// PatternPulse Problem Database
// Single source of truth for all problem data
// Format: leetcodeId -> problem data

const PROBLEM_DATABASE = {
  1: {
      "title": "Two Sum",
      "slug": "two-sum",
      "difficulty": "easy",
      "lists": [
          "neetcode-150",
          "leetcode-75"
      ],
      "category": "Arrays & Hashing",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Two Pointers"
      ],
      "patternExplanations": {
          "Hash Map": "Store each number's index as you iterate. For each number, check if (target - num) exists in the map. This gives O(1) lookup for complements.",
          "Two Pointers": "If you sort first, use left/right pointers moving inward. However, you'd need to track original indices, making Hash Map cleaner for this problem."
      },
      "hints": [
          "For each number, what other number would you need to reach the target?",
          "Instead of checking every pair (O(n^2)), can you remember what you've seen before?",
          "What data structure lets you check 'have I seen this value?' in O(1) time?"
      ],
      "solution": {
          "approach": "Single-pass hash map: for each num, check if (target - num) is in the map, then add num to the map.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)",
          "keyInsight": "The complement of each number is known instantly, so we just need fast lookup."
      }
  },
  2: {
      "title": "Add Two Numbers",
      "slug": "add-two-numbers",
      "difficulty": "medium",
      "primaryPattern": "Linked List",
      "acceptablePatterns": [],
      "explanation": "Pointer manipulation for reversing, merging, detecting cycles, or finding intersections in linked structures.",
      "lists": [
          "neetcode-150"
      ],
      "category": "Linked List",
      "patternExplanations": {
          "Linked List": "Traverse both lists simultaneously, summing digits plus carry. Create new nodes for each digit of the result."
      },
      "hints": [
          "Think about how you add numbers by hand - digit by digit from right to left.",
          "The lists are already reversed, so you can traverse left to right. What do you need to track between digits?",
          "Keep track of the carry. When sum >= 10, carry = 1 for the next digit."
      ],
      "solution": {
          "approach": "Iterate both lists, sum corresponding digits plus carry. Create new node with sum % 10, carry = sum / 10.",
          "timeComplexity": "O(max(n, m))",
          "spaceComplexity": "O(max(n, m))",
          "keyInsight": "Since lists are reversed, we process from least significant digit - perfect for addition with carry."
      }
  },
  3: {
      "title": "Longest Substring Without Repeating Characters",
      "slug": "longest-substring-without-repeating-characters",
      "difficulty": "medium",
      "lists": [
          "neetcode-150"
      ],
      "category": "Sliding Window",
      "primaryPattern": "Sliding Window",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "patternExplanations": {
          "Sliding Window": "Expand right pointer. When duplicate found, shrink left until no duplicates. Track characters in window with a set.",
          "Hash Map": "Store last seen index of each character. Jump left pointer past duplicate's previous position. Slightly optimized."
      },
      "hints": [
          "Use a window [left, right] representing current substring. When is it valid?",
          "Window is valid when all characters in it are unique. How do you check uniqueness?",
          "When you find a duplicate, slide left pointer until the duplicate is removed."
      ],
      "solution": {
          "approach": "Sliding window with HashSet. Expand right, add char. If duplicate, remove chars from left until valid.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(min(n, alphabet size))",
          "keyInsight": "Maintain a window of unique characters. Shrink from left when uniqueness is violated."
      }
  },
  4: {
      "title": "Median of Two Sorted Arrays",
      "slug": "median-of-two-sorted-arrays",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element.",
      "lists": [
          "neetcode-150"
      ],
      "category": "Binary Search",
      "patternExplanations": {
          "Binary Search": "Binary search on the smaller array to find the correct partition. The partition divides both arrays such that left half <= right half."
      },
      "hints": [
          "The median splits elements into two equal halves. How can you partition two sorted arrays?",
          "If you know how many elements should be on the left, can you binary search for the right partition point?",
          "Binary search on the smaller array. For each partition, check if maxLeft <= minRight for both arrays."
      ],
      "solution": {
          "approach": "Binary search on smaller array for partition point. Verify partition is valid when maxLeftA <= minRightB and maxLeftB <= minRightA.",
          "timeComplexity": "O(log(min(n, m)))",
          "spaceComplexity": "O(1)",
          "keyInsight": "Finding median = finding correct partition. Binary search finds it in log time."
      }
  },
  5: {
      "title": "Longest Palindromic Substring",
      "slug": "longest-palindromic-substring",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Dynamic Programming"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds.",
      "lists": [
          "neetcode-150"
      ],
      "category": "Dynamic Programming",
      "patternExplanations": {
          "Two Pointers": "Expand around each center (both odd and even length palindromes). Track the longest found.",
          "Dynamic Programming": "dp[i][j] = true if s[i..j] is palindrome. Build from smaller substrings to larger."
      },
      "hints": [
          "A palindrome reads the same forwards and backwards. What's at the center?",
          "Try expanding outward from each possible center position.",
          "Don't forget: centers can be between characters (even-length palindromes) or on characters (odd-length)."
      ],
      "solution": {
          "approach": "For each index, expand around center for both odd and even length palindromes. Track longest.",
          "timeComplexity": "O(n^2)",
          "spaceComplexity": "O(1)",
          "keyInsight": "Every palindrome has a center. Expand from center to find all palindromes."
      }
  },
  6: {
      "title": "Zigzag Conversion",
      "slug": "zigzag-conversion",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  7: {
      "title": "Reverse Integer",
      "slug": "reverse-integer",
      "difficulty": "medium",
      "primaryPattern": "Math",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships.",
      "lists": [
          "neetcode-150"
      ],
      "category": "Math",
      "patternExplanations": {
          "Math": "Extract digits using modulo, build reversed number. Check for overflow before each operation."
      },
      "hints": [
          "How do you get the last digit of a number? How do you remove it?",
          "Build the reversed number digit by digit: result = result * 10 + digit.",
          "Watch out for 32-bit integer overflow! Check before multiplying by 10."
      ],
      "solution": {
          "approach": "Pop digits with x % 10, push to result with result * 10 + digit. Check overflow bounds.",
          "timeComplexity": "O(log x)",
          "spaceComplexity": "O(1)",
          "keyInsight": "Use modulo and division to extract and remove digits. Handle overflow carefully."
      }
  },
  8: {
      "title": "String to Integer (atoi)",
      "slug": "string-to-integer-atoi",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  9: {
      "title": "Palindrome Number",
      "slug": "palindrome-number",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  10: {
      "title": "Regular Expression Matching",
      "slug": "regular-expression-matching",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization.",
      "lists": [
          "neetcode-150"
      ],
      "category": "Dynamic Programming",
      "patternExplanations": {
          "Dynamic Programming": "dp[i][j] = does s[0..i] match p[0..j]? Handle '.', '*' cases carefully."
      },
      "hints": [
          "'.' matches any single character. '*' matches zero or more of the preceding element.",
          "Think about what happens with 'a*' - it can match '', 'a', 'aa', 'aaa', etc.",
          "For '*', either use it zero times (skip pattern by 2) or use it once and stay on same pattern position."
      ],
      "solution": {
          "approach": "2D DP where dp[i][j] means s[0..i-1] matches p[0..j-1]. Handle '*' by checking zero or more matches.",
          "timeComplexity": "O(n * m)",
          "spaceComplexity": "O(n * m)",
          "keyInsight": "For '*', check both possibilities: skip the pattern (zero matches) or match and stay."
      }
  },
  11: {
      "title": "Container With Most Water",
      "slug": "container-with-most-water",
      "difficulty": "medium",
      "lists": [
          "neetcode-150",
          "leetcode-75"
      ],
      "category": "Two Pointers",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Greedy"
      ],
      "patternExplanations": {
          "Two Pointers": "Start with widest container (left=0, right=n-1). Move the shorter side inward - moving the taller side can only decrease area.",
          "Greedy": "The greedy choice is always moving the shorter line. You can't improve by moving the taller line since width decreases."
      },
      "hints": [
          "Area = min(height[left], height[right]) × (right - left). Start with max width.",
          "When you move a pointer, width decreases. When is it worth it?",
          "Moving the taller line can never help - the shorter line still limits height. Move the shorter one."
      ],
      "solution": {
          "approach": "Two pointers at ends. Calculate area. Move the pointer with shorter height. Track max area.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "keyInsight": "The shorter line is the bottleneck. Moving it might find a taller line; moving the taller line can't help."
      }
  },
  12: {
      "title": "Integer to Roman",
      "slug": "integer-to-roman",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  13: {
      "title": "Roman to Integer",
      "slug": "roman-to-integer",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  14: {
      "title": "Longest Common Prefix",
      "slug": "longest-common-prefix",
      "difficulty": "easy",
      "primaryPattern": "Trie",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Prefix tree for efficient string operations. Each node represents a character, paths represent strings."
  },
  15: {
      "title": "3Sum",
      "slug": "3sum",
      "difficulty": "medium",
      "lists": [
          "neetcode-150"
      ],
      "category": "Two Pointers",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "patternExplanations": {
          "Two Pointers": "Sort array. Fix one number, then use two pointers on remaining array to find pairs that sum to -fixed. Skip duplicates to avoid repeats.",
          "Hash Map": "For each pair, check if -(a+b) exists. Harder to handle duplicates efficiently. Two pointers cleaner."
      },
      "hints": [
          "If you fix one number, what problem does finding the other two become?",
          "After fixing nums[i], you need two numbers that sum to -nums[i]. Sound familiar?",
          "Sort first. Then for each i, use two pointers on the right portion. Skip duplicate values."
      ],
      "solution": {
          "approach": "Sort. For each i, use two pointers (i+1, n-1) to find pairs summing to -nums[i]. Skip duplicates.",
          "timeComplexity": "O(n^2)",
          "spaceComplexity": "O(1) excluding output",
          "keyInsight": "Reduce 3Sum to multiple 2Sum problems. Sorting enables two-pointer approach."
      }
  },
  16: {
      "title": "3Sum Closest",
      "slug": "3sum-closest",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  17: {
      "title": "Letter Combinations of a Phone Number",
      "slug": "letter-combinations-of-a-phone-number",
      "difficulty": "medium",
      "primaryPattern": "Backtracking",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships.",
      "lists": [
          "neetcode-150",
          "leetcode-75"
      ],
      "category": "Backtracking",
      "patternExplanations": {
          "Backtracking": "Map each digit to letters. Recursively build combinations by choosing one letter per digit."
      },
      "hints": [
          "Each digit maps to 3-4 letters (like a phone keypad). Store this mapping.",
          "For each digit, you need to try each of its possible letters.",
          "Use recursion: process one digit at a time, append each possible letter, then recurse to next digit."
      ],
      "solution": {
          "approach": "Create digit-to-letters map. Backtrack through digits, for each trying all possible letters.",
          "timeComplexity": "O(4^n) where n is digits length",
          "spaceComplexity": "O(n) for recursion depth",
          "keyInsight": "Classic backtracking: at each step, try all choices (letters), recurse, then backtrack."
      }
  },
  18: {
      "title": "4Sum",
      "slug": "4sum",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  19: {
      "title": "Remove Nth Node From End of List",
      "slug": "remove-nth-node-from-end-of-list",
      "difficulty": "medium",
      "lists": [
          "neetcode-150"
      ],
      "category": "Linked List",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Linked List"
      ],
      "patternExplanations": {
          "Two Pointers": "Advance first pointer n steps ahead. Then move both until first hits end. Second is at the node before target.",
          "Linked List": "The fast/slow pointer technique lets you find position from end without knowing list length."
      },
      "hints": [
          "Nth from end means: when fast pointer reaches end, slow pointer is at target.",
          "How far apart should two pointers be so when one reaches end, the other is at nth from end?",
          "Gap of n between pointers. Use dummy node to handle edge case of removing head."
      ],
      "solution": {
          "approach": "Dummy node -> head. Fast moves n+1 ahead, then both move until fast is null. Remove slow.next.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "keyInsight": "Two pointers with fixed gap translate 'from end' into 'from start'."
      }
  },
  20: {
      "title": "Valid Parentheses",
      "slug": "valid-parentheses",
      "difficulty": "easy",
      "lists": [
          "neetcode-150"
      ],
      "category": "Stack",
      "primaryPattern": "Stack",
      "acceptablePatterns": [],
      "patternExplanations": {
          "Stack": "Push opening brackets. For closing brackets, pop and check if it matches. Stack should be empty at end."
      },
      "hints": [
          "Every closing bracket must match the most recent unmatched opening bracket.",
          "What data structure gives you the 'most recent' item?",
          "Push opening brackets. When you see a closing bracket, pop and verify they match."
      ],
      "solution": {
          "approach": "Stack of opening brackets. Pop on closing bracket and verify match. Valid if stack empty at end.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)",
          "keyInsight": "LIFO order of stack matches the nesting structure of balanced brackets."
      }
  },
  21: {
      "title": "Merge Two Sorted Lists",
      "slug": "merge-two-sorted-lists",
      "difficulty": "easy",
      "lists": [
          "neetcode-150"
      ],
      "category": "Linked List",
      "primaryPattern": "Linked List",
      "acceptablePatterns": [
          "Two Pointers"
      ],
      "patternExplanations": {
          "Linked List": "Use a dummy head. Compare current nodes of both lists, append smaller one. Move that list's pointer forward.",
          "Two Pointers": "Two pointers, one for each list. Compare values, advance the pointer with smaller value."
      },
      "hints": [
          "Similar to merge step in merge sort. Compare heads, take smaller.",
          "Use a dummy node to simplify handling the head of result list.",
          "After one list is exhausted, append the rest of the other list."
      ],
      "solution": {
          "approach": "Dummy head, current pointer. Compare l1.val and l2.val, link smaller, advance that pointer. Attach remaining.",
          "timeComplexity": "O(n + m)",
          "spaceComplexity": "O(1)",
          "keyInsight": "Classic merge: always take the smaller element from the two sorted sources."
      }
  },
  22: {
      "title": "Generate Parentheses",
      "slug": "generate-parentheses",
      "difficulty": "medium",
      "primaryPattern": "Backtracking",
      "acceptablePatterns": [],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization.",
      "lists": [
          "neetcode-150"
      ],
      "category": "Backtracking",
      "patternExplanations": {
          "Backtracking": "Track open and close count. Add '(' if open < n, add ')' if close < open. Backtrack when invalid."
      },
      "hints": [
          "A valid sequence has n '(' and n ')'. When can you add each?",
          "You can add '(' anytime you haven't used all n. When can you add ')'?",
          "Add ')' only if you have more '(' than ')' so far. This ensures validity."
      ],
      "solution": {
          "approach": "Backtrack with open/close counts. Add '(' if open < n, add ')' if close < open.",
          "timeComplexity": "O(4^n / sqrt(n)) - Catalan number",
          "spaceComplexity": "O(n)",
          "keyInsight": "The key constraint: at any point, close count <= open count."
      }
  },
  23: {
      "title": "Merge k Sorted Lists",
      "slug": "merge-k-sorted-lists",
      "difficulty": "hard",
      "primaryPattern": "Heap",
      "acceptablePatterns": [
          "Linked List"
      ],
      "explanation": "Pointer manipulation for reversing, merging, detecting cycles, or finding intersections in linked structures.",
      "lists": [
          "neetcode-150"
      ],
      "category": "Linked List",
      "patternExplanations": {
          "Heap": "Use min-heap to always get smallest among all list heads. Pop min, add its next to heap.",
          "Linked List": "Divide and conquer: merge pairs of lists recursively until one remains."
      },
      "hints": [
          "You need to repeatedly find the minimum among k current elements. What data structure helps?",
          "A min-heap can give you the minimum in O(log k) time.",
          "Push all list heads to heap. Pop minimum, add to result, push its next node to heap."
      ],
      "solution": {
          "approach": "Min-heap of size k. Pop smallest, add to result, push popped node's next to heap.",
          "timeComplexity": "O(n log k) where n is total nodes",
          "spaceComplexity": "O(k) for heap",
          "keyInsight": "Heap maintains k candidates efficiently. Each node enters/exits heap once."
      }
  },
  24: {
      "title": "Swap Nodes in Pairs",
      "slug": "swap-nodes-in-pairs",
      "difficulty": "medium",
      "primaryPattern": "Linked List",
      "acceptablePatterns": [
          "DFS"
      ],
      "explanation": "Pointer manipulation for reversing, merging, detecting cycles, or finding intersections in linked structures."
  },
  25: {
      "title": "Reverse Nodes in k-Group",
      "slug": "reverse-nodes-in-k-group",
      "difficulty": "hard",
      "primaryPattern": "Linked List",
      "acceptablePatterns": [],
      "explanation": "Pointer manipulation for reversing, merging, detecting cycles, or finding intersections in linked structures.",
      "lists": [
          "neetcode-150"
      ],
      "category": "Linked List",
      "patternExplanations": {
          "Linked List": "Count k nodes, reverse them, connect to next group. Use recursion or iteration with careful pointer management."
      },
      "hints": [
          "First check if there are k nodes remaining. If not, don't reverse.",
          "Reverse k nodes in-place. What connections need updating?",
          "After reversing a group, the old head becomes the tail. Connect it to the result of recursing on rest."
      ],
      "solution": {
          "approach": "Check k nodes exist. Reverse k nodes. Recursively process rest. Connect reversed tail to recursive result.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n/k) for recursion or O(1) iterative",
          "keyInsight": "Break into subproblems: reverse k, recurse on rest, connect. The tricky part is pointer management."
      }
  },
  26: {
      "title": "Remove Duplicates from Sorted Array",
      "slug": "remove-duplicates-from-sorted-array",
      "difficulty": "easy",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  27: {
      "title": "Remove Element",
      "slug": "remove-element",
      "difficulty": "easy",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  28: {
      "title": "Find the Index of the First Occurrence in a String",
      "slug": "find-the-index-of-the-first-occurrence-in-a-string",
      "difficulty": "easy",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  29: {
      "title": "Divide Two Integers",
      "slug": "divide-two-integers",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  30: {
      "title": "Substring with Concatenation of All Words",
      "slug": "substring-with-concatenation-of-all-words",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Sliding Window"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  31: {
      "title": "Next Permutation",
      "slug": "next-permutation",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  32: {
      "title": "Longest Valid Parentheses",
      "slug": "longest-valid-parentheses",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Stack"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  33: {
      "title": "Search in Rotated Sorted Array",
      "slug": "search-in-rotated-sorted-array",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element.",
      "lists": [
          "neetcode-150"
      ],
      "category": "Binary Search",
      "patternExplanations": {
          "Binary Search": "Find which half is sorted. If target is in sorted half, search there; otherwise search other half."
      },
      "hints": [
          "The array is sorted but rotated. At least one half is always sorted.",
          "Compare mid with left to determine which half is sorted.",
          "If target is in the sorted half's range, search there. Otherwise search the other half."
      ],
      "solution": {
          "approach": "Binary search. Determine sorted half by comparing nums[mid] with nums[left]. Check if target in sorted range.",
          "timeComplexity": "O(log n)",
          "spaceComplexity": "O(1)",
          "keyInsight": "One half is always sorted. Use that to decide which half to search."
      }
  },
  34: {
      "title": "Find First and Last Position of Element in Sorted Array",
      "slug": "find-first-and-last-position-of-element-in-sorted-array",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  35: {
      "title": "Search Insert Position",
      "slug": "search-insert-position",
      "difficulty": "easy",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  36: {
      "title": "Valid Sudoku",
      "slug": "valid-sudoku",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships.",
      "lists": [
          "neetcode-150"
      ],
      "category": "Arrays & Hashing",
      "patternExplanations": {
          "Hash Map": "Use sets to track seen numbers in each row, column, and 3x3 box. Check for duplicates."
      },
      "hints": [
          "Each row, column, and 3x3 box must contain unique digits 1-9.",
          "How do you identify which 3x3 box a cell belongs to?",
          "Box index = (row / 3) * 3 + (col / 3). Use sets to track seen numbers in each row, col, and box."
      ],
      "solution": {
          "approach": "Use 9 sets for rows, 9 for columns, 9 for boxes. For each cell, check if number already in its row/col/box set.",
          "timeComplexity": "O(81) = O(1)",
          "spaceComplexity": "O(81) = O(1)",
          "keyInsight": "Box index formula: (row/3)*3 + (col/3) maps each cell to its 3x3 box."
      }
  },
  37: {
      "title": "Sudoku Solver",
      "slug": "sudoku-solver",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Backtracking",
          "DFS"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  38: {
      "title": "Count and Say",
      "slug": "count-and-say",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  39: {
      "title": "Combination Sum",
      "slug": "combination-sum",
      "difficulty": "medium",
      "lists": [
          "neetcode-150"
      ],
      "category": "Backtracking",
      "primaryPattern": "Backtracking",
      "acceptablePatterns": [],
      "patternExplanations": {
          "Backtracking": "Try adding each candidate (can reuse). If sum = target, record. If sum > target, backtrack. Recurse."
      },
      "hints": [
          "Can use same number multiple times. When should you stop adding?",
          "Build combination by adding candidates. If you overshoot target, backtrack.",
          "To avoid duplicates like [2,3] and [3,2], only consider candidates from current index onward."
      ],
      "solution": {
          "approach": "Backtrack with index, current combination, current sum. For each candidate from index onward, try including it (recurse with same index).",
          "timeComplexity": "O(n^(target/min))",
          "spaceComplexity": "O(target/min)",
          "keyInsight": "Allowing repeats means recursing with same index. Starting from index i avoids duplicates."
      }
  },
  40: {
      "title": "Combination Sum II",
      "slug": "combination-sum-ii",
      "difficulty": "medium",
      "primaryPattern": "Backtracking",
      "acceptablePatterns": [],
      "explanation": "Explore all possible solutions recursively. Build candidates incrementally and abandon paths that cannot lead to solution.",
      "lists": [
          "neetcode-150"
      ],
      "category": "Backtracking",
      "patternExplanations": {
          "Backtracking": "Sort array first. Skip duplicates at same recursion level to avoid duplicate combinations."
      },
      "hints": [
          "Similar to Combination Sum, but each number can only be used once.",
          "How do you avoid duplicate combinations like [1,2,2] appearing twice?",
          "Sort the array. At each level, skip duplicate numbers after the first one."
      ],
      "solution": {
          "approach": "Sort input. Backtrack, but skip duplicates: if candidates[i] == candidates[i-1] and we didn't use i-1, skip i.",
          "timeComplexity": "O(2^n)",
          "spaceComplexity": "O(n)",
          "keyInsight": "Sorting + skipping consecutive duplicates at same level prevents duplicate combinations."
      }
  },
  41: {
      "title": "First Missing Positive",
      "slug": "first-missing-positive",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  42: {
      "title": "Trapping Rain Water",
      "slug": "trapping-rain-water",
      "difficulty": "hard",
      "lists": [
          "neetcode-150"
      ],
      "category": "Two Pointers",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Dynamic Programming",
          "Stack"
      ],
      "patternExplanations": {
          "Two Pointers": "Water at position i = min(maxLeft, maxRight) - height[i]. Use two pointers tracking running max from each side. Process the smaller side.",
          "Dynamic Programming": "Precompute maxLeft[i] and maxRight[i] arrays. Water at i = min(maxLeft[i], maxRight[i]) - height[i]. O(n) space.",
          "Stack": "Use monotonic decreasing stack. When you find a taller bar, pop and calculate water trapped in the 'valley'. More complex."
      },
      "hints": [
          "Water at any position depends on the tallest bars to its left and right. Why?",
          "Water level = min(tallest left, tallest right). Water trapped = water level - ground height.",
          "Can you track left max and right max as you go, without precomputing?"
      ],
      "solution": {
          "approach": "Two pointers with leftMax and rightMax. Process from the side with smaller max (that side determines water level).",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "keyInsight": "Water level at any point is determined by the minimum of the maximum heights on either side."
      }
  },
  43: {
      "title": "Multiply Strings",
      "slug": "multiply-strings",
      "difficulty": "medium",
      "primaryPattern": "Math",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships.",
      "lists": [
          "neetcode-150"
      ],
      "category": "Math",
      "patternExplanations": {
          "Math": "Multiply digit by digit like grade school multiplication. Handle positions: digit at i and j contributes to position i+j."
      },
      "hints": [
          "Think about how you multiply numbers by hand - digit by digit.",
          "When you multiply digit at position i with digit at position j, where does the result go?",
          "Result of num1[i] * num2[j] goes to positions [i+j, i+j+1]. Use an array to accumulate."
      ],
      "solution": {
          "approach": "Create result array of length m+n. For each pair of digits, add product to appropriate positions with carry.",
          "timeComplexity": "O(m * n)",
          "spaceComplexity": "O(m + n)",
          "keyInsight": "Position math: product of digits at i,j affects positions i+j and i+j+1."
      }
  },
  44: {
      "title": "Wildcard Matching",
      "slug": "wildcard-matching",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy",
          "DFS"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  45: {
      "title": "Jump Game II",
      "slug": "jump-game-ii",
      "difficulty": "medium",
      "lists": [
          "neetcode-150"
      ],
      "category": "Greedy",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Dynamic Programming",
          "BFS"
      ],
      "patternExplanations": {
          "Greedy": "Track current range boundary and farthest reachable. When you hit boundary, increment jumps and extend boundary.",
          "BFS": "BFS where level = number of jumps. From each index, you can reach indices up to i + nums[i].",
          "Dynamic Programming": "dp[i] = min jumps to reach i. O(n^2). Greedy is O(n)."
      },
      "hints": [
          "Find minimum jumps to reach the end.",
          "Greedy: from current range, find the farthest you can reach. That becomes next range.",
          "When you must take a jump (reached end of current range), increment jump count."
      ],
      "solution": {
          "approach": "Track jumps, current end, farthest. When i reaches current end, jumps++, current end = farthest.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "keyInsight": "Each jump expands to the farthest reachable from the current range."
      }
  },
  46: {
      "title": "Permutations",
      "slug": "permutations",
      "difficulty": "medium",
      "lists": [
          "neetcode-150"
      ],
      "category": "Backtracking",
      "primaryPattern": "Backtracking",
      "acceptablePatterns": [],
      "patternExplanations": {
          "Backtracking": "Build permutation by choosing unused elements. Use visited set or swap-based approach."
      },
      "hints": [
          "Permutation = arrangement using all elements exactly once.",
          "At each position, try every unused number. Mark as used, recurse, unmark.",
          "Or use swapping: swap element at current position with each element from current to end."
      ],
      "solution": {
          "approach": "Backtrack: track used elements. At each step, try adding each unused element, recurse, then remove.",
          "timeComplexity": "O(n! * n)",
          "spaceComplexity": "O(n)",
          "keyInsight": "Permutations are about ordering all elements - explore all orderings via backtracking."
      }
  },
  47: {
      "title": "Permutations II",
      "slug": "permutations-ii",
      "difficulty": "medium",
      "primaryPattern": "Backtracking",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Explore all possible solutions recursively. Build candidates incrementally and abandon paths that cannot lead to solution."
  },
  48: {
      "title": "Rotate Image",
      "slug": "rotate-image",
      "difficulty": "medium",
      "primaryPattern": "Math",
      "acceptablePatterns": [],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation.",
      "lists": [
          "neetcode-150"
      ],
      "category": "Math & Geometry",
      "patternExplanations": {
          "Math": "Rotate 90° clockwise = transpose + reverse each row. Or do it in-place by rotating 4 cells at a time."
      },
      "hints": [
          "90° clockwise rotation: element at (i,j) goes to (j, n-1-i).",
          "Can you do it in-place? Think of rotating 4 elements at a time.",
          "Easier approach: transpose the matrix (swap rows and columns), then reverse each row."
      ],
      "solution": {
          "approach": "Transpose matrix (swap matrix[i][j] with matrix[j][i]), then reverse each row.",
          "timeComplexity": "O(n^2)",
          "spaceComplexity": "O(1)",
          "keyInsight": "90° rotation = transpose + reverse rows. 270° = transpose + reverse columns."
      }
  },
  49: {
      "title": "Group Anagrams",
      "slug": "group-anagrams",
      "difficulty": "medium",
      "lists": [
          "neetcode-150"
      ],
      "category": "Arrays & Hashing",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "patternExplanations": {
          "Hash Map": "Use sorted string (or character count) as the key. All anagrams map to the same key, grouping them automatically."
      },
      "hints": [
          "How can you create a 'signature' that's the same for all anagrams?",
          "If you sort 'eat' and 'tea', what do you get?",
          "Use this signature as a hash map key to group words together."
      ],
      "solution": {
          "approach": "For each word, create a key (sorted string or char frequency tuple). Map key -> list of words.",
          "timeComplexity": "O(n * k log k) where k is max word length",
          "spaceComplexity": "O(n * k)",
          "keyInsight": "A canonical form (sorted string) makes all anagrams hash to the same bucket."
      }
  },
  50: {
      "title": "Pow(x, n)",
      "slug": "powx-n",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Math"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation.",
      "lists": [
          "neetcode-150"
      ],
      "category": "Math",
      "patternExplanations": {
          "Binary Search": "Use binary exponentiation: x^n = (x^(n/2))^2. Halve the exponent each step.",
          "Math": "Fast power algorithm: if n is even, x^n = (x^2)^(n/2). If odd, x^n = x * x^(n-1)."
      },
      "hints": [
          "Computing x^n by multiplying x n times is O(n). Can you do better?",
          "x^10 = x^5 * x^5. x^5 = x * x^4 = x * (x^2)^2. See the pattern?",
          "Handle negative exponents: x^(-n) = 1 / x^n. Be careful with integer overflow."
      ],
      "solution": {
          "approach": "Binary exponentiation: if n even, return pow(x*x, n/2). If odd, return x * pow(x, n-1).",
          "timeComplexity": "O(log n)",
          "spaceComplexity": "O(log n) or O(1) iterative",
          "keyInsight": "Halving the exponent each time gives logarithmic complexity."
      }
  },
  51: {
      "title": "N-Queens",
      "slug": "n-queens",
      "difficulty": "hard",
      "primaryPattern": "Backtracking",
      "acceptablePatterns": [],
      "explanation": "Explore all possible solutions recursively. Build candidates incrementally and abandon paths that cannot lead to solution.",
      "lists": [
          "neetcode-150"
      ],
      "category": "Backtracking",
      "patternExplanations": {
          "Backtracking": "Place queens row by row. Track attacked columns and diagonals. Backtrack when no valid position."
      },
      "hints": [
          "Place one queen per row. For each row, try each column.",
          "Queens attack along columns and diagonals. How do you track which are occupied?",
          "For diagonals: cells on same diagonal have same (row-col) or (row+col). Use sets to track."
      ],
      "solution": {
          "approach": "Backtrack row by row. Use sets for columns, positive diagonals (r-c), negative diagonals (r+c).",
          "timeComplexity": "O(n!)",
          "spaceComplexity": "O(n)",
          "keyInsight": "Diagonal tracking: same r-c = same \\ diagonal, same r+c = same / diagonal."
      }
  },
  52: {
      "title": "N-Queens II",
      "slug": "n-queens-ii",
      "difficulty": "hard",
      "primaryPattern": "Backtracking",
      "acceptablePatterns": [],
      "explanation": "Explore all possible solutions recursively. Build candidates incrementally and abandon paths that cannot lead to solution."
  },
  53: {
      "title": "Maximum Subarray",
      "slug": "maximum-subarray",
      "difficulty": "medium",
      "lists": [
          "neetcode-150"
      ],
      "category": "Greedy",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Dynamic Programming",
          "Divide and Conquer"
      ],
      "patternExplanations": {
          "Greedy": "Kadane's algorithm: track current sum. If it goes negative, reset to 0 (start new subarray). Track max seen.",
          "Dynamic Programming": "dp[i] = max subarray ending at i = max(nums[i], dp[i-1] + nums[i]). Same as Kadane's.",
          "Divide and Conquer": "Max subarray is in left half, right half, or crosses middle. O(n log n)."
      },
      "hints": [
          "At each position, should you extend the previous subarray or start fresh?",
          "If the sum so far is negative, it can only hurt the next elements. Better to start over.",
          "Track max sum ending at current position. Answer is max over all positions."
      ],
      "solution": {
          "approach": "Kadane's: currentSum = max(nums[i], currentSum + nums[i]). maxSum = max(maxSum, currentSum).",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "keyInsight": "A negative prefix sum never helps - reset and start fresh."
      }
  },
  54: {
      "title": "Spiral Matrix",
      "slug": "spiral-matrix",
      "difficulty": "medium",
      "primaryPattern": "Math",
      "acceptablePatterns": [],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation.",
      "lists": [
          "neetcode-150"
      ],
      "category": "Math & Geometry",
      "patternExplanations": {
          "Math": "Track boundaries (top, bottom, left, right). Traverse in spiral order, shrinking boundaries after each edge."
      },
      "hints": [
          "Traverse right, then down, then left, then up. Repeat.",
          "Track four boundaries. After traversing an edge, shrink that boundary.",
          "Be careful with edge cases: single row, single column, or when boundaries cross."
      ],
      "solution": {
          "approach": "Maintain top/bottom/left/right bounds. Traverse in order: right, down, left, up. Shrink bounds after each.",
          "timeComplexity": "O(m * n)",
          "spaceComplexity": "O(1) excluding output",
          "keyInsight": "Four boundaries define the current layer. Shrink inward after completing each direction."
      }
  },
  55: {
      "title": "Jump Game",
      "slug": "jump-game",
      "difficulty": "medium",
      "lists": [
          "neetcode-150"
      ],
      "category": "Greedy",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Dynamic Programming"
      ],
      "patternExplanations": {
          "Greedy": "Track farthest reachable index. If current index > farthest, can't reach it. If farthest >= last index, success.",
          "Dynamic Programming": "dp[i] = can reach index i? Check if any j < i can reach i. O(n^2), greedy is better."
      },
      "hints": [
          "Can you reach the last index starting from index 0?",
          "At each step, update the farthest index you can reach.",
          "If at any point your current index exceeds farthest reachable, you're stuck."
      ],
      "solution": {
          "approach": "Track maxReach. For each i from 0: if i > maxReach, return false. Update maxReach = max(maxReach, i + nums[i]).",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "keyInsight": "Greedily track the frontier of reachable indices."
      }
  },
  56: {
      "title": "Merge Intervals",
      "slug": "merge-intervals",
      "difficulty": "medium",
      "lists": [
          "neetcode-150"
      ],
      "category": "Intervals",
      "primaryPattern": "Sorting",
      "acceptablePatterns": [
          "Greedy"
      ],
      "patternExplanations": {
          "Sorting": "Sort by start time. Iterate and merge overlapping intervals. Overlap: current start <= previous end.",
          "Greedy": "After sorting, greedily extend intervals when they overlap."
      },
      "hints": [
          "How do you know if two intervals overlap?",
          "Sort by start time. Then consecutive intervals that overlap can be merged.",
          "If current interval starts before/at previous end, merge. Else start new interval."
      ],
      "solution": {
          "approach": "Sort by start. For each interval: if overlaps with last in result, extend end. Else add new interval.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(n)",
          "keyInsight": "Sorting by start lets you merge overlapping intervals in a single pass."
      }
  },
  57: {
      "title": "Insert Interval",
      "slug": "insert-interval",
      "difficulty": "medium",
      "lists": [
          "neetcode-150"
      ],
      "category": "Intervals",
      "primaryPattern": "Sorting",
      "acceptablePatterns": [
          "Greedy"
      ],
      "patternExplanations": {
          "Sorting": "Intervals already sorted. Add intervals that end before new one starts. Merge overlapping. Add remaining.",
          "Greedy": "Three phases: add all intervals before new one, merge all overlapping with new one, add all after."
      },
      "hints": [
          "Intervals are already sorted. Where does the new interval fit?",
          "First, add intervals that end before new one starts. Then merge overlaps. Finally, add intervals that start after.",
          "During merge phase, keep extending the interval's end while there's overlap."
      ],
      "solution": {
          "approach": "Add intervals with end < newStart. Merge all overlapping. Add intervals with start > newEnd.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)",
          "keyInsight": "Sorted intervals let you handle insert with a single pass."
      }
  },
  58: {
      "title": "Length of Last Word",
      "slug": "length-of-last-word",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  59: {
      "title": "Spiral Matrix II",
      "slug": "spiral-matrix-ii",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  60: {
      "title": "Permutation Sequence",
      "slug": "permutation-sequence",
      "difficulty": "hard",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  61: {
      "title": "Rotate List",
      "slug": "rotate-list",
      "difficulty": "medium",
      "primaryPattern": "Linked List",
      "acceptablePatterns": [
          "Two Pointers"
      ],
      "explanation": "Pointer manipulation for reversing, merging, detecting cycles, or finding intersections in linked structures."
  },
  62: {
      "title": "Unique Paths",
      "slug": "unique-paths",
      "difficulty": "medium",
      "lists": [
          "neetcode-150",
          "leetcode-75"
      ],
      "category": "2-D Dynamic Programming",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [],
      "patternExplanations": {
          "Dynamic Programming": "dp[i][j] = paths to reach (i,j). Can only come from top or left: dp[i][j] = dp[i-1][j] + dp[i][j-1]."
      },
      "hints": [
          "Can only move right or down. How many ways to reach cell (i,j)?",
          "To reach (i,j), you came from (i-1,j) or (i,j-1). Sum the ways to reach those.",
          "First row and column have only 1 way each (all right or all down)."
      ],
      "solution": {
          "approach": "dp[i][j] = dp[i-1][j] + dp[i][j-1]. Initialize first row and column to 1. Can optimize to O(n) space.",
          "timeComplexity": "O(m * n)",
          "spaceComplexity": "O(n)",
          "keyInsight": "Path counting on grid: each cell's paths = sum of paths to cells you can come from."
      }
  },
  63: {
      "title": "Unique Paths II",
      "slug": "unique-paths-ii",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "DFS"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  64: {
      "title": "Minimum Path Sum",
      "slug": "minimum-path-sum",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "DFS"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  65: {
      "title": "Valid Number",
      "slug": "valid-number",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  66: {
      "title": "Plus One",
      "slug": "plus-one",
      "difficulty": "easy",
      "primaryPattern": "Math",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships.",
      "lists": [
          "neetcode-150"
      ],
      "category": "Math",
      "patternExplanations": {
          "Math": "Add 1 to last digit. Handle carry by propagating left. If carry remains, prepend 1."
      },
      "hints": [
          "Start from the last digit. Add 1. What if it becomes 10?",
          "Carry propagates left. What if all digits are 9?",
          "If you finish the loop with carry, you need to prepend a 1 (e.g., 999 + 1 = 1000)."
      ],
      "solution": {
          "approach": "Iterate from right. Add 1, if < 10 done. If 10, set to 0 and continue. If loop ends, prepend 1.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1) or O(n) if new array needed",
          "keyInsight": "Most cases: just increment last digit. Carry only propagates for trailing 9s."
      }
  },
  67: {
      "title": "Add Binary",
      "slug": "add-binary",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  68: {
      "title": "Text Justification",
      "slug": "text-justification",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  69: {
      "title": "Sqrt(x)",
      "slug": "sqrtx",
      "difficulty": "easy",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  70: {
      "title": "Climbing Stairs",
      "slug": "climbing-stairs",
      "difficulty": "easy",
      "lists": [
          "neetcode-150"
      ],
      "category": "1-D Dynamic Programming",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [],
      "patternExplanations": {
          "Dynamic Programming": "ways(n) = ways(n-1) + ways(n-2). Either take 1 step from n-1, or 2 steps from n-2. Base: ways(1)=1, ways(2)=2."
      },
      "hints": [
          "To reach step n, what's the last move you could make?",
          "You either came from step n-1 (took 1 step) or from step n-2 (took 2 steps).",
          "This is exactly the Fibonacci sequence! ways[n] = ways[n-1] + ways[n-2]."
      ],
      "solution": {
          "approach": "DP: dp[i] = dp[i-1] + dp[i-2]. Can optimize to O(1) space with two variables.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "keyInsight": "The number of ways to reach step n is the sum of ways to reach n-1 and n-2."
      }
  },
  71: {
      "title": "Simplify Path",
      "slug": "simplify-path",
      "difficulty": "medium",
      "primaryPattern": "Stack",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "LIFO structure for nested patterns, matching pairs, or maintaining monotonic sequences."
  },
  72: {
      "title": "Edit Distance",
      "slug": "edit-distance",
      "difficulty": "medium",
      "lists": [
          "neetcode-150",
          "leetcode-75"
      ],
      "category": "2-D Dynamic Programming",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [],
      "patternExplanations": {
          "Dynamic Programming": "dp[i][j] = min ops to convert word1[0:i] to word2[0:j]. If match: dp[i-1][j-1]. Else: 1 + min of insert, delete, replace."
      },
      "hints": [
          "Three operations: insert, delete, replace. What's the minimum to transform word1 to word2?",
          "If last characters match, no operation needed there. If not, try all three operations.",
          "Insert = dp[i][j-1], Delete = dp[i-1][j], Replace = dp[i-1][j-1]. Take min and add 1."
      ],
      "solution": {
          "approach": "dp[i][j] = dp[i-1][j-1] if match, else 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]).",
          "timeComplexity": "O(m * n)",
          "spaceComplexity": "O(m * n)",
          "keyInsight": "Each cell considers all three operations and takes the best one."
      }
  },
  73: {
      "title": "Set Matrix Zeroes",
      "slug": "set-matrix-zeroes",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships.",
      "lists": [
          "neetcode-150"
      ],
      "category": "Arrays & Hashing",
      "patternExplanations": {
          "Hash Map": "Use first row and column as markers. Track which rows/cols need zeroing, then apply."
      },
      "hints": [
          "If you use O(m+n) space, track which rows and columns contain zeros.",
          "Can you use the matrix itself to store this information?",
          "Use first row and first column as markers. Handle the first row/col separately."
      ],
      "solution": {
          "approach": "Use first row/col as flags. First pass: mark. Second pass: zero out based on marks. Handle first row/col last.",
          "timeComplexity": "O(m * n)",
          "spaceComplexity": "O(1)",
          "keyInsight": "The matrix's first row and column can serve as the marker arrays."
      }
  },
  74: {
      "title": "Search a 2D Matrix",
      "slug": "search-a-2d-matrix",
      "difficulty": "medium",
      "lists": [
          "neetcode-150"
      ],
      "category": "Binary Search",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [],
      "patternExplanations": {
          "Binary Search": "Treat the 2D matrix as a sorted 1D array. Index i maps to matrix[i/cols][i%cols]. Standard binary search."
      },
      "hints": [
          "Each row is sorted, and first element of each row > last element of previous row.",
          "If you 'flattened' the matrix into one array, it would be fully sorted.",
          "Binary search on virtual 1D array. Convert 1D index to 2D: row = idx/cols, col = idx%cols."
      ],
      "solution": {
          "approach": "Binary search treating matrix as 1D array. Convert indices: matrix[mid/cols][mid%cols].",
          "timeComplexity": "O(log(m*n))",
          "spaceComplexity": "O(1)",
          "keyInsight": "The matrix is essentially a sorted 1D array stored in 2D format."
      }
  },
  75: {
      "title": "Sort Colors",
      "slug": "sort-colors",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  76: {
      "title": "Minimum Window Substring",
      "slug": "minimum-window-substring",
      "difficulty": "hard",
      "primaryPattern": "Sliding Window",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships.",
      "lists": [
          "neetcode-150"
      ],
      "category": "Sliding Window",
      "patternExplanations": {
          "Sliding Window": "Expand right to include chars, shrink left when all t chars are covered. Track minimum window.",
          "Hash Map": "Use hashmap to count required chars. Window is valid when all counts are satisfied."
      },
      "hints": [
          "Use sliding window. When is the window valid?",
          "Track character counts needed from t. Window is valid when all counts are met.",
          "Expand right until valid, then shrink left while maintaining validity to find minimum."
      ],
      "solution": {
          "approach": "Hashmap for required counts. Expand right, add to window. When valid, shrink left, update min.",
          "timeComplexity": "O(m + n)",
          "spaceComplexity": "O(m + n)",
          "keyInsight": "Two-phase window: expand to satisfy, shrink to minimize."
      }
  },
  77: {
      "title": "Combinations",
      "slug": "combinations",
      "difficulty": "medium",
      "primaryPattern": "Backtracking",
      "acceptablePatterns": [],
      "explanation": "Explore all possible solutions recursively. Build candidates incrementally and abandon paths that cannot lead to solution."
  },
  78: {
      "title": "Subsets",
      "slug": "subsets",
      "difficulty": "medium",
      "lists": [
          "neetcode-150"
      ],
      "category": "Backtracking",
      "primaryPattern": "Backtracking",
      "acceptablePatterns": [
          "Bit Manipulation"
      ],
      "patternExplanations": {
          "Backtracking": "For each element, choose to include or exclude it. Recurse. At end, add current subset to result.",
          "Bit Manipulation": "Each subset maps to binary number 0 to 2^n-1. Bit i set = include element i."
      },
      "hints": [
          "Each element is either in the subset or not. That's a binary choice.",
          "Start empty. For each element, you can add it or skip it. Explore both paths.",
          "Backtracking: add element, recurse, remove element (backtrack), recurse without it."
      ],
      "solution": {
          "approach": "Backtrack: for index i, add nums[i] to current, recurse, then remove it and recurse again (or iterate from i).",
          "timeComplexity": "O(n * 2^n)",
          "spaceComplexity": "O(n) recursion depth",
          "keyInsight": "Subsets = all combinations of include/exclude decisions for each element."
      }
  },
  79: {
      "title": "Word Search",
      "slug": "word-search",
      "difficulty": "medium",
      "lists": [
          "neetcode-150"
      ],
      "category": "Backtracking",
      "primaryPattern": "Backtracking",
      "acceptablePatterns": [
          "DFS"
      ],
      "patternExplanations": {
          "Backtracking": "DFS from each cell. Try all 4 directions. Mark cell visited during path, unmark when backtracking.",
          "DFS": "Explore paths in the grid matching the word. Backtrack when path doesn't match."
      },
      "hints": [
          "Start DFS from any cell matching word[0]. Explore adjacent cells for word[1], etc.",
          "Need to avoid revisiting cells in current path. How to track this?",
          "Mark cell as visited (e.g., change to '#'), recurse, then restore original value."
      ],
      "solution": {
          "approach": "For each cell, if matches word[0], DFS trying to match rest. Mark visited, explore 4 directions, backtrack.",
          "timeComplexity": "O(m * n * 4^L)",
          "spaceComplexity": "O(L) recursion",
          "keyInsight": "Grid search with path constraint = DFS with backtracking to unmark visited cells."
      }
  },
  80: {
      "title": "Remove Duplicates from Sorted Array II",
      "slug": "remove-duplicates-from-sorted-array-ii",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  81: {
      "title": "Search in Rotated Sorted Array II",
      "slug": "search-in-rotated-sorted-array-ii",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  82: {
      "title": "Remove Duplicates from Sorted List II",
      "slug": "remove-duplicates-from-sorted-list-ii",
      "difficulty": "medium",
      "primaryPattern": "Linked List",
      "acceptablePatterns": [
          "Two Pointers"
      ],
      "explanation": "Pointer manipulation for reversing, merging, detecting cycles, or finding intersections in linked structures."
  },
  83: {
      "title": "Remove Duplicates from Sorted List",
      "slug": "remove-duplicates-from-sorted-list",
      "difficulty": "easy",
      "primaryPattern": "Linked List",
      "acceptablePatterns": [],
      "explanation": "Pointer manipulation for reversing, merging, detecting cycles, or finding intersections in linked structures."
  },
  84: {
      "title": "Largest Rectangle in Histogram",
      "slug": "largest-rectangle-in-histogram",
      "difficulty": "hard",
      "primaryPattern": "Stack",
      "acceptablePatterns": [],
      "explanation": "LIFO structure for nested patterns, matching pairs, or maintaining monotonic sequences.",
      "lists": [
          "neetcode-150"
      ],
      "category": "Stack",
      "patternExplanations": {
          "Stack": "Monotonic increasing stack. When bar is shorter, pop and calculate area with popped bar as height."
      },
      "hints": [
          "For each bar, you need to know how far left and right it can extend.",
          "A bar can extend until it hits a shorter bar. Use stack to track previous shorter bars.",
          "Maintain increasing stack of indices. When current < stack top, pop and calculate area."
      ],
      "solution": {
          "approach": "Monotonic increasing stack of indices. On smaller bar, pop and compute area using width from indices.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)",
          "keyInsight": "Stack gives us left boundary (previous smaller). Current position gives right boundary."
      }
  },
  85: {
      "title": "Maximal Rectangle",
      "slug": "maximal-rectangle",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Stack",
          "DFS"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  86: {
      "title": "Partition List",
      "slug": "partition-list",
      "difficulty": "medium",
      "primaryPattern": "Linked List",
      "acceptablePatterns": [
          "Two Pointers"
      ],
      "explanation": "Pointer manipulation for reversing, merging, detecting cycles, or finding intersections in linked structures."
  },
  87: {
      "title": "Scramble String",
      "slug": "scramble-string",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  88: {
      "title": "Merge Sorted Array",
      "slug": "merge-sorted-array",
      "difficulty": "easy",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  89: {
      "title": "Gray Code",
      "slug": "gray-code",
      "difficulty": "medium",
      "primaryPattern": "Backtracking",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Explore all possible solutions recursively. Build candidates incrementally and abandon paths that cannot lead to solution."
  },
  90: {
      "title": "Subsets II",
      "slug": "subsets-ii",
      "difficulty": "medium",
      "primaryPattern": "Backtracking",
      "acceptablePatterns": [],
      "explanation": "Explore all possible solutions recursively. Build candidates incrementally and abandon paths that cannot lead to solution.",
      "lists": [
          "neetcode-150"
      ],
      "category": "Backtracking",
      "patternExplanations": {
          "Backtracking": "Sort first. Skip duplicate elements at same recursion level to avoid duplicate subsets."
      },
      "hints": [
          "Similar to Subsets I, but with duplicates. How to avoid duplicate subsets?",
          "If you have [1,2,2], choosing first 2 vs second 2 gives same subset.",
          "Sort the array. At each position, skip elements equal to previous if previous wasn't included."
      ],
      "solution": {
          "approach": "Sort input. Backtrack with choice to include/exclude. Skip duplicate choices at same level.",
          "timeComplexity": "O(n * 2^n)",
          "spaceComplexity": "O(n)",
          "keyInsight": "Sorting + skipping consecutive duplicates prevents duplicate subsets."
      }
  },
  91: {
      "title": "Decode Ways",
      "slug": "decode-ways",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization.",
      "lists": [
          "neetcode-150"
      ],
      "category": "Dynamic Programming",
      "patternExplanations": {
          "Dynamic Programming": "dp[i] = ways to decode s[0..i]. Can use one digit (1-9) or two digits (10-26)."
      },
      "hints": [
          "At each position, you can decode 1 digit or 2 digits (if valid).",
          "Valid single digit: 1-9. Valid two digits: 10-26.",
          "dp[i] = dp[i-1] (if single digit valid) + dp[i-2] (if two digits valid)."
      ],
      "solution": {
          "approach": "DP where dp[i] = ways to decode first i chars. Add dp[i-1] if s[i-1] is 1-9, add dp[i-2] if s[i-2..i-1] is 10-26.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n) or O(1)",
          "keyInsight": "Each position depends on previous 1 or 2 positions, like Fibonacci."
      }
  },
  92: {
      "title": "Reverse Linked List II",
      "slug": "reverse-linked-list-ii",
      "difficulty": "medium",
      "primaryPattern": "Linked List",
      "acceptablePatterns": [],
      "explanation": "Pointer manipulation for reversing, merging, detecting cycles, or finding intersections in linked structures."
  },
  93: {
      "title": "Restore IP Addresses",
      "slug": "restore-ip-addresses",
      "difficulty": "medium",
      "primaryPattern": "Backtracking",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Explore all possible solutions recursively. Build candidates incrementally and abandon paths that cannot lead to solution."
  },
  94: {
      "title": "Binary Tree Inorder Traversal",
      "slug": "binary-tree-inorder-traversal",
      "difficulty": "easy",
      "primaryPattern": "Stack",
      "acceptablePatterns": [
          "Tree Traversal",
          "DFS"
      ],
      "explanation": "LIFO structure for nested patterns, matching pairs, or maintaining monotonic sequences."
  },
  95: {
      "title": "Unique Binary Search Trees II",
      "slug": "unique-binary-search-trees-ii",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Backtracking",
          "Tree Traversal"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  96: {
      "title": "Unique Binary Search Trees",
      "slug": "unique-binary-search-trees",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Tree Traversal"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  97: {
      "title": "Interleaving String",
      "slug": "interleaving-string",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization.",
      "lists": [
          "neetcode-150"
      ],
      "category": "Dynamic Programming",
      "patternExplanations": {
          "Dynamic Programming": "dp[i][j] = can s1[0..i] and s2[0..j] interleave to form s3[0..i+j]? Check if next char matches."
      },
      "hints": [
          "s3[k] must come from either s1 or s2. Track positions in both.",
          "dp[i][j] = true if first i chars of s1 and first j chars of s2 can form first i+j chars of s3.",
          "Transition: dp[i][j] = (s1[i-1]==s3[i+j-1] && dp[i-1][j]) || (s2[j-1]==s3[i+j-1] && dp[i][j-1])."
      ],
      "solution": {
          "approach": "2D DP. dp[i][j] true if s1[0..i-1] and s2[0..j-1] interleave to s3[0..i+j-1]. Check both transitions.",
          "timeComplexity": "O(m * n)",
          "spaceComplexity": "O(m * n) or O(n)",
          "keyInsight": "At each step, the next char in s3 must match either the next from s1 or s2."
      }
  },
  98: {
      "title": "Validate Binary Search Tree",
      "slug": "validate-binary-search-tree",
      "difficulty": "medium",
      "lists": [
          "neetcode-150"
      ],
      "category": "Trees",
      "primaryPattern": "DFS",
      "acceptablePatterns": [],
      "patternExplanations": {
          "DFS": "Each node has valid range (min, max). Root: (-inf, inf). Left child: (min, parent). Right child: (parent, max)."
      },
      "hints": [
          "BST property: left < root < right. But it's not just immediate children - ALL left descendants < root.",
          "Each node must be within a valid range. What determines that range?",
          "Pass min and max bounds down. Left child's max = parent. Right child's min = parent."
      ],
      "solution": {
          "approach": "DFS with min/max bounds. validate(node, min, max): check node in range, recurse with updated bounds.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(h)",
          "keyInsight": "BST validity is about ranges, not just parent-child relationships."
      }
  },
  99: {
      "title": "Recover Binary Search Tree",
      "slug": "recover-binary-search-tree",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Tree Traversal"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  100: {
      "title": "Same Tree",
      "slug": "same-tree",
      "difficulty": "easy",
      "lists": [
          "neetcode-150"
      ],
      "category": "Trees",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "BFS"
      ],
      "patternExplanations": {
          "DFS": "Recursively compare: both null = true, one null = false, values differ = false, else check both subtrees.",
          "BFS": "Compare level by level. Same logic but iterative with queue."
      },
      "hints": [
          "Two trees are same if: same structure AND same values at each position.",
          "Compare root values. If equal, both left subtrees must be same AND both right subtrees must be same.",
          "Base cases: both null = same, exactly one null = different."
      ],
      "solution": {
          "approach": "DFS: if both null return true, if one null return false, if vals differ return false, else recurse on both children.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(h)",
          "keyInsight": "Structural equality check is naturally recursive."
      }
  },
  101: {
      "title": "Symmetric Tree",
      "slug": "symmetric-tree",
      "difficulty": "easy",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Tree Traversal",
          "BFS"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  102: {
      "title": "Binary Tree Level Order Traversal",
      "slug": "binary-tree-level-order-traversal",
      "difficulty": "medium",
      "lists": [
          "neetcode-150"
      ],
      "category": "Trees",
      "primaryPattern": "BFS",
      "acceptablePatterns": [
          "DFS"
      ],
      "patternExplanations": {
          "BFS": "Process level by level using queue. For each level, process all nodes in queue, add their children.",
          "DFS": "Track depth parameter, add node value to result[depth]. Pre-order traversal maintains left-to-right order."
      },
      "hints": [
          "Level order = all nodes at depth 1, then depth 2, etc. This is BFS.",
          "Use a queue. Process all nodes currently in queue (one level), adding their children.",
          "Track level size before processing to know when one level ends and next begins."
      ],
      "solution": {
          "approach": "BFS with queue. For each level: record queue size, process that many nodes, add children to queue.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n) for queue",
          "keyInsight": "BFS naturally visits nodes level by level. Track level boundaries by queue size."
      }
  },
  103: {
      "title": "Binary Tree Zigzag Level Order Traversal",
      "slug": "binary-tree-zigzag-level-order-traversal",
      "difficulty": "medium",
      "primaryPattern": "BFS",
      "acceptablePatterns": [
          "Tree Traversal"
      ],
      "explanation": "Breadth-first search - explore level by level using a queue. Ideal for shortest path in unweighted graphs or level-order traversal."
  },
  104: {
      "title": "Maximum Depth of Binary Tree",
      "slug": "maximum-depth-of-binary-tree",
      "difficulty": "easy",
      "lists": [
          "neetcode-150",
          "leetcode-75"
      ],
      "category": "Trees",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "BFS"
      ],
      "patternExplanations": {
          "DFS": "Depth of node = 1 + max(depth of left subtree, depth of right subtree). Base case: null node has depth 0.",
          "BFS": "Level order traversal, count the number of levels. Each level = one depth unit."
      },
      "hints": [
          "Depth = number of nodes on longest path from root to leaf.",
          "For any node, its depth contribution is 1 + the deeper of its two subtrees.",
          "Recursive: return 1 + max(maxDepth(left), maxDepth(right)). Base: null returns 0."
      ],
      "solution": {
          "approach": "DFS: if null return 0, else return 1 + max(maxDepth(left), maxDepth(right)).",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(h) recursion stack",
          "keyInsight": "Tree depth problems decompose into subproblems on subtrees."
      }
  },
  105: {
      "title": "Construct Binary Tree from Preorder and Inorder Traversal",
      "slug": "construct-binary-tree-from-preorder-and-inorder-traversal",
      "difficulty": "medium",
      "lists": [
          "neetcode-150"
      ],
      "category": "Trees",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "patternExplanations": {
          "DFS": "Preorder first element = root. Find root in inorder to split left/right subtrees. Recurse.",
          "Hash Map": "Map inorder values to indices for O(1) lookup of root position. Avoids O(n) search each time."
      },
      "hints": [
          "Preorder: root first, then left subtree, then right subtree. Inorder: left, root, right.",
          "First element of preorder is always the root. Where is this root in inorder?",
          "Root's position in inorder tells you size of left subtree. Use this to split both arrays."
      ],
      "solution": {
          "approach": "Root = preorder[0]. Find root index in inorder. Left subtree = inorder[0:idx], right = inorder[idx+1:]. Recurse.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)",
          "keyInsight": "Preorder gives roots in order. Inorder splits left/right subtrees."
      }
  },
  106: {
      "title": "Construct Binary Tree from Inorder and Postorder Traversal",
      "slug": "construct-binary-tree-from-inorder-and-postorder-traversal",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Binary Search",
          "Tree Traversal"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  107: {
      "title": "Binary Tree Level Order Traversal II",
      "slug": "binary-tree-level-order-traversal-ii",
      "difficulty": "medium",
      "primaryPattern": "BFS",
      "acceptablePatterns": [
          "Tree Traversal"
      ],
      "explanation": "Breadth-first search - explore level by level using a queue. Ideal for shortest path in unweighted graphs or level-order traversal."
  },
  108: {
      "title": "Convert Sorted Array to Binary Search Tree",
      "slug": "convert-sorted-array-to-binary-search-tree",
      "difficulty": "easy",
      "primaryPattern": "Tree Traversal",
      "acceptablePatterns": [
          "Hash Map",
          "Binary Search"
      ],
      "explanation": "Navigate tree structures using inorder, preorder, or postorder traversal. Consider recursive or iterative approaches."
  },
  109: {
      "title": "Convert Sorted List to Binary Search Tree",
      "slug": "convert-sorted-list-to-binary-search-tree",
      "difficulty": "medium",
      "primaryPattern": "Linked List",
      "acceptablePatterns": [
          "Binary Search",
          "Tree Traversal"
      ],
      "explanation": "Pointer manipulation for reversing, merging, detecting cycles, or finding intersections in linked structures."
  },
  110: {
      "title": "Balanced Binary Tree",
      "slug": "balanced-binary-tree",
      "difficulty": "easy",
      "primaryPattern": "DFS",
      "acceptablePatterns": [],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation.",
      "lists": [
          "neetcode-150"
      ],
      "category": "Trees",
      "patternExplanations": {
          "DFS": "For each node, check if left and right subtrees are balanced and their height difference <= 1."
      },
      "hints": [
          "A balanced tree has left and right subtrees with height difference at most 1.",
          "You need height of each subtree. Can you compute height and check balance in one pass?",
          "Return -1 if subtree is unbalanced, otherwise return its height. Check both children."
      ],
      "solution": {
          "approach": "DFS returns height if balanced, -1 if not. For each node, check both children balanced and heights differ by <= 1.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(h)",
          "keyInsight": "Encode both height and balance status in return value: -1 means unbalanced."
      }
  },
  111: {
      "title": "Minimum Depth of Binary Tree",
      "slug": "minimum-depth-of-binary-tree",
      "difficulty": "easy",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Tree Traversal",
          "BFS"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  112: {
      "title": "Path Sum",
      "slug": "path-sum",
      "difficulty": "easy",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Tree Traversal",
          "BFS"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  113: {
      "title": "Path Sum II",
      "slug": "path-sum-ii",
      "difficulty": "medium",
      "primaryPattern": "Backtracking",
      "acceptablePatterns": [
          "Tree Traversal",
          "DFS"
      ],
      "explanation": "Explore all possible solutions recursively. Build candidates incrementally and abandon paths that cannot lead to solution."
  },
  114: {
      "title": "Flatten Binary Tree to Linked List",
      "slug": "flatten-binary-tree-to-linked-list",
      "difficulty": "medium",
      "primaryPattern": "Linked List",
      "acceptablePatterns": [
          "Stack",
          "Tree Traversal",
          "DFS"
      ],
      "explanation": "Pointer manipulation for reversing, merging, detecting cycles, or finding intersections in linked structures."
  },
  115: {
      "title": "Distinct Subsequences",
      "slug": "distinct-subsequences",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization.",
      "lists": [
          "neetcode-150"
      ],
      "category": "Dynamic Programming",
      "patternExplanations": {
          "Dynamic Programming": "dp[i][j] = distinct subsequences of s[0..i] that equal t[0..j]. If chars match, can include or skip."
      },
      "hints": [
          "For each character in s, you can either use it to match t or skip it.",
          "If s[i] == t[j], you can match them (dp[i-1][j-1]) or skip s[i] (dp[i-1][j]).",
          "If s[i] != t[j], you must skip s[i], so dp[i][j] = dp[i-1][j]."
      ],
      "solution": {
          "approach": "2D DP. If chars match: dp[i][j] = dp[i-1][j-1] + dp[i-1][j]. Else: dp[i][j] = dp[i-1][j].",
          "timeComplexity": "O(m * n)",
          "spaceComplexity": "O(m * n) or O(n)",
          "keyInsight": "Two choices when chars match: use this match or skip it for a potentially later match."
      }
  },
  116: {
      "title": "Populating Next Right Pointers in Each Node",
      "slug": "populating-next-right-pointers-in-each-node",
      "difficulty": "medium",
      "primaryPattern": "Linked List",
      "acceptablePatterns": [
          "Tree Traversal",
          "DFS",
          "BFS"
      ],
      "explanation": "Pointer manipulation for reversing, merging, detecting cycles, or finding intersections in linked structures."
  },
  117: {
      "title": "Populating Next Right Pointers in Each Node II",
      "slug": "populating-next-right-pointers-in-each-node-ii",
      "difficulty": "medium",
      "primaryPattern": "Linked List",
      "acceptablePatterns": [
          "Tree Traversal",
          "DFS",
          "BFS"
      ],
      "explanation": "Pointer manipulation for reversing, merging, detecting cycles, or finding intersections in linked structures."
  },
  118: {
      "title": "Pascal's Triangle",
      "slug": "pascals-triangle",
      "difficulty": "easy",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  119: {
      "title": "Pascal's Triangle II",
      "slug": "pascals-triangle-ii",
      "difficulty": "easy",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  120: {
      "title": "Triangle",
      "slug": "triangle",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  121: {
      "title": "Best Time to Buy and Sell Stock",
      "slug": "best-time-to-buy-and-sell-stock",
      "difficulty": "easy",
      "lists": [
          "neetcode-150",
          "leetcode-75"
      ],
      "category": "Sliding Window",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Sliding Window",
          "Dynamic Programming"
      ],
      "patternExplanations": {
          "Greedy": "Track minimum price seen so far. For each price, profit = price - minSoFar. Update max profit and min price.",
          "Sliding Window": "Think of it as finding max difference where right > left. Expand right, move left to new min.",
          "Dynamic Programming": "maxProfit[i] = max(maxProfit[i-1], price[i] - minPrice). But greedy is simpler."
      },
      "hints": [
          "You want to buy low and sell high. What information do you need to track?",
          "If you're at day i, the best buy day is the day with minimum price before i.",
          "Track minimum price seen so far. Current profit = current price - min price so far."
      ],
      "solution": {
          "approach": "One pass: track minPrice and maxProfit. For each price: maxProfit = max(maxProfit, price - minPrice).",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "keyInsight": "For any selling day, the optimal buying day is the minimum price before it."
      }
  },
  122: {
      "title": "Best Time to Buy and Sell Stock II",
      "slug": "best-time-to-buy-and-sell-stock-ii",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  123: {
      "title": "Best Time to Buy and Sell Stock III",
      "slug": "best-time-to-buy-and-sell-stock-iii",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  124: {
      "title": "Binary Tree Maximum Path Sum",
      "slug": "binary-tree-maximum-path-sum",
      "difficulty": "hard",
      "primaryPattern": "DFS",
      "acceptablePatterns": [],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization.",
      "lists": [
          "neetcode-150"
      ],
      "category": "Trees",
      "patternExplanations": {
          "DFS": "For each node, calculate max path through it. Update global max. Return max one-sided path to parent."
      },
      "hints": [
          "A path can go through any node. At each node, the path could include left child, right child, or both.",
          "Maximum path through a node = node.val + maxLeft + maxRight (if positive).",
          "But when returning to parent, you can only take one side. Return max(leftPath, rightPath) + node.val."
      ],
      "solution": {
          "approach": "DFS returns max one-sided path. At each node, update global max with node + left + right. Return max single path.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(h)",
          "keyInsight": "Path through node uses both sides; path to parent uses only one side."
      }
  },
  125: {
      "title": "Valid Palindrome",
      "slug": "valid-palindrome",
      "difficulty": "easy",
      "lists": [
          "neetcode-150"
      ],
      "category": "Two Pointers",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [],
      "patternExplanations": {
          "Two Pointers": "Use left and right pointers. Skip non-alphanumeric chars. Compare characters moving inward. O(n) time, O(1) space."
      },
      "hints": [
          "A palindrome reads the same forward and backward. How would you check this?",
          "Can you compare first and last character, then second and second-to-last, etc.?",
          "Skip any characters that aren't letters or numbers."
      ],
      "solution": {
          "approach": "Two pointers from ends, skip non-alphanumeric, compare lowercase chars.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "keyInsight": "Palindrome check is naturally suited to comparing from both ends simultaneously."
      }
  },
  126: {
      "title": "Word Ladder II",
      "slug": "word-ladder-ii",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Backtracking",
          "BFS"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  127: {
      "title": "Word Ladder",
      "slug": "word-ladder",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "BFS"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  128: {
      "title": "Longest Consecutive Sequence",
      "slug": "longest-consecutive-sequence",
      "difficulty": "medium",
      "lists": [
          "neetcode-150"
      ],
      "category": "Arrays & Hashing",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Union Find"
      ],
      "patternExplanations": {
          "Hash Map": "Put all numbers in a set. For each number, check if it's a sequence start (n-1 not in set). If so, count consecutive numbers from there.",
          "Union Find": "Union consecutive numbers together, then find the largest connected component. More complex but also valid."
      },
      "hints": [
          "How can you quickly check if a number exists in the array?",
          "A sequence like [100,4,200,1,3,2] contains 1,2,3,4. How do you find where a sequence starts?",
          "A number starts a sequence if (number - 1) is NOT in the set. Then count upward."
      ],
      "solution": {
          "approach": "Add all to HashSet. For each num where (num-1) not in set, count consecutive nums going up.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)",
          "keyInsight": "Only start counting from sequence beginnings to avoid redundant work."
      }
  },
  129: {
      "title": "Sum Root to Leaf Numbers",
      "slug": "sum-root-to-leaf-numbers",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Tree Traversal"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  130: {
      "title": "Surrounded Regions",
      "slug": "surrounded-regions",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "BFS",
          "Union Find"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation.",
      "lists": [
          "neetcode-150"
      ],
      "category": "Graphs",
      "patternExplanations": {
          "DFS": "DFS from border O's to mark them. Then flip remaining O's to X. Unmark border-connected O's.",
          "BFS": "BFS from all border O's. Mark connected regions. Flip unmarked O's.",
          "Union Find": "Connect all border O's to a sentinel. Flip O's not connected to sentinel."
      },
      "hints": [
          "O's connected to border cannot be captured. Only interior O's get flipped.",
          "Instead of finding captured regions, find regions that are NOT captured.",
          "DFS/BFS from all border O's. Mark them. Everything else that's O gets captured."
      ],
      "solution": {
          "approach": "Mark border-connected O's as safe (e.g., change to 'S'). Flip remaining O's to X. Change S back to O.",
          "timeComplexity": "O(m * n)",
          "spaceComplexity": "O(m * n)",
          "keyInsight": "Invert the problem: find what's NOT captured (border-connected) instead of what is."
      }
  },
  131: {
      "title": "Palindrome Partitioning",
      "slug": "palindrome-partitioning",
      "difficulty": "medium",
      "primaryPattern": "Backtracking",
      "acceptablePatterns": [
          "Dynamic Programming"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization.",
      "lists": [
          "neetcode-150"
      ],
      "category": "Backtracking",
      "patternExplanations": {
          "Backtracking": "Try each prefix. If palindrome, recurse on rest. Build all valid partitions.",
          "Dynamic Programming": "Precompute palindrome table with DP, then backtrack to find partitions."
      },
      "hints": [
          "At each position, try all possible first palindromes, then recurse on the rest.",
          "How do you check if a substring is a palindrome efficiently?",
          "You can precompute: dp[i][j] = true if s[i..j] is palindrome. Or check on the fly with two pointers."
      ],
      "solution": {
          "approach": "Backtrack: try each prefix as first palindrome, recurse on suffix. Add partition when string exhausted.",
          "timeComplexity": "O(n * 2^n)",
          "spaceComplexity": "O(n)",
          "keyInsight": "Classic partition backtracking: try all valid first parts, recurse on rest."
      }
  },
  132: {
      "title": "Palindrome Partitioning II",
      "slug": "palindrome-partitioning-ii",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  133: {
      "title": "Clone Graph",
      "slug": "clone-graph",
      "difficulty": "medium",
      "lists": [
          "neetcode-150"
      ],
      "category": "Graphs",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "BFS",
          "Hash Map"
      ],
      "patternExplanations": {
          "DFS": "Recursively clone nodes. Use map from original to clone to handle cycles and avoid duplicates.",
          "BFS": "Iteratively clone using queue. Same map to track cloned nodes.",
          "Hash Map": "Essential to both approaches - maps original node to its clone."
      },
      "hints": [
          "Need to create new nodes and connect them the same way. How to handle cycles?",
          "If you revisit a node, you've already cloned it. Need to remember clones.",
          "Map: original node -> cloned node. If in map, return existing clone. Else create and recurse."
      ],
      "solution": {
          "approach": "DFS with HashMap<Node, Node>. If node in map, return clone. Else create clone, add to map, clone neighbors recursively.",
          "timeComplexity": "O(V + E)",
          "spaceComplexity": "O(V)",
          "keyInsight": "Hash map prevents infinite loops and ensures each node is cloned exactly once."
      }
  },
  134: {
      "title": "Gas Station",
      "slug": "gas-station",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum.",
      "lists": [
          "neetcode-150"
      ],
      "category": "Greedy",
      "patternExplanations": {
          "Greedy": "If total gas >= total cost, solution exists. Start where cumulative sum from start is never negative."
      },
      "hints": [
          "If total gas < total cost, impossible. Otherwise a solution exists.",
          "If you can't reach station i+1 starting from j, can any station between j and i be the answer?",
          "No! If j can't reach i+1, neither can any station between them. Start fresh from i+1."
      ],
      "solution": {
          "approach": "Track total and current tank. If current < 0, reset start to next station. If total >= 0, start is answer.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "keyInsight": "If we fail at station i starting from j, start fresh at i+1. All stations in between also fail."
      }
  },
  135: {
      "title": "Candy",
      "slug": "candy",
      "difficulty": "hard",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  136: {
      "title": "Single Number",
      "slug": "single-number",
      "difficulty": "easy",
      "lists": [
          "neetcode-150",
          "leetcode-75"
      ],
      "category": "Bit Manipulation",
      "primaryPattern": "Bit Manipulation",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "patternExplanations": {
          "Bit Manipulation": "XOR all numbers. Pairs cancel out (a ^ a = 0). Result is the single number.",
          "Hash Map": "Count occurrences, find the one with count 1. Works but uses O(n) space."
      },
      "hints": [
          "Every element appears twice except one. How to find the unique one in O(1) space?",
          "XOR has properties: a ^ a = 0, a ^ 0 = a, XOR is commutative and associative.",
          "XOR all numbers: pairs cancel out, leaving only the single number."
      ],
      "solution": {
          "approach": "result = 0. For each num: result ^= num. Return result.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "keyInsight": "XOR is self-inverse - duplicates cancel, unique remains."
      }
  },
  137: {
      "title": "Single Number II",
      "slug": "single-number-ii",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  138: {
      "title": "Copy List with Random Pointer",
      "slug": "copy-list-with-random-pointer",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Linked List"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships.",
      "lists": [
          "neetcode-150"
      ],
      "category": "Linked List",
      "patternExplanations": {
          "Hash Map": "First pass: create all nodes, map old to new. Second pass: set next and random pointers.",
          "Linked List": "Interleave copies: A->A'->B->B'. Set random pointers. Separate lists."
      },
      "hints": [
          "The tricky part is the random pointer - it points to arbitrary nodes.",
          "If you had a mapping from old nodes to new nodes, setting pointers would be easy.",
          "First pass: create all new nodes, map old->new. Second pass: set next and random using the map."
      ],
      "solution": {
          "approach": "HashMap from original to copy. First pass creates copies. Second pass sets next and random pointers.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)",
          "keyInsight": "The map lets you find the copy of any node in O(1) when setting random pointers."
      }
  },
  139: {
      "title": "Word Break",
      "slug": "word-break",
      "difficulty": "medium",
      "lists": [
          "neetcode-150"
      ],
      "category": "1-D Dynamic Programming",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "BFS"
      ],
      "patternExplanations": {
          "Dynamic Programming": "dp[i] = can string[0:i] be segmented? Check all j < i: if dp[j] is true and string[j:i] is in dictionary, dp[i] = true.",
          "BFS": "BFS where each state is an index. From index i, try to match each word, jump to i + word.length."
      },
      "hints": [
          "Can the string be broken into dictionary words?",
          "If s[0:i] can be segmented AND s[i:j] is a word, then s[0:j] can be segmented.",
          "dp[i] = true if there exists j where dp[j] is true and s[j:i] is in dictionary."
      ],
      "solution": {
          "approach": "dp[0] = true. For i from 1 to n: for each j from 0 to i: if dp[j] and s[j:i] in wordDict, dp[i] = true.",
          "timeComplexity": "O(n^2 * m) or O(n * m * k) with optimization",
          "spaceComplexity": "O(n)",
          "keyInsight": "Build up segmentation validity from start of string."
      }
  },
  140: {
      "title": "Word Break II",
      "slug": "word-break-ii",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Dynamic Programming",
          "Backtracking",
          "Trie"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  141: {
      "title": "Linked List Cycle",
      "slug": "linked-list-cycle",
      "difficulty": "easy",
      "lists": [
          "neetcode-150"
      ],
      "category": "Linked List",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "patternExplanations": {
          "Two Pointers": "Floyd's cycle detection: slow moves 1 step, fast moves 2 steps. If they meet, there's a cycle. If fast hits null, no cycle.",
          "Hash Map": "Store visited nodes in a set. If you revisit a node, there's a cycle. Uses O(n) space though."
      },
      "hints": [
          "How can you detect if you're going in circles?",
          "Imagine two runners on a track. If there's a loop, a faster runner will lap the slower one.",
          "Slow pointer: 1 step. Fast pointer: 2 steps. If they meet, cycle exists."
      ],
      "solution": {
          "approach": "Floyd's algorithm: slow (1 step) and fast (2 steps) pointers. Cycle exists iff they meet.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "keyInsight": "In a cycle, the fast pointer gains one step per iteration, so they must eventually meet."
      }
  },
  142: {
      "title": "Linked List Cycle II",
      "slug": "linked-list-cycle-ii",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Linked List",
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  143: {
      "title": "Reorder List",
      "slug": "reorder-list",
      "difficulty": "medium",
      "lists": [
          "neetcode-150"
      ],
      "category": "Linked List",
      "primaryPattern": "Linked List",
      "acceptablePatterns": [
          "Two Pointers"
      ],
      "patternExplanations": {
          "Linked List": "Three steps: 1) Find middle with slow/fast pointers, 2) Reverse second half, 3) Merge alternating from both halves.",
          "Two Pointers": "Slow/fast to find middle, then interleave nodes from start and reversed end."
      },
      "hints": [
          "The pattern is: first, last, second, second-to-last, third, third-to-last...",
          "You're interleaving from front and back. But lists only go forward...",
          "Find middle, reverse the second half, then merge the two halves alternately."
      ],
      "solution": {
          "approach": "1) Find middle (slow/fast). 2) Reverse second half. 3) Merge first half and reversed second half alternately.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "keyInsight": "Reversing the second half lets you access it from the 'back' while traversing forward."
      }
  },
  144: {
      "title": "Binary Tree Preorder Traversal",
      "slug": "binary-tree-preorder-traversal",
      "difficulty": "easy",
      "primaryPattern": "Stack",
      "acceptablePatterns": [
          "Tree Traversal",
          "DFS"
      ],
      "explanation": "LIFO structure for nested patterns, matching pairs, or maintaining monotonic sequences."
  },
  145: {
      "title": "Binary Tree Postorder Traversal",
      "slug": "binary-tree-postorder-traversal",
      "difficulty": "easy",
      "primaryPattern": "Stack",
      "acceptablePatterns": [
          "Tree Traversal",
          "DFS"
      ],
      "explanation": "LIFO structure for nested patterns, matching pairs, or maintaining monotonic sequences."
  },
  146: {
      "title": "LRU Cache",
      "slug": "lru-cache",
      "difficulty": "medium",
      "lists": [
          "neetcode-150"
      ],
      "category": "Linked List",
      "primaryPattern": "Linked List",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "patternExplanations": {
          "Linked List": "Doubly linked list maintains usage order. Most recent at head, least recent at tail. O(1) to move/remove nodes.",
          "Hash Map": "Map key -> node for O(1) lookup. Combined with doubly linked list for O(1) get and put."
      },
      "hints": [
          "LRU = Least Recently Used. Need to track usage order and evict oldest when full.",
          "Need O(1) lookup by key AND O(1) update of 'most recently used'. What combination works?",
          "Hash map for lookup, doubly linked list for ordering. Move accessed items to front."
      ],
      "solution": {
          "approach": "HashMap<key, node> + doubly linked list. On access: move to front. On insert when full: remove tail.",
          "timeComplexity": "O(1) for get and put",
          "spaceComplexity": "O(capacity)",
          "keyInsight": "Combining hash map (O(1) access) with doubly linked list (O(1) reorder) achieves both requirements."
      }
  },
  147: {
      "title": "Insertion Sort List",
      "slug": "insertion-sort-list",
      "difficulty": "medium",
      "primaryPattern": "Linked List",
      "acceptablePatterns": [
          "Two Pointers"
      ],
      "explanation": "Pointer manipulation for reversing, merging, detecting cycles, or finding intersections in linked structures."
  },
  148: {
      "title": "Sort List",
      "slug": "sort-list",
      "difficulty": "medium",
      "primaryPattern": "Linked List",
      "acceptablePatterns": [
          "Two Pointers",
          "Binary Search"
      ],
      "explanation": "Pointer manipulation for reversing, merging, detecting cycles, or finding intersections in linked structures."
  },
  149: {
      "title": "Max Points on a Line",
      "slug": "max-points-on-a-line",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  150: {
      "title": "Evaluate Reverse Polish Notation",
      "slug": "evaluate-reverse-polish-notation",
      "difficulty": "medium",
      "primaryPattern": "Stack",
      "acceptablePatterns": [],
      "explanation": "LIFO structure for nested patterns, matching pairs, or maintaining monotonic sequences.",
      "lists": [
          "neetcode-150"
      ],
      "category": "Stack",
      "patternExplanations": {
          "Stack": "Push numbers to stack. On operator, pop two operands, apply operator, push result."
      },
      "hints": [
          "In RPN, operators come after their operands: '3 4 +' means 3 + 4.",
          "Use a stack. When you see a number, push it.",
          "When you see an operator, pop two numbers, apply the operator, push the result."
      ],
      "solution": {
          "approach": "Stack of numbers. On number: push. On operator: pop b, pop a, push (a op b).",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)",
          "keyInsight": "Second popped value is left operand, first popped is right. Order matters for - and /."
      }
  },
  151: {
      "title": "Reverse Words in a String",
      "slug": "reverse-words-in-a-string",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds.",
      "lists": [
          "leetcode-75"
      ],
      "category": "Two Pointers",
      "patternExplanations": {
          "Two Pointers": "Reverse entire string, then reverse each word. Use two pointers to find word boundaries."
      },
      "hints": [
          "The words need to be in reverse order. What if you reversed the whole string first?",
          "After reversing whole string, each word is backwards. Reverse each word individually.",
          "Handle multiple spaces: skip spaces between words, don't include leading/trailing spaces."
      ],
      "solution": {
          "approach": "Reverse entire string. Then reverse each word. Handle extra spaces by rebuilding with single spaces.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n) or O(1) if in-place",
          "keyInsight": "Two reverses: whole string reverses word order, per-word reverse fixes each word."
      }
  },
  152: {
      "title": "Maximum Product Subarray",
      "slug": "maximum-product-subarray",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization.",
      "lists": [
          "neetcode-150"
      ],
      "category": "Dynamic Programming",
      "patternExplanations": {
          "Dynamic Programming": "Track both max and min product ending at each position. Negative can flip min to max."
      },
      "hints": [
          "Unlike sum, product with negative numbers can flip sign.",
          "A large negative * negative = large positive. You need to track minimum too.",
          "At each position, track both max and min product ending there. Update both considering current element."
      ],
      "solution": {
          "approach": "Track maxProd and minProd ending at current position. For each num, update both (they can swap on negative).",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "keyInsight": "Minimum product can become maximum when multiplied by negative number."
      }
  },
  153: {
      "title": "Find Minimum in Rotated Sorted Array",
      "slug": "find-minimum-in-rotated-sorted-array",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element.",
      "lists": [
          "neetcode-150"
      ],
      "category": "Binary Search",
      "patternExplanations": {
          "Binary Search": "Minimum is at rotation point. Binary search: if mid > right, min is in right half."
      },
      "hints": [
          "The array is sorted but rotated. The minimum is at the rotation point.",
          "Compare mid with right. If mid > right, rotation point (min) is in right half.",
          "If mid < right, mid could be min or min is in left half. Include mid in search."
      ],
      "solution": {
          "approach": "Binary search. If nums[mid] > nums[right], min in right half. Else in left half (including mid).",
          "timeComplexity": "O(log n)",
          "spaceComplexity": "O(1)",
          "keyInsight": "Compare with right boundary to determine which half contains the rotation point."
      }
  },
  154: {
      "title": "Find Minimum in Rotated Sorted Array II",
      "slug": "find-minimum-in-rotated-sorted-array-ii",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  155: {
      "title": "Min Stack",
      "slug": "min-stack",
      "difficulty": "medium",
      "lists": [
          "neetcode-150"
      ],
      "category": "Stack",
      "primaryPattern": "Stack",
      "acceptablePatterns": [],
      "patternExplanations": {
          "Stack": "Use two stacks or store pairs (value, currentMin). Track minimum at each level so pop doesn't lose min info."
      },
      "hints": [
          "Regular stack gives O(1) push/pop. How do you also get O(1) min?",
          "When you push, the min might change. When you pop, you need to know the previous min.",
          "Store the current minimum alongside each element, or use a separate min stack."
      ],
      "solution": {
          "approach": "Each stack entry stores (value, minSoFar). Min is always top entry's minSoFar.",
          "timeComplexity": "O(1) for all operations",
          "spaceComplexity": "O(n)",
          "keyInsight": "Store enough state with each element to reconstruct min after any number of pops."
      }
  },
  160: {
      "title": "Intersection of Two Linked Lists",
      "slug": "intersection-of-two-linked-lists",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Linked List",
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  162: {
      "title": "Find Peak Element",
      "slug": "find-peak-element",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element.",
      "lists": [
          "leetcode-75"
      ],
      "category": "Binary Search",
      "patternExplanations": {
          "Binary Search": "If mid < mid+1, peak is on right. If mid > mid+1, peak is on left (or mid is peak)."
      },
      "hints": [
          "A peak is greater than its neighbors. nums[-1] = nums[n] = -∞.",
          "Think about which direction leads uphill. The peak must be in that direction.",
          "If nums[mid] < nums[mid+1], we're on ascending slope, go right. Else go left."
      ],
      "solution": {
          "approach": "Binary search. Compare mid with mid+1. Go toward the higher neighbor. Peak is where it's higher than both.",
          "timeComplexity": "O(log n)",
          "spaceComplexity": "O(1)",
          "keyInsight": "Always move toward higher ground. Eventually you reach a peak."
      }
  },
  164: {
      "title": "Maximum Gap",
      "slug": "maximum-gap",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  165: {
      "title": "Compare Version Numbers",
      "slug": "compare-version-numbers",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  166: {
      "title": "Fraction to Recurring Decimal",
      "slug": "fraction-to-recurring-decimal",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  167: {
      "title": "Two Sum II - Input Array Is Sorted",
      "slug": "two-sum-ii-input-array-is-sorted",
      "difficulty": "medium",
      "lists": [
          "neetcode-150"
      ],
      "category": "Two Pointers",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Binary Search",
          "Hash Map"
      ],
      "patternExplanations": {
          "Two Pointers": "Start with left=0, right=n-1. If sum too small, move left up. If sum too big, move right down. Sorted order makes this work.",
          "Binary Search": "For each number, binary search for its complement. O(n log n) but two pointers is simpler.",
          "Hash Map": "Works but doesn't leverage sorted property. Two pointers is optimal here."
      },
      "hints": [
          "The array is sorted - how can you use this property?",
          "If you pick the smallest and largest, their sum gives you information about which to adjust.",
          "Sum too big? You need smaller numbers. Sum too small? You need larger numbers."
      ],
      "solution": {
          "approach": "Two pointers at ends. Move left pointer right if sum < target, right pointer left if sum > target.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "keyInsight": "Sorted order lets you deterministically decide which pointer to move."
      }
  },
  168: {
      "title": "Excel Sheet Column Title",
      "slug": "excel-sheet-column-title",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  169: {
      "title": "Majority Element",
      "slug": "majority-element",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Binary Search",
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  171: {
      "title": "Excel Sheet Column Number",
      "slug": "excel-sheet-column-number",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  172: {
      "title": "Factorial Trailing Zeroes",
      "slug": "factorial-trailing-zeroes",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  173: {
      "title": "Binary Search Tree Iterator",
      "slug": "binary-search-tree-iterator",
      "difficulty": "medium",
      "primaryPattern": "Stack",
      "acceptablePatterns": [
          "Tree Traversal",
          "Hash Map"
      ],
      "explanation": "LIFO structure for nested patterns, matching pairs, or maintaining monotonic sequences."
  },
  174: {
      "title": "Dungeon Game",
      "slug": "dungeon-game",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "DFS"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  175: {
      "title": "Combine Two Tables",
      "slug": "combine-two-tables",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  176: {
      "title": "Second Highest Salary",
      "slug": "second-highest-salary",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  177: {
      "title": "Nth Highest Salary",
      "slug": "nth-highest-salary",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  178: {
      "title": "Rank Scores",
      "slug": "rank-scores",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  179: {
      "title": "Largest Number",
      "slug": "largest-number",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  180: {
      "title": "Consecutive Numbers",
      "slug": "consecutive-numbers",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  181: {
      "title": "Employees Earning More Than Their Managers",
      "slug": "employees-earning-more-than-their-managers",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  182: {
      "title": "Duplicate Emails",
      "slug": "duplicate-emails",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  183: {
      "title": "Customers Who Never Order",
      "slug": "customers-who-never-order",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  184: {
      "title": "Department Highest Salary",
      "slug": "department-highest-salary",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  185: {
      "title": "Department Top Three Salaries",
      "slug": "department-top-three-salaries",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  187: {
      "title": "Repeated DNA Sequences",
      "slug": "repeated-dna-sequences",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Sliding Window"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  188: {
      "title": "Best Time to Buy and Sell Stock IV",
      "slug": "best-time-to-buy-and-sell-stock-iv",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  189: {
      "title": "Rotate Array",
      "slug": "rotate-array",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  190: {
      "title": "Reverse Bits",
      "slug": "reverse-bits",
      "difficulty": "easy",
      "primaryPattern": "Bit Manipulation",
      "acceptablePatterns": [],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element.",
      "lists": [
          "neetcode-150"
      ],
      "category": "Bit Manipulation",
      "patternExplanations": {
          "Bit Manipulation": "Extract each bit from right, add to result from left. Or swap bit pairs recursively."
      },
      "hints": [
          "Extract the rightmost bit, place it in the leftmost position of result.",
          "Use bit operations: n & 1 gets last bit, result << 1 shifts result left.",
          "Loop 32 times: result = (result << 1) | (n & 1); n >>= 1;"
      ],
      "solution": {
          "approach": "For each of 32 bits: shift result left, add last bit of n, shift n right.",
          "timeComplexity": "O(1) - always 32 iterations",
          "spaceComplexity": "O(1)",
          "keyInsight": "Build result bit by bit, taking from right of input and adding to left of result."
      }
  },
  191: {
      "title": "Number of 1 Bits",
      "slug": "number-of-1-bits",
      "difficulty": "easy",
      "lists": [
          "neetcode-150"
      ],
      "category": "Bit Manipulation",
      "primaryPattern": "Bit Manipulation",
      "acceptablePatterns": [],
      "patternExplanations": {
          "Bit Manipulation": "n & (n-1) clears the lowest set bit. Count how many times until n becomes 0. Or check each bit."
      },
      "hints": [
          "Count the number of 1s in binary representation.",
          "Simple way: check each of 32 bits with (n >> i) & 1.",
          "Clever way: n & (n-1) removes lowest 1 bit. Count iterations until n = 0."
      ],
      "solution": {
          "approach": "count = 0. While n: n = n & (n-1); count++. Or loop through 32 bits checking each.",
          "timeComplexity": "O(1) - at most 32 bits",
          "spaceComplexity": "O(1)",
          "keyInsight": "n & (n-1) efficiently removes one 1-bit per iteration."
      }
  },
  192: {
      "title": "Word Frequency",
      "slug": "word-frequency",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  193: {
      "title": "Valid Phone Numbers",
      "slug": "valid-phone-numbers",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  194: {
      "title": "Transpose File",
      "slug": "transpose-file",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  195: {
      "title": "Tenth Line",
      "slug": "tenth-line",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  196: {
      "title": "Delete Duplicate Emails",
      "slug": "delete-duplicate-emails",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  197: {
      "title": "Rising Temperature",
      "slug": "rising-temperature",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  198: {
      "title": "House Robber",
      "slug": "house-robber",
      "difficulty": "medium",
      "lists": [
          "neetcode-150",
          "leetcode-75"
      ],
      "category": "1-D Dynamic Programming",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [],
      "patternExplanations": {
          "Dynamic Programming": "dp[i] = max(dp[i-1], dp[i-2] + nums[i]). Either skip house i (take dp[i-1]) or rob it (dp[i-2] + nums[i])."
      },
      "hints": [
          "Can't rob adjacent houses. For each house, decide: rob it or skip it.",
          "If you rob house i, you couldn't have robbed house i-1. Your last rob was house i-2 or earlier.",
          "At house i: max money = max(skip this house, rob this house). Express both in terms of previous answers."
      ],
      "solution": {
          "approach": "dp[i] = max(dp[i-1], dp[i-2] + nums[i]). Use two variables instead of array.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "keyInsight": "Classic DP: each state depends on previous non-adjacent state."
      }
  },
  199: {
      "title": "Binary Tree Right Side View",
      "slug": "binary-tree-right-side-view",
      "difficulty": "medium",
      "lists": [
          "neetcode-150",
          "leetcode-75"
      ],
      "category": "Trees",
      "primaryPattern": "BFS",
      "acceptablePatterns": [
          "DFS"
      ],
      "patternExplanations": {
          "BFS": "Level order traversal. For each level, the last node is visible from the right side.",
          "DFS": "Visit right subtree first. First node at each depth is rightmost. Track depth to avoid duplicates."
      },
      "hints": [
          "Right side view = rightmost node at each level.",
          "BFS level by level - what's the last node at each level?",
          "Or DFS right-to-left: first node you see at each new depth is the answer for that level."
      ],
      "solution": {
          "approach": "BFS: for each level, add the last node's value to result. Or DFS right-first, track depth.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)",
          "keyInsight": "Right side view = one node per level, specifically the rightmost."
      }
  },
  200: {
      "title": "Number of Islands",
      "slug": "number-of-islands",
      "difficulty": "medium",
      "lists": [
          "neetcode-150"
      ],
      "category": "Graphs",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "BFS",
          "Union Find"
      ],
      "patternExplanations": {
          "DFS": "When you find '1', DFS to mark entire island as visited. Count how many times you start a new DFS.",
          "BFS": "Same idea but explore island using BFS queue. Either traversal works.",
          "Union Find": "Union adjacent '1' cells. Count unique roots at end."
      },
      "hints": [
          "An island is a connected group of '1's. How do you count separate groups?",
          "When you find a '1', you've found a new island. Mark all connected '1's as visited.",
          "Increment count each time you start a DFS/BFS from an unvisited '1'."
      ],
      "solution": {
          "approach": "Iterate grid. When finding unvisited '1', increment count and DFS/BFS to mark entire island visited.",
          "timeComplexity": "O(m * n)",
          "spaceComplexity": "O(m * n) worst case",
          "keyInsight": "Connected component counting: each DFS/BFS explores one component."
      }
  },
  201: {
      "title": "Bitwise AND of Numbers Range",
      "slug": "bitwise-and-of-numbers-range",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  202: {
      "title": "Happy Number",
      "slug": "happy-number",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships.",
      "lists": [
          "neetcode-150"
      ],
      "category": "Math",
      "patternExplanations": {
          "Hash Map": "Compute sum of squared digits repeatedly. Track seen sums to detect cycle.",
          "Two Pointers": "Floyd's cycle detection: slow and fast pointers on the sequence of sums."
      },
      "hints": [
          "Keep computing sum of squared digits. It either reaches 1 or cycles.",
          "How do you detect if you're in a cycle?",
          "Use a set to track seen numbers, or use Floyd's cycle detection (fast/slow pointers)."
      ],
      "solution": {
          "approach": "Compute next number (sum of squared digits). Use set to detect cycle. Stop at 1 or cycle.",
          "timeComplexity": "O(log n) per step, limited steps",
          "spaceComplexity": "O(1) with Floyd's, O(log n) with set",
          "keyInsight": "The sequence either reaches 1 or enters a cycle. Detect cycle to avoid infinite loop."
      }
  },
  203: {
      "title": "Remove Linked List Elements",
      "slug": "remove-linked-list-elements",
      "difficulty": "easy",
      "primaryPattern": "Linked List",
      "acceptablePatterns": [
          "DFS"
      ],
      "explanation": "Pointer manipulation for reversing, merging, detecting cycles, or finding intersections in linked structures."
  },
  204: {
      "title": "Count Primes",
      "slug": "count-primes",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  205: {
      "title": "Isomorphic Strings",
      "slug": "isomorphic-strings",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  206: {
      "title": "Reverse Linked List",
      "slug": "reverse-linked-list",
      "difficulty": "easy",
      "lists": [
          "neetcode-150",
          "leetcode-75"
      ],
      "category": "Linked List",
      "primaryPattern": "Linked List",
      "acceptablePatterns": [
          "Two Pointers"
      ],
      "patternExplanations": {
          "Linked List": "Iteratively reverse pointers: for each node, save next, point current to prev, advance prev and current.",
          "Two Pointers": "prev and current pointers moving through the list, reversing each link as you go."
      },
      "hints": [
          "You need to reverse all the arrows. 1->2->3 becomes 1<-2<-3.",
          "To reverse a link, you need access to the previous node. Track it.",
          "For each node: save next, reverse link, move prev and current forward."
      ],
      "solution": {
          "approach": "Track prev (initially null) and curr. For each node: tmp = curr.next, curr.next = prev, prev = curr, curr = tmp.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "keyInsight": "Reverse one link at a time while tracking just prev and current."
      }
  },
  207: {
      "title": "Course Schedule",
      "slug": "course-schedule",
      "difficulty": "medium",
      "lists": [
          "neetcode-150"
      ],
      "category": "Graphs",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "BFS",
          "Topological Sort"
      ],
      "patternExplanations": {
          "DFS": "Detect cycle in directed graph. Use states: unvisited, visiting (in current path), visited. Cycle if we revisit 'visiting' node.",
          "BFS": "Kahn's algorithm for topological sort. If all nodes processed, no cycle. If queue empties early, cycle exists.",
          "Topological Sort": "Can complete all courses iff the dependency graph has no cycles (is a DAG)."
      },
      "hints": [
          "Courses with prerequisites form a directed graph. What makes it impossible to complete all?",
          "Impossible if there's a cycle: A requires B, B requires C, C requires A.",
          "Detect cycle via DFS (tracking 'in current path') or BFS topological sort."
      ],
      "solution": {
          "approach": "DFS cycle detection: 3 states per node. Or BFS: count incoming edges, process nodes with 0 incoming, check if all processed.",
          "timeComplexity": "O(V + E)",
          "spaceComplexity": "O(V + E)",
          "keyInsight": "Course scheduling is a DAG validity check - can only complete if no cycles."
      }
  },
  208: {
      "title": "Implement Trie (Prefix Tree)",
      "slug": "implement-trie-prefix-tree",
      "difficulty": "medium",
      "lists": [
          "neetcode-150",
          "leetcode-75"
      ],
      "category": "Tries",
      "primaryPattern": "Trie",
      "acceptablePatterns": [],
      "patternExplanations": {
          "Trie": "Tree where each node has up to 26 children (for lowercase letters). Path from root to node represents a prefix."
      },
      "hints": [
          "Each node stores children (a-z) and a flag for 'is this a complete word?'",
          "Insert: traverse/create nodes for each character, mark last node as word end.",
          "Search: traverse for each character, return false if missing. StartsWith is similar but doesn't check word end."
      ],
      "solution": {
          "approach": "Node has children[26] and isEnd boolean. Insert creates path. Search/StartsWith traverse path.",
          "timeComplexity": "O(m) per operation, m = word length",
          "spaceComplexity": "O(total characters inserted)",
          "keyInsight": "Trie shares prefixes - common prefixes stored once, enabling efficient prefix queries."
      }
  },
  209: {
      "title": "Minimum Size Subarray Sum",
      "slug": "minimum-size-subarray-sum",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Sliding Window"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  210: {
      "title": "Course Schedule II",
      "slug": "course-schedule-ii",
      "difficulty": "medium",
      "primaryPattern": "Topological Sort",
      "acceptablePatterns": [
          "DFS",
          "BFS"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation.",
      "lists": [
          "neetcode-150"
      ],
      "category": "Graphs",
      "patternExplanations": {
          "Topological Sort": "Kahn's algorithm: process nodes with no prerequisites first. Remove edges, repeat.",
          "DFS": "DFS with states (unvisited, visiting, visited). Detect cycles. Build order in post-order.",
          "BFS": "BFS from nodes with 0 in-degree. Add to order. Decrement neighbors' in-degree."
      },
      "hints": [
          "This is topological sort - order nodes so all edges point forward.",
          "Start with courses that have no prerequisites (in-degree 0).",
          "Process them, remove their edges, find new courses with in-degree 0. Repeat."
      ],
      "solution": {
          "approach": "Kahn's algorithm: queue nodes with 0 in-degree, process, decrement neighbors' in-degree, add new 0s.",
          "timeComplexity": "O(V + E)",
          "spaceComplexity": "O(V + E)",
          "keyInsight": "Same as Course Schedule I, but collect the order instead of just checking feasibility."
      }
  },
  211: {
      "title": "Design Add and Search Words Data Structure",
      "slug": "design-add-and-search-words-data-structure",
      "difficulty": "medium",
      "primaryPattern": "Trie",
      "acceptablePatterns": [
          "DFS"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation.",
      "lists": [
          "neetcode-150"
      ],
      "category": "Tries",
      "patternExplanations": {
          "Trie": "Build trie for words. For search with '.', try all children at that position with DFS.",
          "DFS": "DFS through trie. On '.', recursively try all 26 children."
      },
      "hints": [
          "Use a trie for efficient prefix operations.",
          "addWord is standard trie insert. search is where it gets interesting.",
          "For '.', you need to try all possible characters at that position. Use DFS/backtracking."
      ],
      "solution": {
          "approach": "Trie with search that handles '.'. On '.', recursively search all children. On letter, follow that path.",
          "timeComplexity": "O(m) for add, O(26^m) worst case for search with all dots",
          "spaceComplexity": "O(total characters)",
          "keyInsight": "Trie handles prefixes well. Wildcards require trying all branches at that level."
      }
  },
  212: {
      "title": "Word Search II",
      "slug": "word-search-ii",
      "difficulty": "hard",
      "primaryPattern": "Trie",
      "acceptablePatterns": [
          "Backtracking"
      ],
      "explanation": "Explore all possible solutions recursively. Build candidates incrementally and abandon paths that cannot lead to solution.",
      "lists": [
          "neetcode-150"
      ],
      "category": "Backtracking",
      "patternExplanations": {
          "Trie": "Build trie of words. DFS from each cell, following trie paths. Prune when no trie match.",
          "Backtracking": "Trie + backtracking. Use trie to quickly check if current path could lead to a word."
      },
      "hints": [
          "Word Search I for each word would be O(words * m * n * 4^L). Can you do better?",
          "Build a trie from all words. Search the board once, following the trie.",
          "At each cell, only continue if current path exists in trie. This prunes many paths."
      ],
      "solution": {
          "approach": "Build trie of words. DFS from each cell, following trie. When word found, add to result. Mark visited cells.",
          "timeComplexity": "O(m * n * 4^L) but heavily pruned by trie",
          "spaceComplexity": "O(words * avgLength)",
          "keyInsight": "Trie lets you search for all words simultaneously, pruning impossible paths."
      }
  },
  213: {
      "title": "House Robber II",
      "slug": "house-robber-ii",
      "difficulty": "medium",
      "lists": [
          "neetcode-150"
      ],
      "category": "1-D Dynamic Programming",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [],
      "patternExplanations": {
          "Dynamic Programming": "Houses in a circle. Can't rob both first and last. Run House Robber twice: once without first, once without last."
      },
      "hints": [
          "Houses are in a circle - first and last are adjacent.",
          "If you rob house 0, you can't rob house n-1 (and vice versa).",
          "Solve two separate House Robber I problems: houses[0..n-2] and houses[1..n-1]. Take max."
      ],
      "solution": {
          "approach": "max(robLinear(nums[0:n-1]), robLinear(nums[1:n])). Exclude either first or last house.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "keyInsight": "Break the cycle by considering two cases: exclude first house or exclude last house."
      }
  },
  214: {
      "title": "Shortest Palindrome",
      "slug": "shortest-palindrome",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  215: {
      "title": "Kth Largest Element in an Array",
      "slug": "kth-largest-element-in-an-array",
      "difficulty": "medium",
      "lists": [
          "neetcode-150",
          "leetcode-75"
      ],
      "category": "Heap / Priority Queue",
      "primaryPattern": "Heap/Priority Queue",
      "acceptablePatterns": [
          "Quickselect"
      ],
      "patternExplanations": {
          "Heap/Priority Queue": "Use min-heap of size k. Add all elements. Heap top is kth largest. O(n log k).",
          "Quickselect": "Partition-based selection like quicksort. Average O(n), but worst case O(n^2)."
      },
      "hints": [
          "Kth largest = (n-k+1)th smallest. How can you find this efficiently?",
          "A min-heap of size k keeps the k largest elements. What's at the top?",
          "Add elements to heap. If size > k, remove smallest. Finally, top is kth largest."
      ],
      "solution": {
          "approach": "Min-heap of size k. Add all elements, remove if size > k. Result is heap top.",
          "timeComplexity": "O(n log k)",
          "spaceComplexity": "O(k)",
          "keyInsight": "Min-heap of size k naturally filters to keep k largest, with smallest of those on top."
      }
  },
  216: {
      "title": "Combination Sum III",
      "slug": "combination-sum-iii",
      "difficulty": "medium",
      "primaryPattern": "Backtracking",
      "acceptablePatterns": [],
      "explanation": "Explore all possible solutions recursively. Build candidates incrementally and abandon paths that cannot lead to solution.",
      "lists": [
          "leetcode-75"
      ],
      "category": "Backtracking",
      "patternExplanations": {
          "Backtracking": "Choose k numbers from 1-9 that sum to n. Backtrack, trying each number once."
      },
      "hints": [
          "Similar to Combination Sum, but exactly k numbers, each from 1-9, no repeats.",
          "Backtrack through choices. Track count and remaining sum.",
          "Start each recursion from the next number to avoid duplicates."
      ],
      "solution": {
          "approach": "Backtrack with start index (1-9), remaining count k, remaining sum n. Add when k=0 and n=0.",
          "timeComplexity": "O(C(9,k) * k)",
          "spaceComplexity": "O(k)",
          "keyInsight": "Limited to digits 1-9, each used once. Constrained backtracking."
      }
  },
  217: {
      "title": "Contains Duplicate",
      "slug": "contains-duplicate",
      "difficulty": "easy",
      "lists": [
          "neetcode-150"
      ],
      "category": "Arrays & Hashing",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Sorting"
      ],
      "patternExplanations": {
          "Hash Map": "Add each number to a set. If you try to add a number that's already there, you found a duplicate. O(n) time, O(n) space.",
          "Sorting": "Sort the array first, then adjacent duplicates will be next to each other. O(n log n) time, O(1) space if sorting in-place."
      },
      "hints": [
          "What's the simplest way to know if you've seen a number before?",
          "A Set automatically rejects duplicates - how can you use that?",
          "Alternatively, if the array were sorted, where would duplicates appear?"
      ],
      "solution": {
          "approach": "Use a HashSet to track seen numbers. Return true if a number is already in the set.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)",
          "keyInsight": "Detecting duplicates is fundamentally about tracking 'have I seen this before?'"
      }
  },
  218: {
      "title": "The Skyline Problem",
      "slug": "the-skyline-problem",
      "difficulty": "hard",
      "primaryPattern": "Heap/Priority Queue",
      "acceptablePatterns": [
          "Hash Map",
          "Binary Search",
          "Two Pointers"
      ],
      "explanation": "Maintain ordered access to min/max elements. Useful for k-largest/smallest, merging, or scheduling problems."
  },
  219: {
      "title": "Contains Duplicate II",
      "slug": "contains-duplicate-ii",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Sliding Window"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  220: {
      "title": "Contains Duplicate III",
      "slug": "contains-duplicate-iii",
      "difficulty": "hard",
      "primaryPattern": "Sliding Window",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Maintain a window of elements that slides through the array. Expand when adding elements, contract when removing. Track window state."
  },
  221: {
      "title": "Maximal Square",
      "slug": "maximal-square",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "DFS"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  222: {
      "title": "Count Complete Tree Nodes",
      "slug": "count-complete-tree-nodes",
      "difficulty": "easy",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Tree Traversal"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  223: {
      "title": "Rectangle Area",
      "slug": "rectangle-area",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  224: {
      "title": "Basic Calculator",
      "slug": "basic-calculator",
      "difficulty": "hard",
      "primaryPattern": "Stack",
      "acceptablePatterns": [
          "Hash Map",
          "DFS"
      ],
      "explanation": "LIFO structure for nested patterns, matching pairs, or maintaining monotonic sequences."
  },
  225: {
      "title": "Implement Stack using Queues",
      "slug": "implement-stack-using-queues",
      "difficulty": "easy",
      "primaryPattern": "Stack",
      "acceptablePatterns": [
          "Hash Map",
          "BFS"
      ],
      "explanation": "LIFO structure for nested patterns, matching pairs, or maintaining monotonic sequences."
  },
  226: {
      "title": "Invert Binary Tree",
      "slug": "invert-binary-tree",
      "difficulty": "easy",
      "lists": [
          "neetcode-150"
      ],
      "category": "Trees",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "BFS"
      ],
      "patternExplanations": {
          "DFS": "Recursively invert left and right subtrees, then swap them. Process each node once.",
          "BFS": "Level by level, swap left and right children of each node. Same result, different traversal."
      },
      "hints": [
          "Inverting means swapping left and right children at every node.",
          "If you invert the subtrees first, then swap them, does order matter?",
          "Recursively: invert(left), invert(right), then swap left and right."
      ],
      "solution": {
          "approach": "DFS: for each node, swap left and right children, recursively invert both subtrees.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(h) recursion stack",
          "keyInsight": "Inverting is just swapping children at every node - recursion handles the traversal."
      }
  },
  227: {
      "title": "Basic Calculator II",
      "slug": "basic-calculator-ii",
      "difficulty": "medium",
      "primaryPattern": "Stack",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "LIFO structure for nested patterns, matching pairs, or maintaining monotonic sequences."
  },
  228: {
      "title": "Summary Ranges",
      "slug": "summary-ranges",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  229: {
      "title": "Majority Element II",
      "slug": "majority-element-ii",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  230: {
      "title": "Kth Smallest Element in a BST",
      "slug": "kth-smallest-element-in-a-bst",
      "difficulty": "medium",
      "lists": [
          "neetcode-150"
      ],
      "category": "Trees",
      "primaryPattern": "DFS",
      "acceptablePatterns": [],
      "patternExplanations": {
          "DFS": "Inorder traversal of BST visits nodes in sorted order. Count nodes during traversal, stop at k."
      },
      "hints": [
          "In a BST, which traversal order gives you elements in sorted order?",
          "Inorder: left, node, right. For BST this is ascending order.",
          "Do inorder traversal, count nodes visited. When count reaches k, that's your answer."
      ],
      "solution": {
          "approach": "Inorder traversal (iterative or recursive), count elements, return when count = k.",
          "timeComplexity": "O(h + k)",
          "spaceComplexity": "O(h)",
          "keyInsight": "BST inorder traversal = sorted order. Kth smallest = kth element in inorder."
      }
  },
  231: {
      "title": "Power of Two",
      "slug": "power-of-two",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "DFS"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  232: {
      "title": "Implement Queue using Stacks",
      "slug": "implement-queue-using-stacks",
      "difficulty": "easy",
      "primaryPattern": "Stack",
      "acceptablePatterns": [
          "Hash Map",
          "BFS"
      ],
      "explanation": "LIFO structure for nested patterns, matching pairs, or maintaining monotonic sequences."
  },
  233: {
      "title": "Number of Digit One",
      "slug": "number-of-digit-one",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "DFS"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  234: {
      "title": "Palindrome Linked List",
      "slug": "palindrome-linked-list",
      "difficulty": "easy",
      "primaryPattern": "Linked List",
      "acceptablePatterns": [
          "Two Pointers",
          "Stack",
          "DFS"
      ],
      "explanation": "Pointer manipulation for reversing, merging, detecting cycles, or finding intersections in linked structures."
  },
  235: {
      "title": "Lowest Common Ancestor of a Binary Search Tree",
      "slug": "lowest-common-ancestor-of-a-binary-search-tree",
      "difficulty": "medium",
      "lists": [
          "neetcode-150"
      ],
      "category": "Trees",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "DFS"
      ],
      "patternExplanations": {
          "Binary Search": "Use BST property: if both p and q are smaller, go left. If both larger, go right. Otherwise, current node is LCA.",
          "DFS": "BST property guides the search - no need to check both subtrees like in regular binary tree."
      },
      "hints": [
          "In a BST, all left descendants are smaller, all right descendants are larger.",
          "If p and q are on different sides of current node, current node is their LCA. Why?",
          "If both p and q are smaller than current, LCA must be in left subtree. Similarly for right."
      ],
      "solution": {
          "approach": "If p and q both < node, go left. If both > node, go right. Otherwise return node (it's the split point).",
          "timeComplexity": "O(h)",
          "spaceComplexity": "O(1) iterative, O(h) recursive",
          "keyInsight": "BST property means the first node where p and q 'split' (go different directions) is the LCA."
      }
  },
  236: {
      "title": "Lowest Common Ancestor of a Binary Tree",
      "slug": "lowest-common-ancestor-of-a-binary-tree",
      "difficulty": "medium",
      "lists": [
          "leetcode-75"
      ],
      "category": "Binary Tree - DFS",
      "primaryPattern": "DFS",
      "acceptablePatterns": [],
      "patternExplanations": {
          "DFS": "Recursively search. If node is p or q, return it. If left and right both return non-null, current is LCA. Else return non-null child."
      },
      "hints": [
          "LCA: deepest node that has both p and q as descendants (node can be its own descendant).",
          "Recursively: if current is p or q, return it. Search left and right subtrees.",
          "If both subtrees return non-null, current node is LCA. Else return whichever is non-null."
      ],
      "solution": {
          "approach": "If node is null/p/q, return node. Recurse left and right. If both non-null, return node. Else return non-null one.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(h)",
          "keyInsight": "Node is LCA if p and q are found in different subtrees (or node itself is p or q)."
      }
  },
  237: {
      "title": "Delete Node in a Linked List",
      "slug": "delete-node-in-a-linked-list",
      "difficulty": "medium",
      "primaryPattern": "Linked List",
      "acceptablePatterns": [],
      "explanation": "Pointer manipulation for reversing, merging, detecting cycles, or finding intersections in linked structures."
  },
  238: {
      "title": "Product of Array Except Self",
      "slug": "product-of-array-except-self",
      "difficulty": "medium",
      "lists": [
          "neetcode-150",
          "leetcode-75"
      ],
      "category": "Arrays & Hashing",
      "primaryPattern": "Prefix/Suffix",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "patternExplanations": {
          "Prefix/Suffix": "For each position, answer = (product of all elements before) × (product of all elements after). Build prefix and suffix products.",
          "Hash Map": "Not ideal, but you could precompute total product and divide (fails with zeros). Prefix/suffix is the clean approach."
      },
      "hints": [
          "The answer for position i is the product of everything except nums[i]. Can you split this?",
          "Product of everything before i × product of everything after i = answer for i.",
          "Can you compute all prefix products in one pass, then all suffix products in another?"
      ],
      "solution": {
          "approach": "First pass: build prefix products. Second pass: multiply by suffix products (computed on the fly).",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1) extra (output array doesn't count)",
          "keyInsight": "Decompose 'everything except self' into 'everything before' × 'everything after'."
      }
  },
  239: {
      "title": "Sliding Window Maximum",
      "slug": "sliding-window-maximum",
      "difficulty": "hard",
      "primaryPattern": "Sliding Window",
      "acceptablePatterns": [
          "Heap"
      ],
      "explanation": "Maintain a window of elements that slides through the array. Expand when adding elements, contract when removing. Track window state.",
      "lists": [
          "neetcode-150"
      ],
      "category": "Sliding Window",
      "patternExplanations": {
          "Sliding Window": "Monotonic decreasing deque. Remove smaller elements when adding. Remove out-of-window elements.",
          "Heap": "Max-heap of (value, index). Pop elements outside window before getting max."
      },
      "hints": [
          "For each window, you need the maximum. Naive is O(nk). Can you do O(n)?",
          "Use a deque to maintain indices of useful elements in decreasing order.",
          "When adding nums[i], remove all smaller elements from back (they'll never be max). Remove front if outside window."
      ],
      "solution": {
          "approach": "Deque of indices in decreasing order of values. Pop back if smaller, pop front if outside window.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(k)",
          "keyInsight": "Monotonic deque: smaller elements are useless once a larger one enters the window."
      }
  },
  240: {
      "title": "Search a 2D Matrix II",
      "slug": "search-a-2d-matrix-ii",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "DFS"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  241: {
      "title": "Different Ways to Add Parentheses",
      "slug": "different-ways-to-add-parentheses",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "DFS"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  242: {
      "title": "Valid Anagram",
      "slug": "valid-anagram",
      "difficulty": "easy",
      "lists": [
          "neetcode-150"
      ],
      "category": "Arrays & Hashing",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Sorting"
      ],
      "patternExplanations": {
          "Hash Map": "Count character frequencies in both strings. If the frequency maps are identical, they're anagrams. O(n) time.",
          "Sorting": "Sort both strings and compare. Anagrams will produce identical sorted strings. O(n log n) time."
      },
      "hints": [
          "What makes two words anagrams of each other?",
          "Anagrams have the exact same letters, just rearranged. How can you verify this?",
          "Count each letter's frequency - what should be true for anagrams?"
      ],
      "solution": {
          "approach": "Build frequency map for each string, compare maps (or use single map with increment/decrement).",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1) - at most 26 letters",
          "keyInsight": "Anagrams are defined by character counts, not character positions."
      }
  },
  252: {
      "title": "Meeting Rooms",
      "slug": "meeting-rooms",
      "difficulty": "easy",
      "lists": [
          "neetcode-150"
      ],
      "category": "Intervals",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [],
      "patternExplanations": {
          "Greedy": "Sort intervals by start time. Check if any overlap (end > next start)."
      },
      "hints": [
          "If any two meetings overlap, can't attend all.",
          "Sort by start time. Check each consecutive pair.",
          "If meeting[i].end > meeting[i+1].start, they overlap."
      ],
      "solution": {
          "approach": "Sort by start time. For each pair of consecutive meetings, check if they overlap.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "keyInsight": "Sorted by start: only need to check adjacent pairs for overlap."
      }
  },
  253: {
      "title": "Meeting Rooms II",
      "slug": "meeting-rooms-ii",
      "difficulty": "medium",
      "lists": [
          "neetcode-150"
      ],
      "category": "Intervals",
      "primaryPattern": "Heap",
      "acceptablePatterns": [
          "Greedy"
      ],
      "patternExplanations": {
          "Heap": "Sort by start. Min-heap of end times. For each meeting, if can reuse room (end <= start), pop. Push new end.",
          "Greedy": "Count maximum concurrent meetings. Sort all start/end points, track running count."
      },
      "hints": [
          "Minimum rooms = maximum number of concurrent meetings.",
          "Sort by start time. Track end times of ongoing meetings.",
          "Min-heap of end times. For each meeting: if earliest end <= new start, reuse that room. Always add new end."
      ],
      "solution": {
          "approach": "Sort by start. Min-heap of end times. For each meeting, pop if top <= start (room freed). Push new end. Max heap size = rooms.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(n)",
          "keyInsight": "Heap tracks rooms by end time. Can reuse room if earliest-ending room ends before new meeting starts."
      }
  },
  257: {
      "title": "Binary Tree Paths",
      "slug": "binary-tree-paths",
      "difficulty": "easy",
      "primaryPattern": "Backtracking",
      "acceptablePatterns": [
          "Hash Map",
          "Tree Traversal",
          "DFS"
      ],
      "explanation": "Explore all possible solutions recursively. Build candidates incrementally and abandon paths that cannot lead to solution."
  },
  258: {
      "title": "Add Digits",
      "slug": "add-digits",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  260: {
      "title": "Single Number III",
      "slug": "single-number-iii",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  261: {
      "title": "Graph Valid Tree",
      "slug": "graph-valid-tree",
      "difficulty": "medium",
      "lists": [
          "neetcode-150"
      ],
      "category": "Graphs",
      "primaryPattern": "Union Find",
      "acceptablePatterns": [
          "DFS"
      ],
      "patternExplanations": {
          "Union Find": "Tree has n-1 edges and is connected. Use union-find: if edge creates cycle, invalid. Finally check one component.",
          "DFS": "Tree = connected + acyclic. Check both with DFS."
      },
      "hints": [
          "A tree with n nodes has exactly n-1 edges and is connected.",
          "Also, a tree has no cycles.",
          "Union-Find: process edges. If edge connects same component, it's a cycle. After, check all in one component."
      ],
      "solution": {
          "approach": "Check edges = n-1. Union-Find: if union returns false (same component), there's a cycle. Check one component at end.",
          "timeComplexity": "O(n α(n))",
          "spaceComplexity": "O(n)",
          "keyInsight": "Tree = n-1 edges + connected + no cycles. Union-Find checks cycles and connectivity."
      }
  },
  262: {
      "title": "Trips and Users",
      "slug": "trips-and-users",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  263: {
      "title": "Ugly Number",
      "slug": "ugly-number",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  264: {
      "title": "Ugly Number II",
      "slug": "ugly-number-ii",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Dynamic Programming",
          "Heap/Priority Queue"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  268: {
      "title": "Missing Number",
      "slug": "missing-number",
      "difficulty": "easy",
      "lists": [
          "neetcode-150"
      ],
      "category": "Bit Manipulation",
      "primaryPattern": "Bit Manipulation",
      "acceptablePatterns": [
          "Hash Map",
          "Math"
      ],
      "patternExplanations": {
          "Bit Manipulation": "XOR all indices 0 to n with all elements. Pairs cancel, missing number remains.",
          "Math": "Expected sum = n*(n+1)/2. Actual sum = sum of array. Missing = expected - actual.",
          "Hash Map": "Store all elements, find which 0 to n is missing. Uses O(n) space."
      },
      "hints": [
          "Array contains n numbers in range [0, n]. One is missing.",
          "Sum approach: expected sum of 0 to n minus actual sum = missing number.",
          "XOR approach: XOR indices 0 to n with array elements. Duplicates cancel."
      ],
      "solution": {
          "approach": "XOR: result = n (covers the index). Then result ^= i ^ nums[i] for all i. Or use sum formula.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "keyInsight": "Both math (sum) and XOR leverage the complete range [0,n] vs array contents."
      }
  },
  269: {
      "title": "Alien Dictionary",
      "slug": "alien-dictionary",
      "difficulty": "hard",
      "lists": [
          "neetcode-150"
      ],
      "category": "Graphs",
      "primaryPattern": "Topological Sort",
      "acceptablePatterns": [],
      "patternExplanations": {
          "Topological Sort": "Build order graph from adjacent word pairs. Topological sort gives valid ordering. Detect cycle = invalid."
      },
      "hints": [
          "Compare adjacent words to find character ordering.",
          "First differing char in adjacent words tells you: earlier char < later char.",
          "Build directed graph. Topological sort. If cycle exists, no valid order."
      ],
      "solution": {
          "approach": "Compare adjacent words for ordering. Build graph. Topological sort (Kahn's). Detect cycle. Return order.",
          "timeComplexity": "O(total chars)",
          "spaceComplexity": "O(unique chars)",
          "keyInsight": "Adjacent sorted words reveal character order. Edge a->b means a comes before b."
      }
  },
  271: {
      "title": "Encode and Decode Strings",
      "slug": "encode-and-decode-strings",
      "difficulty": "medium",
      "lists": [
          "neetcode-150"
      ],
      "category": "Design",
      "primaryPattern": "Design",
      "acceptablePatterns": [],
      "patternExplanations": {
          "Design": "Encode with length prefix: '3#abc' for 'abc'. Decode by reading length, then extracting string."
      },
      "hints": [
          "Strings can contain any characters including delimiters.",
          "Use length-prefix encoding: store length before each string.",
          "Format: 'len#string'. To decode, read until #, parse length, extract that many chars."
      ],
      "solution": {
          "approach": "Encode: len(s) + '#' + s for each string. Decode: read number until '#', extract that many chars, repeat.",
          "timeComplexity": "O(n) total chars",
          "spaceComplexity": "O(n)",
          "keyInsight": "Length prefix avoids delimiter conflicts. Any character is safe in the string itself."
      }
  },
  273: {
      "title": "Integer to English Words",
      "slug": "integer-to-english-words",
      "difficulty": "hard",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  274: {
      "title": "H-Index",
      "slug": "h-index",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  275: {
      "title": "H-Index II",
      "slug": "h-index-ii",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  278: {
      "title": "First Bad Version",
      "slug": "first-bad-version",
      "difficulty": "easy",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  279: {
      "title": "Perfect Squares",
      "slug": "perfect-squares",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "BFS"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  282: {
      "title": "Expression Add Operators",
      "slug": "expression-add-operators",
      "difficulty": "hard",
      "primaryPattern": "Backtracking",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Explore all possible solutions recursively. Build candidates incrementally and abandon paths that cannot lead to solution."
  },
  283: {
      "title": "Move Zeroes",
      "slug": "move-zeroes",
      "difficulty": "easy",
      "lists": [
          "leetcode-75"
      ],
      "category": "Two Pointers",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [],
      "patternExplanations": {
          "Two Pointers": "Slow pointer tracks position for next non-zero. Fast pointer scans array. Swap when fast finds non-zero."
      },
      "hints": [
          "Move all non-zero elements to the front, maintaining relative order.",
          "Two pointers: slow marks where next non-zero should go, fast finds non-zeros.",
          "When fast finds non-zero, swap with slow position, advance both. Else just advance fast."
      ],
      "solution": {
          "approach": "slow = 0. For fast in range(n): if nums[fast] != 0, swap nums[slow] and nums[fast], slow++.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "keyInsight": "Partition-like operation: non-zeros to the left, zeros to the right."
      }
  },
  284: {
      "title": "Peeking Iterator",
      "slug": "peeking-iterator",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  286: {
      "title": "Walls and Gates",
      "slug": "walls-and-gates",
      "difficulty": "medium",
      "lists": [
          "neetcode-150"
      ],
      "category": "Graphs",
      "primaryPattern": "BFS",
      "acceptablePatterns": [],
      "patternExplanations": {
          "BFS": "Multi-source BFS from all gates. Each cell gets distance to nearest gate."
      },
      "hints": [
          "Each room should have distance to nearest gate.",
          "BFS from single source gives distance from that source. What about multiple sources?",
          "Multi-source BFS: start from all gates simultaneously. First visit to each room gives shortest distance."
      ],
      "solution": {
          "approach": "Queue all gates. BFS: for each cell, if neighbor is INF, set to distance+1 and queue.",
          "timeComplexity": "O(m * n)",
          "spaceComplexity": "O(m * n)",
          "keyInsight": "Multi-source BFS: treat all gates as distance 0 starting points. BFS gives shortest path."
      }
  },
  287: {
      "title": "Find the Duplicate Number",
      "slug": "find-the-duplicate-number",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Binary Search"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds.",
      "lists": [
          "neetcode-150"
      ],
      "category": "Linked List",
      "patternExplanations": {
          "Two Pointers": "Floyd's cycle detection. Array indices as next pointers. The cycle start is the duplicate.",
          "Binary Search": "Binary search on value range [1,n]. Count elements <= mid. If count > mid, duplicate is <= mid."
      },
      "hints": [
          "There are n+1 numbers in range [1,n]. By pigeonhole, there's a duplicate.",
          "Think of array as linked list: value at index i points to next index.",
          "A duplicate means two indices point to the same value - that's a cycle! Use cycle detection."
      ],
      "solution": {
          "approach": "Floyd's algorithm: slow = nums[slow], fast = nums[nums[fast]]. Find cycle, then find entrance.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "keyInsight": "Treating values as pointers creates a linked list. Duplicate = cycle entrance."
      }
  },
  289: {
      "title": "Game of Life",
      "slug": "game-of-life",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  290: {
      "title": "Word Pattern",
      "slug": "word-pattern",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  292: {
      "title": "Nim Game",
      "slug": "nim-game",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  295: {
      "title": "Find Median from Data Stream",
      "slug": "find-median-from-data-stream",
      "difficulty": "hard",
      "lists": [
          "neetcode-150"
      ],
      "category": "Heap / Priority Queue",
      "primaryPattern": "Heap/Priority Queue",
      "acceptablePatterns": [],
      "patternExplanations": {
          "Heap/Priority Queue": "Two heaps: max-heap for lower half, min-heap for upper half. Median is from heap tops."
      },
      "hints": [
          "Median is the middle element. Need quick access to middle as elements are added.",
          "What if you kept the smaller half in one structure and larger half in another?",
          "Max-heap for small half (gives max of small), min-heap for large half (gives min of large). Balance sizes."
      ],
      "solution": {
          "approach": "Max-heap for lower half, min-heap for upper half. Keep sizes balanced (differ by at most 1). Median from top(s).",
          "timeComplexity": "O(log n) add, O(1) findMedian",
          "spaceComplexity": "O(n)",
          "keyInsight": "Two heaps maintain the partition around the median, giving O(1) access to middle elements."
      }
  },
  297: {
      "title": "Serialize and Deserialize Binary Tree",
      "slug": "serialize-and-deserialize-binary-tree",
      "difficulty": "hard",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "BFS"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation.",
      "lists": [
          "neetcode-150"
      ],
      "category": "Trees",
      "patternExplanations": {
          "DFS": "Serialize with preorder, marking nulls. Deserialize by reading preorder, creating nodes or nulls.",
          "BFS": "Level-order traversal for serialization. Include nulls to preserve structure."
      },
      "hints": [
          "You need to encode the tree structure in a string, then reconstruct it.",
          "Preorder traversal with null markers is a common approach.",
          "Serialize: 1,2,null,null,3,4,null,null,5,null,null. Use queue/recursion to deserialize."
      ],
      "solution": {
          "approach": "Serialize with preorder DFS, using 'null' for empty nodes. Deserialize by reading tokens and recursing.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)",
          "keyInsight": "Preorder with null markers uniquely identifies tree structure. No need for inorder."
      }
  },
  299: {
      "title": "Bulls and Cows",
      "slug": "bulls-and-cows",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  300: {
      "title": "Longest Increasing Subsequence",
      "slug": "longest-increasing-subsequence",
      "difficulty": "medium",
      "lists": [
          "neetcode-150"
      ],
      "category": "1-D Dynamic Programming",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Binary Search"
      ],
      "patternExplanations": {
          "Dynamic Programming": "dp[i] = LIS ending at index i. For each j < i where nums[j] < nums[i]: dp[i] = max(dp[i], dp[j] + 1). O(n^2).",
          "Binary Search": "Maintain array of smallest tail for each LIS length. Binary search to find position to update. O(n log n)."
      },
      "hints": [
          "For each position i, what's the longest increasing subsequence that ends at i?",
          "LIS ending at i = 1 + max(LIS ending at any j < i where nums[j] < nums[i]).",
          "O(n^2) DP works. For O(n log n), maintain tails array and use binary search."
      ],
      "solution": {
          "approach": "O(n^2): dp[i] = max(dp[j] + 1) for all j < i where nums[j] < nums[i]. Answer = max(dp).",
          "timeComplexity": "O(n^2) or O(n log n)",
          "spaceComplexity": "O(n)",
          "keyInsight": "Each element extends the best LIS from some previous element that's smaller."
      }
  },
  301: {
      "title": "Remove Invalid Parentheses",
      "slug": "remove-invalid-parentheses",
      "difficulty": "hard",
      "primaryPattern": "Backtracking",
      "acceptablePatterns": [
          "Hash Map",
          "BFS"
      ],
      "explanation": "Explore all possible solutions recursively. Build candidates incrementally and abandon paths that cannot lead to solution."
  },
  303: {
      "title": "Range Sum Query - Immutable",
      "slug": "range-sum-query-immutable",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  304: {
      "title": "Range Sum Query 2D - Immutable",
      "slug": "range-sum-query-2d-immutable",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "DFS"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  306: {
      "title": "Additive Number",
      "slug": "additive-number",
      "difficulty": "medium",
      "primaryPattern": "Backtracking",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Explore all possible solutions recursively. Build candidates incrementally and abandon paths that cannot lead to solution."
  },
  307: {
      "title": "Range Sum Query - Mutable",
      "slug": "range-sum-query-mutable",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  309: {
      "title": "Best Time to Buy and Sell Stock with Cooldown",
      "slug": "best-time-to-buy-and-sell-stock-with-cooldown",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization.",
      "lists": [
          "neetcode-150"
      ],
      "category": "Dynamic Programming",
      "patternExplanations": {
          "Dynamic Programming": "Track states: holding stock, cooldown, not holding. Transition based on actions."
      },
      "hints": [
          "At each day, you can be in one of three states: holding stock, cooling down, or ready to buy.",
          "holding[i] = max(holding[i-1], notHolding[i-1] - price)",
          "notHolding[i] = max(notHolding[i-1], cooldown[i-1]). cooldown[i] = holding[i-1] + price."
      ],
      "solution": {
          "approach": "3 states: hold, sold (cooldown), ready. Transition: hold = max(hold, ready-price), sold = hold+price, ready = max(ready, sold).",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "keyInsight": "The cooldown constraint means you can't buy immediately after selling. Track sold state separately."
      }
  },
  310: {
      "title": "Minimum Height Trees",
      "slug": "minimum-height-trees",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "BFS",
          "Graph"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  312: {
      "title": "Burst Balloons",
      "slug": "burst-balloons",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization.",
      "lists": [
          "neetcode-150"
      ],
      "category": "Dynamic Programming",
      "patternExplanations": {
          "Dynamic Programming": "dp[i][j] = max coins from bursting balloons in range (i,j). Choose last balloon to burst in range."
      },
      "hints": [
          "If you think about which balloon to burst first, the subproblems aren't independent.",
          "Instead, think about which balloon to burst LAST in a range.",
          "If balloon k is last in range (i,j), coins = dp[i][k] + dp[k][j] + nums[i]*nums[k]*nums[j]."
      ],
      "solution": {
          "approach": "DP on ranges. dp[i][j] = max coins from (i,j). Try each k as last burst. Pad array with 1s at ends.",
          "timeComplexity": "O(n^3)",
          "spaceComplexity": "O(n^2)",
          "keyInsight": "Choosing last balloon (not first) makes subproblems independent. Boundaries are fixed."
      }
  },
  313: {
      "title": "Super Ugly Number",
      "slug": "super-ugly-number",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  315: {
      "title": "Count of Smaller Numbers After Self",
      "slug": "count-of-smaller-numbers-after-self",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  316: {
      "title": "Remove Duplicate Letters",
      "slug": "remove-duplicate-letters",
      "difficulty": "medium",
      "primaryPattern": "Stack",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy"
      ],
      "explanation": "LIFO structure for nested patterns, matching pairs, or maintaining monotonic sequences."
  },
  318: {
      "title": "Maximum Product of Word Lengths",
      "slug": "maximum-product-of-word-lengths",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  319: {
      "title": "Bulb Switcher",
      "slug": "bulb-switcher",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  321: {
      "title": "Create Maximum Number",
      "slug": "create-maximum-number",
      "difficulty": "hard",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map",
          "Stack",
          "Greedy"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  322: {
      "title": "Coin Change",
      "slug": "coin-change",
      "difficulty": "medium",
      "lists": [
          "neetcode-150"
      ],
      "category": "1-D Dynamic Programming",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "BFS"
      ],
      "patternExplanations": {
          "Dynamic Programming": "dp[amount] = min coins to make that amount. For each coin c: dp[a] = min(dp[a], dp[a-c] + 1).",
          "BFS": "BFS from 0, each edge adds one coin. First time reaching target amount = min coins."
      },
      "hints": [
          "To make amount a, you can use any coin c where c <= a. Then you need to make amount a-c.",
          "dp[a] = minimum of (dp[a-c] + 1) for all coins c.",
          "Build up from amount 0. dp[0] = 0. For each amount, try each coin."
      ],
      "solution": {
          "approach": "dp[0] = 0, dp[i] = infinity initially. For i from 1 to amount, for each coin: dp[i] = min(dp[i], dp[i-coin]+1).",
          "timeComplexity": "O(amount * coins)",
          "spaceComplexity": "O(amount)",
          "keyInsight": "Unbounded knapsack variant - can use each coin unlimited times."
      }
  },
  323: {
      "title": "Number of Connected Components in an Undirected Graph",
      "slug": "number-of-connected-components-in-an-undirected-graph",
      "difficulty": "medium",
      "lists": [
          "neetcode-150"
      ],
      "category": "Graphs",
      "primaryPattern": "Union Find",
      "acceptablePatterns": [
          "DFS",
          "BFS"
      ],
      "patternExplanations": {
          "Union Find": "Initially n components. Each edge potentially merges two. Final count = components.",
          "DFS": "DFS from each unvisited node. Count how many DFS traversals needed."
      },
      "hints": [
          "Count distinct connected components.",
          "Union-Find: start with n components. Each edge merges two (if different).",
          "Count components by counting unique roots (or track component count as you union)."
      ],
      "solution": {
          "approach": "Union-Find: start with n components. For each edge, union. If roots different, decrement count. Return final count.",
          "timeComplexity": "O(E α(n))",
          "spaceComplexity": "O(n)",
          "keyInsight": "Each successful union reduces component count by 1."
      }
  },
  324: {
      "title": "Wiggle Sort II",
      "slug": "wiggle-sort-ii",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Binary Search",
          "Two Pointers",
          "Heap/Priority Queue"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  326: {
      "title": "Power of Three",
      "slug": "power-of-three",
      "difficulty": "easy",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  327: {
      "title": "Count of Range Sum",
      "slug": "count-of-range-sum",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  328: {
      "title": "Odd Even Linked List",
      "slug": "odd-even-linked-list",
      "difficulty": "medium",
      "lists": [
          "leetcode-75"
      ],
      "category": "Linked List",
      "primaryPattern": "Linked List",
      "acceptablePatterns": [],
      "patternExplanations": {
          "Linked List": "Build two separate lists: odd-indexed and even-indexed. Connect odd list tail to even list head."
      },
      "hints": [
          "Group nodes by index parity: all odd indices first, then all even indices.",
          "Maintain two lists: odd and even. Iterate, adding nodes to appropriate list.",
          "At end, connect oddTail.next = evenHead."
      ],
      "solution": {
          "approach": "oddHead = head, evenHead = head.next. Build odd and even chains. Connect odd.next = evenHead.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "keyInsight": "Separate into two chains, then join. Careful with pointer manipulation."
      }
  },
  329: {
      "title": "Longest Increasing Path in a Matrix",
      "slug": "longest-increasing-path-in-a-matrix",
      "difficulty": "hard",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Dynamic Programming"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization.",
      "lists": [
          "neetcode-150"
      ],
      "category": "Dynamic Programming",
      "patternExplanations": {
          "DFS": "DFS with memoization. For each cell, compute longest path starting there by checking neighbors.",
          "Dynamic Programming": "Topological order by value. Process smaller values first. dp[i][j] = 1 + max(neighbors)."
      },
      "hints": [
          "From each cell, you can move to adjacent cells with larger values.",
          "DFS from each cell to find longest path. But this has overlapping subproblems.",
          "Memoize! Once you compute longest path from a cell, store it."
      ],
      "solution": {
          "approach": "DFS with memoization. For each cell, recursively find max of 1 + dfs(neighbor) for valid neighbors.",
          "timeComplexity": "O(m * n)",
          "spaceComplexity": "O(m * n)",
          "keyInsight": "Strictly increasing means no cycles, so memoization works perfectly."
      }
  },
  330: {
      "title": "Patching Array",
      "slug": "patching-array",
      "difficulty": "hard",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  331: {
      "title": "Verify Preorder Serialization of a Binary Tree",
      "slug": "verify-preorder-serialization-of-a-binary-tree",
      "difficulty": "medium",
      "primaryPattern": "Stack",
      "acceptablePatterns": [
          "Hash Map",
          "Tree Traversal"
      ],
      "explanation": "LIFO structure for nested patterns, matching pairs, or maintaining monotonic sequences."
  },
  332: {
      "title": "Reconstruct Itinerary",
      "slug": "reconstruct-itinerary",
      "difficulty": "hard",
      "primaryPattern": "DFS",
      "acceptablePatterns": [],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation.",
      "lists": [
          "neetcode-150"
      ],
      "category": "Graphs",
      "patternExplanations": {
          "DFS": "Hierholzer's algorithm: DFS through edges, add to result in post-order. Reverse at end."
      },
      "hints": [
          "This is finding an Eulerian path - visit every edge exactly once.",
          "Sort destinations lexicographically. Use DFS to visit edges.",
          "Add airport to result AFTER exploring all its edges (post-order). Reverse at end."
      ],
      "solution": {
          "approach": "Build graph with sorted adjacency lists. DFS greedily, add to result after all edges used. Reverse result.",
          "timeComplexity": "O(E log E) for sorting",
          "spaceComplexity": "O(E)",
          "keyInsight": "Post-order DFS naturally builds Eulerian path in reverse. Sorting gives lexicographic result."
      }
  },
  334: {
      "title": "Increasing Triplet Subsequence",
      "slug": "increasing-triplet-subsequence",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum.",
      "lists": [
          "leetcode-75"
      ],
      "category": "Greedy",
      "patternExplanations": {
          "Greedy": "Track smallest and second smallest seen. If current > both, triplet exists."
      },
      "hints": [
          "You need i < j < k with nums[i] < nums[j] < nums[k].",
          "Track the smallest element seen. Track smallest element that has a smaller element before it.",
          "If you find an element larger than both, you found the triplet."
      ],
      "solution": {
          "approach": "Track first (smallest) and second (smallest with smaller before it). Return true if any num > second.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "keyInsight": "Greedy update first and second. Second implicitly has a smaller element before it."
      }
  },
  335: {
      "title": "Self Crossing",
      "slug": "self-crossing",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  336: {
      "title": "Palindrome Pairs",
      "slug": "palindrome-pairs",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Trie"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  337: {
      "title": "House Robber III",
      "slug": "house-robber-iii",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Tree Traversal",
          "DFS"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  338: {
      "title": "Counting Bits",
      "slug": "counting-bits",
      "difficulty": "easy",
      "lists": [
          "neetcode-150",
          "leetcode-75"
      ],
      "category": "Bit Manipulation",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Bit Manipulation"
      ],
      "patternExplanations": {
          "Dynamic Programming": "dp[i] = dp[i >> 1] + (i & 1). Number of 1s in i = 1s in i/2 plus the last bit.",
          "Bit Manipulation": "Or dp[i] = dp[i & (i-1)] + 1. Removing lowest 1-bit gives a smaller number."
      },
      "hints": [
          "Count 1-bits for every number from 0 to n.",
          "Can you use previous answers? How does count for i relate to count for i/2?",
          "i and i>>1 differ only in the last bit. dp[i] = dp[i>>1] + (i&1)."
      ],
      "solution": {
          "approach": "dp[0] = 0. For i from 1 to n: dp[i] = dp[i >> 1] + (i & 1).",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)",
          "keyInsight": "Right shift relationship lets you build on previous answers."
      }
  },
  341: {
      "title": "Flatten Nested List Iterator",
      "slug": "flatten-nested-list-iterator",
      "difficulty": "medium",
      "primaryPattern": "Stack",
      "acceptablePatterns": [
          "Tree Traversal",
          "DFS",
          "Hash Map",
          "BFS"
      ],
      "explanation": "LIFO structure for nested patterns, matching pairs, or maintaining monotonic sequences."
  },
  342: {
      "title": "Power of Four",
      "slug": "power-of-four",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "DFS"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  343: {
      "title": "Integer Break",
      "slug": "integer-break",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  344: {
      "title": "Reverse String",
      "slug": "reverse-string",
      "difficulty": "easy",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  345: {
      "title": "Reverse Vowels of a String",
      "slug": "reverse-vowels-of-a-string",
      "difficulty": "easy",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds.",
      "lists": [
          "leetcode-75"
      ],
      "category": "Two Pointers",
      "patternExplanations": {
          "Two Pointers": "Two pointers from ends. Move inward, swapping when both point to vowels."
      },
      "hints": [
          "Only swap vowels, leave consonants in place.",
          "Use two pointers from start and end.",
          "Move pointers inward. When both point to vowels, swap them."
      ],
      "solution": {
          "approach": "Two pointers. Skip non-vowels. When both at vowels, swap and move both inward.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n) for string manipulation",
          "keyInsight": "Classic two-pointer swap pattern, with condition (vowel check) before swapping."
      }
  },
  347: {
      "title": "Top K Frequent Elements",
      "slug": "top-k-frequent-elements",
      "difficulty": "medium",
      "lists": [
          "neetcode-150"
      ],
      "category": "Arrays & Hashing",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Heap/Priority Queue",
          "Bucket Sort"
      ],
      "patternExplanations": {
          "Hash Map": "Count frequencies, then use bucket sort where index = frequency. Scan buckets from highest to lowest. O(n) time.",
          "Heap/Priority Queue": "Count frequencies, then use a min-heap of size k to track top k elements. O(n log k) time.",
          "Bucket Sort": "Create buckets where bucket[i] contains elements with frequency i. Max frequency is n, so O(n) buckets."
      },
      "hints": [
          "First step: how do you count how often each number appears?",
          "Now you have frequencies - how do you find the k highest?",
          "A heap gives top k in O(n log k), but bucket sort can do O(n). What's the max possible frequency?"
      ],
      "solution": {
          "approach": "Count frequencies with hash map, then bucket sort by frequency (index = frequency count).",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)",
          "keyInsight": "Frequency is bounded by n, so bucket sort achieves linear time."
      }
  },
  349: {
      "title": "Intersection of Two Arrays",
      "slug": "intersection-of-two-arrays",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Two Pointers",
          "Binary Search"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  350: {
      "title": "Intersection of Two Arrays II",
      "slug": "intersection-of-two-arrays-ii",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Two Pointers",
          "Binary Search"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  352: {
      "title": "Data Stream as Disjoint Intervals",
      "slug": "data-stream-as-disjoint-intervals",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Binary Search",
          "Graph"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  354: {
      "title": "Russian Doll Envelopes",
      "slug": "russian-doll-envelopes",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Dynamic Programming",
          "Two Pointers"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  355: {
      "title": "Design Twitter",
      "slug": "design-twitter",
      "difficulty": "medium",
      "primaryPattern": "Heap",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships.",
      "lists": [
          "neetcode-150"
      ],
      "category": "Heap / Priority Queue",
      "patternExplanations": {
          "Heap": "Merge k sorted lists (user timelines). Use heap to get 10 most recent across all followed users.",
          "Hash Map": "Track followers and tweets per user. Merge timelines using heap or sorting."
      },
      "hints": [
          "Each user has a timeline (list of tweets). News feed merges followed users' timelines.",
          "This is like 'Merge K Sorted Lists' - each user's tweets are sorted by time.",
          "Use max-heap to get 10 most recent. Push latest tweet from each followed user, pop max, push next."
      ],
      "solution": {
          "approach": "HashMap for user->followers and user->tweets. getNewsFeed: heap merge of followed users' tweets.",
          "timeComplexity": "O(k log k) for news feed, O(1) for others",
          "spaceComplexity": "O(users + tweets)",
          "keyInsight": "News feed is merging sorted lists. Use heap to efficiently get top k from multiple lists."
      }
  },
  357: {
      "title": "Count Numbers with Unique Digits",
      "slug": "count-numbers-with-unique-digits",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Backtracking"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  363: {
      "title": "Max Sum of Rectangle No Larger Than K",
      "slug": "max-sum-of-rectangle-no-larger-than-k",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "DFS"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  365: {
      "title": "Water and Jug Problem",
      "slug": "water-and-jug-problem",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map",
          "BFS"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  367: {
      "title": "Valid Perfect Square",
      "slug": "valid-perfect-square",
      "difficulty": "easy",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  368: {
      "title": "Largest Divisible Subset",
      "slug": "largest-divisible-subset",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  371: {
      "title": "Sum of Two Integers",
      "slug": "sum-of-two-integers",
      "difficulty": "medium",
      "primaryPattern": "Bit Manipulation",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships.",
      "lists": [
          "neetcode-150"
      ],
      "category": "Bit Manipulation",
      "patternExplanations": {
          "Bit Manipulation": "XOR gives sum without carry. AND + left shift gives carry. Repeat until no carry."
      },
      "hints": [
          "How does addition work in binary? Sum bit and carry bit.",
          "XOR (a ^ b) gives the sum without carry. AND (a & b) gives positions that need carry.",
          "Carry needs to be shifted left. Repeat: sum = a ^ b, carry = (a & b) << 1, until carry is 0."
      ],
      "solution": {
          "approach": "Loop: sum = a XOR b, carry = (a AND b) << 1. Set a = sum, b = carry. Stop when b = 0.",
          "timeComplexity": "O(1) - bounded by bit width",
          "spaceComplexity": "O(1)",
          "keyInsight": "Addition = sum without carry + carry propagation. Iterate until no more carries."
      }
  },
  372: {
      "title": "Super Pow",
      "slug": "super-pow",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  373: {
      "title": "Find K Pairs with Smallest Sums",
      "slug": "find-k-pairs-with-smallest-sums",
      "difficulty": "medium",
      "primaryPattern": "Heap/Priority Queue",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Maintain ordered access to min/max elements. Useful for k-largest/smallest, merging, or scheduling problems."
  },
  374: {
      "title": "Guess Number Higher or Lower",
      "slug": "guess-number-higher-or-lower",
      "difficulty": "easy",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element.",
      "lists": [
          "leetcode-75"
      ],
      "category": "Binary Search",
      "patternExplanations": {
          "Binary Search": "Classic binary search. Call guess(mid) to determine which half to search."
      },
      "hints": [
          "You're finding a number from 1 to n. Standard binary search.",
          "guess(num) returns -1 (too high), 1 (too low), or 0 (correct).",
          "Binary search: if guess(mid) < 0, search lower half. If > 0, search upper half."
      ],
      "solution": {
          "approach": "Binary search [1, n]. Check guess(mid). Adjust search range accordingly.",
          "timeComplexity": "O(log n)",
          "spaceComplexity": "O(1)",
          "keyInsight": "Pure binary search with API-provided comparison function."
      }
  },
  375: {
      "title": "Guess Number Higher or Lower II",
      "slug": "guess-number-higher-or-lower-ii",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  376: {
      "title": "Wiggle Subsequence",
      "slug": "wiggle-subsequence",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  377: {
      "title": "Combination Sum IV",
      "slug": "combination-sum-iv",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  378: {
      "title": "Kth Smallest Element in a Sorted Matrix",
      "slug": "kth-smallest-element-in-a-sorted-matrix",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers",
          "Heap/Priority Queue",
          "DFS"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  380: {
      "title": "Insert Delete GetRandom O(1)",
      "slug": "insert-delete-getrandom-o1",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  381: {
      "title": "Insert Delete GetRandom O(1) - Duplicates allowed",
      "slug": "insert-delete-getrandom-o1-duplicates-allowed",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  382: {
      "title": "Linked List Random Node",
      "slug": "linked-list-random-node",
      "difficulty": "medium",
      "primaryPattern": "Linked List",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Pointer manipulation for reversing, merging, detecting cycles, or finding intersections in linked structures."
  },
  383: {
      "title": "Ransom Note",
      "slug": "ransom-note",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  384: {
      "title": "Shuffle an Array",
      "slug": "shuffle-an-array",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  385: {
      "title": "Mini Parser",
      "slug": "mini-parser",
      "difficulty": "medium",
      "primaryPattern": "Stack",
      "acceptablePatterns": [
          "Hash Map",
          "DFS"
      ],
      "explanation": "LIFO structure for nested patterns, matching pairs, or maintaining monotonic sequences."
  },
  386: {
      "title": "Lexicographical Numbers",
      "slug": "lexicographical-numbers",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Trie"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  387: {
      "title": "First Unique Character in a String",
      "slug": "first-unique-character-in-a-string",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "BFS"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  388: {
      "title": "Longest Absolute File Path",
      "slug": "longest-absolute-file-path",
      "difficulty": "medium",
      "primaryPattern": "Stack",
      "acceptablePatterns": [
          "Hash Map",
          "DFS"
      ],
      "explanation": "LIFO structure for nested patterns, matching pairs, or maintaining monotonic sequences."
  },
  389: {
      "title": "Find the Difference",
      "slug": "find-the-difference",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  390: {
      "title": "Elimination Game",
      "slug": "elimination-game",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  391: {
      "title": "Perfect Rectangle",
      "slug": "perfect-rectangle",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  392: {
      "title": "Is Subsequence",
      "slug": "is-subsequence",
      "difficulty": "easy",
      "lists": [
          "leetcode-75"
      ],
      "category": "Two Pointers",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [],
      "patternExplanations": {
          "Two Pointers": "One pointer on s, one on t. When characters match, advance s pointer. Always advance t pointer. s is subsequence if s pointer reaches end."
      },
      "hints": [
          "Is s a subsequence of t? Characters of s must appear in t in order (not necessarily consecutive).",
          "Scan through t. Whenever you match the current character of s, move to next character of s.",
          "If you match all characters of s before t ends, it's a subsequence."
      ],
      "solution": {
          "approach": "i = 0 (for s). For each char in t: if char == s[i], i++. Return i == len(s).",
          "timeComplexity": "O(n) where n = len(t)",
          "spaceComplexity": "O(1)",
          "keyInsight": "Greedy matching: match s characters as early as possible in t."
      }
  },
  393: {
      "title": "UTF-8 Validation",
      "slug": "utf-8-validation",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  394: {
      "title": "Decode String",
      "slug": "decode-string",
      "difficulty": "medium",
      "lists": [
          "leetcode-75"
      ],
      "category": "Stack",
      "primaryPattern": "Stack",
      "acceptablePatterns": [],
      "patternExplanations": {
          "Stack": "Push current string and count on '['. On ']', pop and repeat current string count times, append to previous string."
      },
      "hints": [
          "3[a2[c]] = accaccacc. Handle nested brackets.",
          "Stack handles nesting. On '[', save current state and start fresh. On ']', restore and combine.",
          "Push (currentString, repeatCount) on '['. Pop on ']' and build result."
      ],
      "solution": {
          "approach": "Stack of (string, count). On '[': push current, reset. On ']': pop, repeat current string, append to popped string.",
          "timeComplexity": "O(n * maxRepeat)",
          "spaceComplexity": "O(n)",
          "keyInsight": "Stack saves context for nested structures. Each ']' closes the innermost pending '['."
      }
  },
  395: {
      "title": "Longest Substring with At Least K Repeating Characters",
      "slug": "longest-substring-with-at-least-k-repeating-characters",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Binary Search",
          "Sliding Window"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  396: {
      "title": "Rotate Function",
      "slug": "rotate-function",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  397: {
      "title": "Integer Replacement",
      "slug": "integer-replacement",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Greedy",
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  398: {
      "title": "Random Pick Index",
      "slug": "random-pick-index",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  399: {
      "title": "Evaluate Division",
      "slug": "evaluate-division",
      "difficulty": "medium",
      "lists": [
          "leetcode-75"
      ],
      "category": "Graphs - DFS",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "BFS",
          "Union Find"
      ],
      "patternExplanations": {
          "DFS": "Build graph: a/b=v means edge a->b with weight v and b->a with weight 1/v. Query = find path and multiply weights.",
          "BFS": "Same path finding with BFS.",
          "Union Find": "Union with weights, track ratios to root."
      },
      "hints": [
          "a/b = 2 means path from a to b with value 2. c/d query = find path a to c, multiply edge weights.",
          "Build weighted directed graph. a/b = v creates a->b (weight v) and b->a (weight 1/v).",
          "DFS from query source to target, multiplying edge weights along path."
      ],
      "solution": {
          "approach": "Build bidirectional weighted graph. For each query, DFS/BFS from source to target, multiply weights.",
          "timeComplexity": "O(q * (v + e))",
          "spaceComplexity": "O(v + e)",
          "keyInsight": "Division relationships form a weighted graph where path product gives answer."
      }
  },
  400: {
      "title": "Nth Digit",
      "slug": "nth-digit",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  401: {
      "title": "Binary Watch",
      "slug": "binary-watch",
      "difficulty": "easy",
      "primaryPattern": "Backtracking",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Explore all possible solutions recursively. Build candidates incrementally and abandon paths that cannot lead to solution."
  },
  402: {
      "title": "Remove K Digits",
      "slug": "remove-k-digits",
      "difficulty": "medium",
      "primaryPattern": "Stack",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy"
      ],
      "explanation": "LIFO structure for nested patterns, matching pairs, or maintaining monotonic sequences."
  },
  403: {
      "title": "Frog Jump",
      "slug": "frog-jump",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  404: {
      "title": "Sum of Left Leaves",
      "slug": "sum-of-left-leaves",
      "difficulty": "easy",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Tree Traversal",
          "BFS"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  405: {
      "title": "Convert a Number to Hexadecimal",
      "slug": "convert-a-number-to-hexadecimal",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  406: {
      "title": "Queue Reconstruction by Height",
      "slug": "queue-reconstruction-by-height",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  407: {
      "title": "Trapping Rain Water II",
      "slug": "trapping-rain-water-ii",
      "difficulty": "hard",
      "primaryPattern": "BFS",
      "acceptablePatterns": [
          "Hash Map",
          "Heap/Priority Queue",
          "DFS"
      ],
      "explanation": "Breadth-first search - explore level by level using a queue. Ideal for shortest path in unweighted graphs or level-order traversal."
  },
  409: {
      "title": "Longest Palindrome",
      "slug": "longest-palindrome",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Greedy"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  410: {
      "title": "Split Array Largest Sum",
      "slug": "split-array-largest-sum",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Dynamic Programming",
          "Greedy"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  412: {
      "title": "Fizz Buzz",
      "slug": "fizz-buzz",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  413: {
      "title": "Arithmetic Slices",
      "slug": "arithmetic-slices",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Sliding Window"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  414: {
      "title": "Third Maximum Number",
      "slug": "third-maximum-number",
      "difficulty": "easy",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  415: {
      "title": "Add Strings",
      "slug": "add-strings",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  416: {
      "title": "Partition Equal Subset Sum",
      "slug": "partition-equal-subset-sum",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization.",
      "lists": [
          "neetcode-150"
      ],
      "category": "Dynamic Programming",
      "patternExplanations": {
          "Dynamic Programming": "0/1 knapsack. dp[j] = can we make sum j? Target is totalSum/2."
      },
      "hints": [
          "If we can find a subset with sum = totalSum/2, the other subset also sums to totalSum/2.",
          "This is the subset sum problem: can we select elements summing to target?",
          "dp[j] = true if sum j is achievable. For each num, update dp[j] |= dp[j-num] (iterate j backwards)."
      ],
      "solution": {
          "approach": "If sum is odd, return false. Target = sum/2. dp[j] = can reach sum j. For each num, update dp backwards.",
          "timeComplexity": "O(n * sum)",
          "spaceComplexity": "O(sum)",
          "keyInsight": "Partition = find subset with sum = total/2. Classic subset sum DP."
      }
  },
  417: {
      "title": "Pacific Atlantic Water Flow",
      "slug": "pacific-atlantic-water-flow",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "BFS"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation.",
      "lists": [
          "neetcode-150"
      ],
      "category": "Graphs",
      "patternExplanations": {
          "DFS": "DFS from Pacific border and Atlantic border separately. Find cells reachable from both.",
          "BFS": "BFS from ocean borders. Water flows uphill in reverse - visit higher or equal neighbors."
      },
      "hints": [
          "Instead of checking where water can flow from each cell, think in reverse.",
          "From which cells can water reach the Pacific? Atlantic?",
          "DFS/BFS from ocean borders going 'uphill'. Find intersection of cells reachable from both."
      ],
      "solution": {
          "approach": "DFS from Pacific border cells, mark reachable. DFS from Atlantic, mark reachable. Return intersection.",
          "timeComplexity": "O(m * n)",
          "spaceComplexity": "O(m * n)",
          "keyInsight": "Reverse the flow: start from oceans, go uphill. Intersection reaches both."
      }
  },
  419: {
      "title": "Battleships in a Board",
      "slug": "battleships-in-a-board",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  420: {
      "title": "Strong Password Checker",
      "slug": "strong-password-checker",
      "difficulty": "hard",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Heap/Priority Queue"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  421: {
      "title": "Maximum XOR of Two Numbers in an Array",
      "slug": "maximum-xor-of-two-numbers-in-an-array",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Trie"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  423: {
      "title": "Reconstruct Original Digits from English",
      "slug": "reconstruct-original-digits-from-english",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  424: {
      "title": "Longest Repeating Character Replacement",
      "slug": "longest-repeating-character-replacement",
      "difficulty": "medium",
      "lists": [
          "neetcode-150"
      ],
      "category": "Sliding Window",
      "primaryPattern": "Sliding Window",
      "acceptablePatterns": [],
      "patternExplanations": {
          "Sliding Window": "Window is valid if (window length - most frequent char count) <= k. Expand right, shrink left if invalid."
      },
      "hints": [
          "In any window, you want to keep the most frequent character and replace the rest.",
          "If window has length L and most frequent char appears M times, you need L-M replacements.",
          "Window is valid if L - M <= k. Expand right, track char counts, shrink left if invalid."
      ],
      "solution": {
          "approach": "Sliding window. Track char frequencies in window. Valid if windowLen - maxFreq <= k.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1) - only 26 letters",
          "keyInsight": "Replacements needed = window size - count of most frequent character in window."
      }
  },
  427: {
      "title": "Construct Quad Tree",
      "slug": "construct-quad-tree",
      "difficulty": "medium",
      "primaryPattern": "Tree Traversal",
      "acceptablePatterns": [
          "Hash Map",
          "Binary Search",
          "DFS"
      ],
      "explanation": "Navigate tree structures using inorder, preorder, or postorder traversal. Consider recursive or iterative approaches."
  },
  429: {
      "title": "N-ary Tree Level Order Traversal",
      "slug": "n-ary-tree-level-order-traversal",
      "difficulty": "medium",
      "primaryPattern": "BFS",
      "acceptablePatterns": [
          "Tree Traversal"
      ],
      "explanation": "Breadth-first search - explore level by level using a queue. Ideal for shortest path in unweighted graphs or level-order traversal."
  },
  430: {
      "title": "Flatten a Multilevel Doubly Linked List",
      "slug": "flatten-a-multilevel-doubly-linked-list",
      "difficulty": "medium",
      "primaryPattern": "Linked List",
      "acceptablePatterns": [
          "DFS"
      ],
      "explanation": "Pointer manipulation for reversing, merging, detecting cycles, or finding intersections in linked structures."
  },
  432: {
      "title": "All O`one Data Structure",
      "slug": "all-oone-data-structure",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Linked List"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  433: {
      "title": "Minimum Genetic Mutation",
      "slug": "minimum-genetic-mutation",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "BFS"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  434: {
      "title": "Number of Segments in a String",
      "slug": "number-of-segments-in-a-string",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  435: {
      "title": "Non-overlapping Intervals",
      "slug": "non-overlapping-intervals",
      "difficulty": "medium",
      "lists": [
          "neetcode-150",
          "leetcode-75"
      ],
      "category": "Intervals",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Sorting"
      ],
      "patternExplanations": {
          "Greedy": "Sort by end time. Greedily keep intervals that don't overlap with last kept. This maximizes kept intervals.",
          "Sorting": "Equivalent: sort by end, count intervals that fit. Remove = total - kept."
      },
      "hints": [
          "Minimum removals = total - maximum non-overlapping intervals you can keep.",
          "Which intervals should you prefer to keep? Ones that end early leave more room.",
          "Sort by end time. Keep interval if it starts after previous kept interval ends."
      ],
      "solution": {
          "approach": "Sort by end time. Track end of last kept interval. If current starts >= end, keep it and update end.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "keyInsight": "Greedy by earliest end time maximizes the number of non-overlapping intervals."
      }
  },
  436: {
      "title": "Find Right Interval",
      "slug": "find-right-interval",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  437: {
      "title": "Path Sum III",
      "slug": "path-sum-iii",
      "difficulty": "medium",
      "lists": [
          "leetcode-75"
      ],
      "category": "Binary Tree - DFS",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map",
          "Prefix Sum"
      ],
      "patternExplanations": {
          "DFS": "Use prefix sum with hash map. Track cumulative sum. If currSum - targetSum exists in map, those are valid paths.",
          "Hash Map": "Map stores prefix sums seen on current path. currSum - target in map = path ending at current node.",
          "Prefix Sum": "Path sum from A to B = prefixSum(B) - prefixSum(A). Find where prefixSum(A) = currSum - target."
      },
      "hints": [
          "Path can start/end anywhere (but must go downward). Count all paths summing to target.",
          "Brute force: from each node, try all downward paths. O(n^2).",
          "Optimal: prefix sum + map. If currSum - target seen before, that many paths end here."
      ],
      "solution": {
          "approach": "DFS with prefix sum map. Add currSum to map going down, remove going back up (backtrack).",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)",
          "keyInsight": "Prefix sum technique adapted for trees. Map tracks sums on current root-to-node path."
      }
  },
  438: {
      "title": "Find All Anagrams in a String",
      "slug": "find-all-anagrams-in-a-string",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Sliding Window"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  440: {
      "title": "K-th Smallest in Lexicographical Order",
      "slug": "k-th-smallest-in-lexicographical-order",
      "difficulty": "hard",
      "primaryPattern": "Trie",
      "acceptablePatterns": [],
      "explanation": "Prefix tree for efficient string operations. Each node represents a character, paths represent strings."
  },
  441: {
      "title": "Arranging Coins",
      "slug": "arranging-coins",
      "difficulty": "easy",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  442: {
      "title": "Find All Duplicates in an Array",
      "slug": "find-all-duplicates-in-an-array",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  443: {
      "title": "String Compression",
      "slug": "string-compression",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds.",
      "lists": [
          "leetcode-75"
      ],
      "category": "Two Pointers",
      "patternExplanations": {
          "Two Pointers": "Read pointer scans, write pointer builds compressed result in-place."
      },
      "hints": [
          "Count consecutive characters. Write char and count (if > 1).",
          "Use two pointers: one for reading, one for writing.",
          "Be careful with multi-digit counts: '12' needs two characters."
      ],
      "solution": {
          "approach": "Read pointer counts consecutive chars. Write pointer writes char + count. Handle multi-digit counts.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "keyInsight": "In-place with read/write pointers. Write is always behind or at read, so no overwrite issues."
      }
  },
  445: {
      "title": "Add Two Numbers II",
      "slug": "add-two-numbers-ii",
      "difficulty": "medium",
      "primaryPattern": "Linked List",
      "acceptablePatterns": [
          "Hash Map",
          "Stack"
      ],
      "explanation": "Pointer manipulation for reversing, merging, detecting cycles, or finding intersections in linked structures."
  },
  446: {
      "title": "Arithmetic Slices II - Subsequence",
      "slug": "arithmetic-slices-ii-subsequence",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  447: {
      "title": "Number of Boomerangs",
      "slug": "number-of-boomerangs",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  448: {
      "title": "Find All Numbers Disappeared in an Array",
      "slug": "find-all-numbers-disappeared-in-an-array",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  449: {
      "title": "Serialize and Deserialize BST",
      "slug": "serialize-and-deserialize-bst",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map",
          "Tree Traversal",
          "BFS"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  450: {
      "title": "Delete Node in a BST",
      "slug": "delete-node-in-a-bst",
      "difficulty": "medium",
      "lists": [
          "leetcode-75"
      ],
      "category": "Binary Search Tree",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Binary Search"
      ],
      "patternExplanations": {
          "DFS": "Find node, then handle 3 cases: no children (remove), one child (replace with child), two children (replace with successor).",
          "Binary Search": "BST search to find node, then restructure."
      },
      "hints": [
          "First, find the node to delete using BST property.",
          "If leaf, just remove. If one child, replace with child. If two children?",
          "Two children: find inorder successor (smallest in right subtree), swap values, delete successor."
      ],
      "solution": {
          "approach": "Find node. If two children: find successor, copy value, recursively delete successor. Else: return non-null child.",
          "timeComplexity": "O(h)",
          "spaceComplexity": "O(h)",
          "keyInsight": "Two-child case: inorder successor has at most one child, making it easier to delete."
      }
  },
  451: {
      "title": "Sort Characters By Frequency",
      "slug": "sort-characters-by-frequency",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Two Pointers",
          "Heap/Priority Queue"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  452: {
      "title": "Minimum Number of Arrows to Burst Balloons",
      "slug": "minimum-number-of-arrows-to-burst-balloons",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum.",
      "lists": [
          "leetcode-75"
      ],
      "category": "Intervals",
      "patternExplanations": {
          "Greedy": "Sort by end point. Shoot at first end. Skip balloons hit by this shot."
      },
      "hints": [
          "Each arrow bursts all overlapping balloons at that x-coordinate.",
          "Sort by end position. Shoot at the end of the first balloon.",
          "This shot hits all balloons starting before this end. Move to next unhit balloon."
      ],
      "solution": {
          "approach": "Sort by end. Shoot at first balloon's end. Skip all overlapping. Repeat for remaining.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "keyInsight": "Greedy: shoot as late as possible (at end) to hit maximum overlapping balloons."
      }
  },
  453: {
      "title": "Minimum Moves to Equal Array Elements",
      "slug": "minimum-moves-to-equal-array-elements",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  454: {
      "title": "4Sum II",
      "slug": "4sum-ii",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  455: {
      "title": "Assign Cookies",
      "slug": "assign-cookies",
      "difficulty": "easy",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  456: {
      "title": "132 Pattern",
      "slug": "132-pattern",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Stack"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  457: {
      "title": "Circular Array Loop",
      "slug": "circular-array-loop",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  458: {
      "title": "Poor Pigs",
      "slug": "poor-pigs",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  459: {
      "title": "Repeated Substring Pattern",
      "slug": "repeated-substring-pattern",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  460: {
      "title": "LFU Cache",
      "slug": "lfu-cache",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Linked List"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  461: {
      "title": "Hamming Distance",
      "slug": "hamming-distance",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  462: {
      "title": "Minimum Moves to Equal Array Elements II",
      "slug": "minimum-moves-to-equal-array-elements-ii",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  463: {
      "title": "Island Perimeter",
      "slug": "island-perimeter",
      "difficulty": "easy",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map",
          "BFS"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  464: {
      "title": "Can I Win",
      "slug": "can-i-win",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  466: {
      "title": "Count The Repetitions",
      "slug": "count-the-repetitions",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  467: {
      "title": "Unique Substrings in Wraparound String",
      "slug": "unique-substrings-in-wraparound-string",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  468: {
      "title": "Validate IP Address",
      "slug": "validate-ip-address",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  470: {
      "title": "Implement Rand10() Using Rand7()",
      "slug": "implement-rand10-using-rand7",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  472: {
      "title": "Concatenated Words",
      "slug": "concatenated-words",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "DFS",
          "Trie",
          "Two Pointers"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  473: {
      "title": "Matchsticks to Square",
      "slug": "matchsticks-to-square",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Backtracking"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  474: {
      "title": "Ones and Zeroes",
      "slug": "ones-and-zeroes",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  475: {
      "title": "Heaters",
      "slug": "heaters",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map",
          "Binary Search"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  476: {
      "title": "Number Complement",
      "slug": "number-complement",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  477: {
      "title": "Total Hamming Distance",
      "slug": "total-hamming-distance",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  478: {
      "title": "Generate Random Point in a Circle",
      "slug": "generate-random-point-in-a-circle",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  479: {
      "title": "Largest Palindrome Product",
      "slug": "largest-palindrome-product",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  480: {
      "title": "Sliding Window Median",
      "slug": "sliding-window-median",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Sliding Window",
          "Heap/Priority Queue"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  481: {
      "title": "Magical String",
      "slug": "magical-string",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  482: {
      "title": "License Key Formatting",
      "slug": "license-key-formatting",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  483: {
      "title": "Smallest Good Base",
      "slug": "smallest-good-base",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  485: {
      "title": "Max Consecutive Ones",
      "slug": "max-consecutive-ones",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  486: {
      "title": "Predict the Winner",
      "slug": "predict-the-winner",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "DFS"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  488: {
      "title": "Zuma Game",
      "slug": "zuma-game",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Stack",
          "BFS"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  491: {
      "title": "Non-decreasing Subsequences",
      "slug": "non-decreasing-subsequences",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Backtracking"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  492: {
      "title": "Construct the Rectangle",
      "slug": "construct-the-rectangle",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  493: {
      "title": "Reverse Pairs",
      "slug": "reverse-pairs",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  494: {
      "title": "Target Sum",
      "slug": "target-sum",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization.",
      "lists": [
          "neetcode-150"
      ],
      "category": "Dynamic Programming",
      "patternExplanations": {
          "Dynamic Programming": "dp[sum] = ways to reach sum. For each num, can add or subtract it."
      },
      "hints": [
          "Each number can be + or -. We want ways to reach target sum.",
          "Let P = positive numbers sum, N = negative. P - N = target, P + N = total. So P = (target + total)/2.",
          "Convert to: find subsets summing to (target + total)/2. That's subset sum count."
      ],
      "solution": {
          "approach": "Reframe: count subsets summing to (target + total)/2. dp[j] = ways to reach sum j.",
          "timeComplexity": "O(n * sum)",
          "spaceComplexity": "O(sum)",
          "keyInsight": "Transform to subset sum by algebra: positive subset sum = (target + total) / 2."
      }
  },
  495: {
      "title": "Teemo Attacking",
      "slug": "teemo-attacking",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  496: {
      "title": "Next Greater Element I",
      "slug": "next-greater-element-i",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Stack"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  497: {
      "title": "Random Point in Non-overlapping Rectangles",
      "slug": "random-point-in-non-overlapping-rectangles",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  498: {
      "title": "Diagonal Traverse",
      "slug": "diagonal-traverse",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  500: {
      "title": "Keyboard Row",
      "slug": "keyboard-row",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  501: {
      "title": "Find Mode in Binary Search Tree",
      "slug": "find-mode-in-binary-search-tree",
      "difficulty": "easy",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Tree Traversal"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  502: {
      "title": "IPO",
      "slug": "ipo",
      "difficulty": "hard",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers",
          "Heap/Priority Queue"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  503: {
      "title": "Next Greater Element II",
      "slug": "next-greater-element-ii",
      "difficulty": "medium",
      "primaryPattern": "Stack",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "LIFO structure for nested patterns, matching pairs, or maintaining monotonic sequences."
  },
  504: {
      "title": "Base 7",
      "slug": "base-7",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  506: {
      "title": "Relative Ranks",
      "slug": "relative-ranks",
      "difficulty": "easy",
      "primaryPattern": "Heap/Priority Queue",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Maintain ordered access to min/max elements. Useful for k-largest/smallest, merging, or scheduling problems."
  },
  507: {
      "title": "Perfect Number",
      "slug": "perfect-number",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  508: {
      "title": "Most Frequent Subtree Sum",
      "slug": "most-frequent-subtree-sum",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Tree Traversal",
          "DFS"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  509: {
      "title": "Fibonacci Number",
      "slug": "fibonacci-number",
      "difficulty": "easy",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "DFS"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  511: {
      "title": "Game Play Analysis I",
      "slug": "game-play-analysis-i",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  513: {
      "title": "Find Bottom Left Tree Value",
      "slug": "find-bottom-left-tree-value",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Tree Traversal",
          "BFS"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  514: {
      "title": "Freedom Trail",
      "slug": "freedom-trail",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "DFS",
          "BFS"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  515: {
      "title": "Find Largest Value in Each Tree Row",
      "slug": "find-largest-value-in-each-tree-row",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Tree Traversal",
          "BFS"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  516: {
      "title": "Longest Palindromic Subsequence",
      "slug": "longest-palindromic-subsequence",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  517: {
      "title": "Super Washing Machines",
      "slug": "super-washing-machines",
      "difficulty": "hard",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  518: {
      "title": "Coin Change II",
      "slug": "coin-change-ii",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization.",
      "lists": [
          "neetcode-150"
      ],
      "category": "Dynamic Programming",
      "patternExplanations": {
          "Dynamic Programming": "dp[j] = ways to make amount j. For each coin, dp[j] += dp[j-coin]. Process coins outer loop."
      },
      "hints": [
          "Unlike Coin Change I (min coins), count combinations (not permutations).",
          "To avoid counting [1,2] and [2,1] as different, process coins in outer loop.",
          "dp[j] = ways to make j. For each coin (outer), for each amount (inner), dp[j] += dp[j-coin]."
      ],
      "solution": {
          "approach": "dp[j] = ways to make j. Outer loop on coins, inner on amounts. dp[j] += dp[j-coin].",
          "timeComplexity": "O(amount * coins)",
          "spaceComplexity": "O(amount)",
          "keyInsight": "Coin-first loop prevents counting permutations. Each combination counted once."
      }
  },
  519: {
      "title": "Random Flip Matrix",
      "slug": "random-flip-matrix",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  520: {
      "title": "Detect Capital",
      "slug": "detect-capital",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  521: {
      "title": "Longest Uncommon Subsequence I",
      "slug": "longest-uncommon-subsequence-i",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  522: {
      "title": "Longest Uncommon Subsequence II",
      "slug": "longest-uncommon-subsequence-ii",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  523: {
      "title": "Continuous Subarray Sum",
      "slug": "continuous-subarray-sum",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  524: {
      "title": "Longest Word in Dictionary through Deleting",
      "slug": "longest-word-in-dictionary-through-deleting",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  525: {
      "title": "Contiguous Array",
      "slug": "contiguous-array",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  526: {
      "title": "Beautiful Arrangement",
      "slug": "beautiful-arrangement",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Backtracking"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  528: {
      "title": "Random Pick with Weight",
      "slug": "random-pick-with-weight",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  529: {
      "title": "Minesweeper",
      "slug": "minesweeper",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map",
          "BFS"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  530: {
      "title": "Minimum Absolute Difference in BST",
      "slug": "minimum-absolute-difference-in-bst",
      "difficulty": "easy",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Tree Traversal",
          "BFS"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  532: {
      "title": "K-diff Pairs in an Array",
      "slug": "k-diff-pairs-in-an-array",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Two Pointers",
          "Binary Search"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  535: {
      "title": "Encode and Decode TinyURL",
      "slug": "encode-and-decode-tinyurl",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  537: {
      "title": "Complex Number Multiplication",
      "slug": "complex-number-multiplication",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  538: {
      "title": "Convert BST to Greater Tree",
      "slug": "convert-bst-to-greater-tree",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Tree Traversal"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  539: {
      "title": "Minimum Time Difference",
      "slug": "minimum-time-difference",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  540: {
      "title": "Single Element in a Sorted Array",
      "slug": "single-element-in-a-sorted-array",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  541: {
      "title": "Reverse String II",
      "slug": "reverse-string-ii",
      "difficulty": "easy",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  542: {
      "title": "01 Matrix",
      "slug": "01-matrix",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "BFS",
          "DFS"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  543: {
      "title": "Diameter of Binary Tree",
      "slug": "diameter-of-binary-tree",
      "difficulty": "easy",
      "primaryPattern": "DFS",
      "acceptablePatterns": [],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation.",
      "lists": [
          "neetcode-150"
      ],
      "category": "Trees",
      "patternExplanations": {
          "DFS": "For each node, diameter through it = left height + right height. Track global max."
      },
      "hints": [
          "Diameter is longest path between any two nodes. It may or may not pass through root.",
          "At each node, longest path through it = left depth + right depth.",
          "DFS to compute depth. At each node, update max diameter. Return depth for parent."
      ],
      "solution": {
          "approach": "DFS returns depth. At each node, update global max with leftDepth + rightDepth. Return max(left, right) + 1.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(h)",
          "keyInsight": "Compute depth, but track diameter as a side effect. Diameter through node = sum of child depths."
      }
  },
  546: {
      "title": "Remove Boxes",
      "slug": "remove-boxes",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  547: {
      "title": "Number of Provinces",
      "slug": "number-of-provinces",
      "difficulty": "medium",
      "lists": [
          "leetcode-75"
      ],
      "category": "Graphs - DFS",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "BFS",
          "Union Find"
      ],
      "patternExplanations": {
          "DFS": "Count connected components. For each unvisited city, DFS to mark all connected cities. Count = number of DFS starts.",
          "BFS": "Same component counting with BFS instead.",
          "Union Find": "Union directly connected cities. Count unique roots."
      },
      "hints": [
          "Province = connected component. Count separate groups of connected cities.",
          "Adjacency matrix given. Traverse and count connected components.",
          "For each unvisited city, start DFS/BFS to mark its component. Count starts."
      ],
      "solution": {
          "approach": "For each city 0 to n-1: if not visited, DFS to mark component, increment count.",
          "timeComplexity": "O(n^2)",
          "spaceComplexity": "O(n)",
          "keyInsight": "Classic connected components problem - count DFS/BFS initiations."
      }
  },
  550: {
      "title": "Game Play Analysis IV",
      "slug": "game-play-analysis-iv",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  551: {
      "title": "Student Attendance Record I",
      "slug": "student-attendance-record-i",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  552: {
      "title": "Student Attendance Record II",
      "slug": "student-attendance-record-ii",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  553: {
      "title": "Optimal Division",
      "slug": "optimal-division",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  554: {
      "title": "Brick Wall",
      "slug": "brick-wall",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  556: {
      "title": "Next Greater Element III",
      "slug": "next-greater-element-iii",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  557: {
      "title": "Reverse Words in a String III",
      "slug": "reverse-words-in-a-string-iii",
      "difficulty": "easy",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  558: {
      "title": "Logical OR of Two Binary Grids Represented as Quad-Trees",
      "slug": "logical-or-of-two-binary-grids-represented-as-quad-trees",
      "difficulty": "medium",
      "primaryPattern": "Tree Traversal",
      "acceptablePatterns": [
          "Binary Search"
      ],
      "explanation": "Navigate tree structures using inorder, preorder, or postorder traversal. Consider recursive or iterative approaches."
  },
  559: {
      "title": "Maximum Depth of N-ary Tree",
      "slug": "maximum-depth-of-n-ary-tree",
      "difficulty": "easy",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Tree Traversal",
          "BFS"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  560: {
      "title": "Subarray Sum Equals K",
      "slug": "subarray-sum-equals-k",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  561: {
      "title": "Array Partition",
      "slug": "array-partition",
      "difficulty": "easy",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  563: {
      "title": "Binary Tree Tilt",
      "slug": "binary-tree-tilt",
      "difficulty": "easy",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Tree Traversal"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  564: {
      "title": "Find the Closest Palindrome",
      "slug": "find-the-closest-palindrome",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  565: {
      "title": "Array Nesting",
      "slug": "array-nesting",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  566: {
      "title": "Reshape the Matrix",
      "slug": "reshape-the-matrix",
      "difficulty": "easy",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  567: {
      "title": "Permutation in String",
      "slug": "permutation-in-string",
      "difficulty": "medium",
      "primaryPattern": "Sliding Window",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships.",
      "lists": [
          "neetcode-150"
      ],
      "category": "Sliding Window",
      "patternExplanations": {
          "Sliding Window": "Fixed window of s1's length. Slide through s2, checking if window has same char counts as s1.",
          "Hash Map": "Use frequency maps. Maintain window counts, check if matches s1's counts."
      },
      "hints": [
          "A permutation has the same characters with same frequencies.",
          "Use a sliding window of size len(s1). Check if window's char counts match s1's.",
          "Optimize: track how many chars have matching counts. Window is valid when all 26 match."
      ],
      "solution": {
          "approach": "Count s1 chars. Slide window of same size over s2. Add right char, remove left char. Check if counts match.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1) - fixed 26 chars",
          "keyInsight": "Fixed-size sliding window. Only need to check character frequencies match."
      }
  },
  570: {
      "title": "Managers with at Least 5 Direct Reports",
      "slug": "managers-with-at-least-5-direct-reports",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  572: {
      "title": "Subtree of Another Tree",
      "slug": "subtree-of-another-tree",
      "difficulty": "easy",
      "lists": [
          "neetcode-150"
      ],
      "category": "Trees",
      "primaryPattern": "DFS",
      "acceptablePatterns": [],
      "patternExplanations": {
          "DFS": "For each node in main tree, check if subtree rooted there equals the target tree. Uses isSameTree as helper."
      },
      "hints": [
          "A subtree match means: some node in the main tree is the root of a tree identical to subRoot.",
          "For each node in main tree, check: is the tree rooted here identical to subRoot?",
          "Reuse 'same tree' logic. Check current node, or recurse to check left and right subtrees."
      ],
      "solution": {
          "approach": "isSubtree(root, sub) = isSameTree(root, sub) OR isSubtree(root.left, sub) OR isSubtree(root.right, sub).",
          "timeComplexity": "O(m * n)",
          "spaceComplexity": "O(h)",
          "keyInsight": "Subtree check = check every node as potential match using same-tree comparison."
      }
  },
  575: {
      "title": "Distribute Candies",
      "slug": "distribute-candies",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  576: {
      "title": "Out of Boundary Paths",
      "slug": "out-of-boundary-paths",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  577: {
      "title": "Employee Bonus",
      "slug": "employee-bonus",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  581: {
      "title": "Shortest Unsorted Continuous Subarray",
      "slug": "shortest-unsorted-continuous-subarray",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map",
          "Stack",
          "Greedy"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  583: {
      "title": "Delete Operation for Two Strings",
      "slug": "delete-operation-for-two-strings",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  584: {
      "title": "Find Customer Referee",
      "slug": "find-customer-referee",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  585: {
      "title": "Investments in 2016",
      "slug": "investments-in-2016",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  586: {
      "title": "Customer Placing the Largest Number of Orders",
      "slug": "customer-placing-the-largest-number-of-orders",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  587: {
      "title": "Erect the Fence",
      "slug": "erect-the-fence",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  589: {
      "title": "N-ary Tree Preorder Traversal",
      "slug": "n-ary-tree-preorder-traversal",
      "difficulty": "easy",
      "primaryPattern": "Stack",
      "acceptablePatterns": [
          "Tree Traversal",
          "DFS"
      ],
      "explanation": "LIFO structure for nested patterns, matching pairs, or maintaining monotonic sequences."
  },
  590: {
      "title": "N-ary Tree Postorder Traversal",
      "slug": "n-ary-tree-postorder-traversal",
      "difficulty": "easy",
      "primaryPattern": "Stack",
      "acceptablePatterns": [
          "Tree Traversal",
          "DFS"
      ],
      "explanation": "LIFO structure for nested patterns, matching pairs, or maintaining monotonic sequences."
  },
  591: {
      "title": "Tag Validator",
      "slug": "tag-validator",
      "difficulty": "hard",
      "primaryPattern": "Stack",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "LIFO structure for nested patterns, matching pairs, or maintaining monotonic sequences."
  },
  592: {
      "title": "Fraction Addition and Subtraction",
      "slug": "fraction-addition-and-subtraction",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  593: {
      "title": "Valid Square",
      "slug": "valid-square",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  594: {
      "title": "Longest Harmonious Subsequence",
      "slug": "longest-harmonious-subsequence",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Sliding Window",
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  595: {
      "title": "Big Countries",
      "slug": "big-countries",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  596: {
      "title": "Classes With at Least 5 Students",
      "slug": "classes-with-at-least-5-students",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  598: {
      "title": "Range Addition II",
      "slug": "range-addition-ii",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  599: {
      "title": "Minimum Index Sum of Two Lists",
      "slug": "minimum-index-sum-of-two-lists",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  600: {
      "title": "Non-negative Integers without Consecutive Ones",
      "slug": "non-negative-integers-without-consecutive-ones",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  601: {
      "title": "Human Traffic of Stadium",
      "slug": "human-traffic-of-stadium",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  602: {
      "title": "Friend Requests II: Who Has the Most Friends",
      "slug": "friend-requests-ii-who-has-the-most-friends",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  605: {
      "title": "Can Place Flowers",
      "slug": "can-place-flowers",
      "difficulty": "easy",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum.",
      "lists": [
          "leetcode-75"
      ],
      "category": "Greedy",
      "patternExplanations": {
          "Greedy": "Place flowers greedily at every valid position (both neighbors are 0)."
      },
      "hints": [
          "A flower can be planted if current and both neighbors are 0.",
          "Greedily plant whenever possible. This doesn't block future plantings.",
          "Handle edges: treat out-of-bounds as 0."
      ],
      "solution": {
          "approach": "Iterate through flowerbed. If current and neighbors are 0, plant (set to 1). Count plantings.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "keyInsight": "Greedy works: planting ASAP doesn't prevent future valid plantings."
      }
  },
  606: {
      "title": "Construct String from Binary Tree",
      "slug": "construct-string-from-binary-tree",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map",
          "Tree Traversal"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  607: {
      "title": "Sales Person",
      "slug": "sales-person",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  608: {
      "title": "Tree Node",
      "slug": "tree-node",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  609: {
      "title": "Find Duplicate File in System",
      "slug": "find-duplicate-file-in-system",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  610: {
      "title": "Triangle Judgement",
      "slug": "triangle-judgement",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  611: {
      "title": "Valid Triangle Number",
      "slug": "valid-triangle-number",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map",
          "Binary Search",
          "Greedy"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  617: {
      "title": "Merge Two Binary Trees",
      "slug": "merge-two-binary-trees",
      "difficulty": "easy",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Tree Traversal",
          "BFS"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  619: {
      "title": "Biggest Single Number",
      "slug": "biggest-single-number",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  620: {
      "title": "Not Boring Movies",
      "slug": "not-boring-movies",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  621: {
      "title": "Task Scheduler",
      "slug": "task-scheduler",
      "difficulty": "medium",
      "lists": [
          "neetcode-150"
      ],
      "category": "Heap / Priority Queue",
      "primaryPattern": "Heap/Priority Queue",
      "acceptablePatterns": [
          "Greedy"
      ],
      "patternExplanations": {
          "Heap/Priority Queue": "Max heap of task counts. Each cycle, pick n+1 most frequent tasks (or idle). Update counts, repeat.",
          "Greedy": "Math approach: idle slots = (maxFreq - 1) * n. Fill idle slots with other tasks. Total = tasks + remaining idles."
      },
      "hints": [
          "Same task must have at least n intervals between executions.",
          "Greedy: always do the task with highest remaining count (minimizes idle time).",
          "Or think mathematically: how many idle slots does the most frequent task create?"
      ],
      "solution": {
          "approach": "Max heap simulation or math: idle_slots = (max_count - 1) * n - (sum of other counts). Time = max(len(tasks), calculated).",
          "timeComplexity": "O(n) for math, O(time * log 26) for heap",
          "spaceComplexity": "O(1)",
          "keyInsight": "The most frequent task determines the minimum time. Other tasks fill in the gaps."
      }
  },
  622: {
      "title": "Design Circular Queue",
      "slug": "design-circular-queue",
      "difficulty": "medium",
      "primaryPattern": "Linked List",
      "acceptablePatterns": [
          "Hash Map",
          "BFS"
      ],
      "explanation": "Pointer manipulation for reversing, merging, detecting cycles, or finding intersections in linked structures."
  },
  623: {
      "title": "Add One Row to Tree",
      "slug": "add-one-row-to-tree",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Tree Traversal",
          "BFS"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  624: {
      "title": "Maximum Distance in Arrays",
      "slug": "maximum-distance-in-arrays",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  626: {
      "title": "Exchange Seats",
      "slug": "exchange-seats",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  627: {
      "title": "Swap Sex of Employees",
      "slug": "swap-sex-of-employees",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  628: {
      "title": "Maximum Product of Three Numbers",
      "slug": "maximum-product-of-three-numbers",
      "difficulty": "easy",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  629: {
      "title": "K Inverse Pairs Array",
      "slug": "k-inverse-pairs-array",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  630: {
      "title": "Course Schedule III",
      "slug": "course-schedule-iii",
      "difficulty": "hard",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers",
          "Heap/Priority Queue"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  632: {
      "title": "Smallest Range Covering Elements from K Lists",
      "slug": "smallest-range-covering-elements-from-k-lists",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Greedy",
          "Sliding Window",
          "Two Pointers",
          "Heap/Priority Queue"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  633: {
      "title": "Sum of Square Numbers",
      "slug": "sum-of-square-numbers",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map",
          "Binary Search"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  636: {
      "title": "Exclusive Time of Functions",
      "slug": "exclusive-time-of-functions",
      "difficulty": "medium",
      "primaryPattern": "Stack",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "LIFO structure for nested patterns, matching pairs, or maintaining monotonic sequences."
  },
  637: {
      "title": "Average of Levels in Binary Tree",
      "slug": "average-of-levels-in-binary-tree",
      "difficulty": "easy",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Tree Traversal",
          "BFS"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  638: {
      "title": "Shopping Offers",
      "slug": "shopping-offers",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Backtracking"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  639: {
      "title": "Decode Ways II",
      "slug": "decode-ways-ii",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  640: {
      "title": "Solve the Equation",
      "slug": "solve-the-equation",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  641: {
      "title": "Design Circular Deque",
      "slug": "design-circular-deque",
      "difficulty": "medium",
      "primaryPattern": "Linked List",
      "acceptablePatterns": [
          "Hash Map",
          "BFS"
      ],
      "explanation": "Pointer manipulation for reversing, merging, detecting cycles, or finding intersections in linked structures."
  },
  643: {
      "title": "Maximum Average Subarray I",
      "slug": "maximum-average-subarray-i",
      "difficulty": "easy",
      "lists": [
          "leetcode-75"
      ],
      "category": "Sliding Window",
      "primaryPattern": "Sliding Window",
      "acceptablePatterns": [],
      "patternExplanations": {
          "Sliding Window": "Fixed-size window of k elements. Slide by adding next element and removing first. Track max sum, divide by k at end."
      },
      "hints": [
          "Find contiguous subarray of length k with maximum average.",
          "Compute initial sum of first k elements. Then slide: add next, remove first.",
          "Track max sum. Average = max sum / k."
      ],
      "solution": {
          "approach": "Compute sum of first k. For each i from k to n: sum += nums[i] - nums[i-k]. Track maxSum. Return maxSum/k.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "keyInsight": "Fixed window size = sliding window with constant add/remove."
      }
  },
  645: {
      "title": "Set Mismatch",
      "slug": "set-mismatch",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  646: {
      "title": "Maximum Length of Pair Chain",
      "slug": "maximum-length-of-pair-chain",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy",
          "Two Pointers"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  647: {
      "title": "Palindromic Substrings",
      "slug": "palindromic-substrings",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Dynamic Programming"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds.",
      "lists": [
          "neetcode-150"
      ],
      "category": "Dynamic Programming",
      "patternExplanations": {
          "Two Pointers": "Expand around each center (both odd and even). Count all palindromes found.",
          "Dynamic Programming": "dp[i][j] = true if s[i..j] is palindrome. Count all true entries."
      },
      "hints": [
          "Similar to Longest Palindromic Substring, but count all, not just longest.",
          "Expand around center approach: for each center, count palindromes as you expand.",
          "Each position has potential centers for odd-length and even-length palindromes."
      ],
      "solution": {
          "approach": "For each index, expand around center for both odd and even length. Count each valid expansion.",
          "timeComplexity": "O(n^2)",
          "spaceComplexity": "O(1)",
          "keyInsight": "Each expansion step that succeeds (chars match) is another palindrome."
      }
  },
  648: {
      "title": "Replace Words",
      "slug": "replace-words",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Trie"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  649: {
      "title": "Dota2 Senate",
      "slug": "dota2-senate",
      "difficulty": "medium",
      "lists": [
          "leetcode-75"
      ],
      "category": "Queue",
      "primaryPattern": "Queue",
      "acceptablePatterns": [
          "Greedy"
      ],
      "patternExplanations": {
          "Queue": "Two queues for R and D indices. Each round, smaller index bans larger. Winner rejoins at end with offset.",
          "Greedy": "Each senator bans the next opponent. Simulate with queues."
      },
      "hints": [
          "Each senator can ban one opponent. Optimal: ban the next opponent to vote.",
          "Use two queues: one for R indices, one for D indices.",
          "Compare front of queues. Smaller index wins, bans other. Winner rejoins at position + n."
      ],
      "solution": {
          "approach": "Queues of indices for R and D. While both non-empty: smaller index wins, add winner to back with +n offset.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)",
          "keyInsight": "Greedy banning + queue simulation handles circular voting."
      }
  },
  650: {
      "title": "2 Keys Keyboard",
      "slug": "2-keys-keyboard",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  652: {
      "title": "Find Duplicate Subtrees",
      "slug": "find-duplicate-subtrees",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Tree Traversal",
          "DFS"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  653: {
      "title": "Two Sum IV - Input is a BST",
      "slug": "two-sum-iv-input-is-a-bst",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Two Pointers",
          "Tree Traversal",
          "DFS",
          "BFS"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  654: {
      "title": "Maximum Binary Tree",
      "slug": "maximum-binary-tree",
      "difficulty": "medium",
      "primaryPattern": "Stack",
      "acceptablePatterns": [
          "Hash Map",
          "Binary Search",
          "Tree Traversal"
      ],
      "explanation": "LIFO structure for nested patterns, matching pairs, or maintaining monotonic sequences."
  },
  655: {
      "title": "Print Binary Tree",
      "slug": "print-binary-tree",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Tree Traversal",
          "BFS"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  657: {
      "title": "Robot Return to Origin",
      "slug": "robot-return-to-origin",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  658: {
      "title": "Find K Closest Elements",
      "slug": "find-k-closest-elements",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map",
          "Binary Search",
          "Sliding Window",
          "Heap/Priority Queue"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  659: {
      "title": "Split Array into Consecutive Subsequences",
      "slug": "split-array-into-consecutive-subsequences",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Greedy",
          "Heap/Priority Queue"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  661: {
      "title": "Image Smoother",
      "slug": "image-smoother",
      "difficulty": "easy",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  662: {
      "title": "Maximum Width of Binary Tree",
      "slug": "maximum-width-of-binary-tree",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Tree Traversal",
          "BFS"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  664: {
      "title": "Strange Printer",
      "slug": "strange-printer",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  665: {
      "title": "Non-decreasing Array",
      "slug": "non-decreasing-array",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  667: {
      "title": "Beautiful Arrangement II",
      "slug": "beautiful-arrangement-ii",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  668: {
      "title": "Kth Smallest Number in Multiplication Table",
      "slug": "kth-smallest-number-in-multiplication-table",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  669: {
      "title": "Trim a Binary Search Tree",
      "slug": "trim-a-binary-search-tree",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Tree Traversal"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  670: {
      "title": "Maximum Swap",
      "slug": "maximum-swap",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  671: {
      "title": "Second Minimum Node In a Binary Tree",
      "slug": "second-minimum-node-in-a-binary-tree",
      "difficulty": "easy",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Tree Traversal"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  672: {
      "title": "Bulb Switcher II",
      "slug": "bulb-switcher-ii",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map",
          "BFS"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  673: {
      "title": "Number of Longest Increasing Subsequence",
      "slug": "number-of-longest-increasing-subsequence",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  674: {
      "title": "Longest Continuous Increasing Subsequence",
      "slug": "longest-continuous-increasing-subsequence",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  675: {
      "title": "Cut Off Trees for Golf Event",
      "slug": "cut-off-trees-for-golf-event",
      "difficulty": "hard",
      "primaryPattern": "BFS",
      "acceptablePatterns": [
          "Hash Map",
          "Heap/Priority Queue",
          "DFS"
      ],
      "explanation": "Breadth-first search - explore level by level using a queue. Ideal for shortest path in unweighted graphs or level-order traversal."
  },
  676: {
      "title": "Implement Magic Dictionary",
      "slug": "implement-magic-dictionary",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "DFS",
          "Trie"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  677: {
      "title": "Map Sum Pairs",
      "slug": "map-sum-pairs",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Trie"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  678: {
      "title": "Valid Parenthesis String",
      "slug": "valid-parenthesis-string",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Dynamic Programming"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization.",
      "lists": [
          "neetcode-150"
      ],
      "category": "Greedy",
      "patternExplanations": {
          "Greedy": "Track min and max possible open parens. '*' can be '(', ')', or empty. Check if 0 is achievable.",
          "Dynamic Programming": "Track all possible counts of open parens at each position."
      },
      "hints": [
          "'*' can be '(', ')', or empty. Many possibilities.",
          "Track range of possible open paren counts: [lo, hi].",
          "On '(': both increase. On ')': both decrease. On '*': lo-1 (could be ')'), hi+1 (could be '(')."
      ],
      "solution": {
          "approach": "Track lo (min open) and hi (max open). lo = max(0, lo-1) on ')' or '*'. If hi < 0, invalid. End with lo = 0.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "keyInsight": "Track range of possibilities. If range ever excludes 0, or hi goes negative, invalid."
      }
  },
  679: {
      "title": "24 Game",
      "slug": "24-game",
      "difficulty": "hard",
      "primaryPattern": "Backtracking",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Explore all possible solutions recursively. Build candidates incrementally and abandon paths that cannot lead to solution."
  },
  680: {
      "title": "Valid Palindrome II",
      "slug": "valid-palindrome-ii",
      "difficulty": "easy",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  682: {
      "title": "Baseball Game",
      "slug": "baseball-game",
      "difficulty": "easy",
      "primaryPattern": "Stack",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "LIFO structure for nested patterns, matching pairs, or maintaining monotonic sequences."
  },
  684: {
      "title": "Redundant Connection",
      "slug": "redundant-connection",
      "difficulty": "medium",
      "primaryPattern": "Union Find",
      "acceptablePatterns": [
          "DFS"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation.",
      "lists": [
          "neetcode-150"
      ],
      "category": "Graphs",
      "patternExplanations": {
          "Union Find": "Process edges. If edge connects already-connected nodes (same component), it's redundant.",
          "DFS": "Build graph edge by edge. Check if new edge creates a cycle using DFS."
      },
      "hints": [
          "A tree has n-1 edges. One extra edge creates exactly one cycle.",
          "The redundant edge is the one that completes the cycle.",
          "Use Union-Find. If both nodes already in same component, this edge is redundant."
      ],
      "solution": {
          "approach": "Union-Find: for each edge, if find(u) == find(v), return this edge (cycle). Else union them.",
          "timeComplexity": "O(n α(n)) ≈ O(n)",
          "spaceComplexity": "O(n)",
          "keyInsight": "Redundant edge connects two already-connected nodes. Union-Find detects this."
      }
  },
  685: {
      "title": "Redundant Connection II",
      "slug": "redundant-connection-ii",
      "difficulty": "hard",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "BFS",
          "Graph"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  686: {
      "title": "Repeated String Match",
      "slug": "repeated-string-match",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  687: {
      "title": "Longest Univalue Path",
      "slug": "longest-univalue-path",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Tree Traversal"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  688: {
      "title": "Knight Probability in Chessboard",
      "slug": "knight-probability-in-chessboard",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  689: {
      "title": "Maximum Sum of 3 Non-Overlapping Subarrays",
      "slug": "maximum-sum-of-3-non-overlapping-subarrays",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Sliding Window"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  690: {
      "title": "Employee Importance",
      "slug": "employee-importance",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Tree Traversal",
          "DFS",
          "BFS"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  691: {
      "title": "Stickers to Spell Word",
      "slug": "stickers-to-spell-word",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Dynamic Programming",
          "Backtracking"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  692: {
      "title": "Top K Frequent Words",
      "slug": "top-k-frequent-words",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Trie",
          "Two Pointers",
          "Heap/Priority Queue"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  693: {
      "title": "Binary Number with Alternating Bits",
      "slug": "binary-number-with-alternating-bits",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  695: {
      "title": "Max Area of Island",
      "slug": "max-area-of-island",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "BFS"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation.",
      "lists": [
          "neetcode-150"
      ],
      "category": "Graphs",
      "patternExplanations": {
          "DFS": "DFS from each land cell, count cells in island. Track visited. Return max area.",
          "BFS": "BFS to explore each island. Count cells in each, return maximum."
      },
      "hints": [
          "Similar to Number of Islands, but track size of each island.",
          "DFS/BFS from each unvisited land cell. Count cells in that island.",
          "Track maximum area seen across all islands."
      ],
      "solution": {
          "approach": "For each unvisited 1, DFS to count island area (marking visited). Track and return max.",
          "timeComplexity": "O(m * n)",
          "spaceComplexity": "O(m * n)",
          "keyInsight": "Standard island traversal, but return count of cells instead of just detecting."
      }
  },
  696: {
      "title": "Count Binary Substrings",
      "slug": "count-binary-substrings",
      "difficulty": "easy",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  697: {
      "title": "Degree of an Array",
      "slug": "degree-of-an-array",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  698: {
      "title": "Partition to K Equal Sum Subsets",
      "slug": "partition-to-k-equal-sum-subsets",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Backtracking"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  699: {
      "title": "Falling Squares",
      "slug": "falling-squares",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  700: {
      "title": "Search in a Binary Search Tree",
      "slug": "search-in-a-binary-search-tree",
      "difficulty": "easy",
      "lists": [
          "leetcode-75"
      ],
      "category": "Binary Search Tree",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "DFS"
      ],
      "patternExplanations": {
          "Binary Search": "BST property: if val < node.val, go left. If val > node.val, go right. If equal, found.",
          "DFS": "Recursive search using BST property to choose direction."
      },
      "hints": [
          "BST: left subtree has smaller values, right subtree has larger values.",
          "Compare target with current node. Go left if smaller, right if larger.",
          "Return the node when found, or null if you reach a leaf without finding."
      ],
      "solution": {
          "approach": "If null or found, return node. If val < node.val, recurse left. Else recurse right.",
          "timeComplexity": "O(h)",
          "spaceComplexity": "O(h) or O(1) iterative",
          "keyInsight": "BST property eliminates half the tree at each step."
      }
  },
  701: {
      "title": "Insert into a Binary Search Tree",
      "slug": "insert-into-a-binary-search-tree",
      "difficulty": "medium",
      "primaryPattern": "Tree Traversal",
      "acceptablePatterns": [],
      "explanation": "Navigate tree structures using inorder, preorder, or postorder traversal. Consider recursive or iterative approaches."
  },
  703: {
      "title": "Kth Largest Element in a Stream",
      "slug": "kth-largest-element-in-a-stream",
      "difficulty": "easy",
      "primaryPattern": "Heap",
      "acceptablePatterns": [],
      "explanation": "Maintain ordered access to min/max elements. Useful for k-largest/smallest, merging, or scheduling problems.",
      "lists": [
          "neetcode-150"
      ],
      "category": "Heap / Priority Queue",
      "patternExplanations": {
          "Heap": "Min-heap of size k. Heap top is kth largest. On add: push, pop if size > k."
      },
      "hints": [
          "Kth largest in a stream. Elements keep coming, need kth largest at any time.",
          "Keep only the k largest elements. The smallest of them is the kth largest.",
          "Use a min-heap of size k. Top of heap is the answer. When adding, push then pop if size > k."
      ],
      "solution": {
          "approach": "Min-heap of size k. Initialize with first elements. add(): push val, pop if size > k, return top.",
          "timeComplexity": "O(log k) per add",
          "spaceComplexity": "O(k)",
          "keyInsight": "Min-heap of k elements: top is kth largest because k-1 elements are larger (below it in heap logic)."
      }
  },
  704: {
      "title": "Binary Search",
      "slug": "binary-search",
      "difficulty": "easy",
      "lists": [
          "neetcode-150"
      ],
      "category": "Binary Search",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [],
      "patternExplanations": {
          "Binary Search": "Compare target with middle element. If equal, found. If target smaller, search left half. If larger, search right half."
      },
      "hints": [
          "The array is sorted. How can you eliminate half the elements with one comparison?",
          "Look at the middle element. Does it tell you which half to search?",
          "left = 0, right = n-1. mid = (left + right) / 2. Adjust bounds based on comparison."
      ],
      "solution": {
          "approach": "Standard binary search: compute mid, compare with target, adjust left/right bounds.",
          "timeComplexity": "O(log n)",
          "spaceComplexity": "O(1)",
          "keyInsight": "Each comparison halves the search space."
      }
  },
  705: {
      "title": "Design HashSet",
      "slug": "design-hashset",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Linked List"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  706: {
      "title": "Design HashMap",
      "slug": "design-hashmap",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Linked List"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  707: {
      "title": "Design Linked List",
      "slug": "design-linked-list",
      "difficulty": "medium",
      "primaryPattern": "Linked List",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Pointer manipulation for reversing, merging, detecting cycles, or finding intersections in linked structures."
  },
  709: {
      "title": "To Lower Case",
      "slug": "to-lower-case",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  710: {
      "title": "Random Pick with Blacklist",
      "slug": "random-pick-with-blacklist",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Binary Search",
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  712: {
      "title": "Minimum ASCII Delete Sum for Two Strings",
      "slug": "minimum-ascii-delete-sum-for-two-strings",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  713: {
      "title": "Subarray Product Less Than K",
      "slug": "subarray-product-less-than-k",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Sliding Window"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  714: {
      "title": "Best Time to Buy and Sell Stock with Transaction Fee",
      "slug": "best-time-to-buy-and-sell-stock-with-transaction-fee",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization.",
      "lists": [
          "leetcode-75"
      ],
      "category": "Dynamic Programming",
      "patternExplanations": {
          "Dynamic Programming": "Track cash (not holding) and hold (holding stock). Fee paid on sell."
      },
      "hints": [
          "Similar to buy/sell stock II, but subtract fee on each transaction.",
          "Two states: holding stock or not. Track max profit in each state.",
          "cash = max(cash, hold + price - fee). hold = max(hold, cash - price)."
      ],
      "solution": {
          "approach": "cash = max(cash, hold + price - fee), hold = max(hold, cash - price). Return cash at end.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "keyInsight": "Same as unlimited transactions, just subtract fee when selling."
      }
  },
  715: {
      "title": "Range Module",
      "slug": "range-module",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  717: {
      "title": "1-bit and 2-bit Characters",
      "slug": "1-bit-and-2-bit-characters",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  718: {
      "title": "Maximum Length of Repeated Subarray",
      "slug": "maximum-length-of-repeated-subarray",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Dynamic Programming",
          "Sliding Window"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  719: {
      "title": "Find K-th Smallest Pair Distance",
      "slug": "find-k-th-smallest-pair-distance",
      "difficulty": "hard",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map",
          "Binary Search"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  720: {
      "title": "Longest Word in Dictionary",
      "slug": "longest-word-in-dictionary",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Trie",
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  721: {
      "title": "Accounts Merge",
      "slug": "accounts-merge",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "DFS",
          "BFS",
          "Graph",
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  722: {
      "title": "Remove Comments",
      "slug": "remove-comments",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  724: {
      "title": "Find Pivot Index",
      "slug": "find-pivot-index",
      "difficulty": "easy",
      "lists": [
          "leetcode-75"
      ],
      "category": "Prefix Sum",
      "primaryPattern": "Prefix Sum",
      "acceptablePatterns": [],
      "patternExplanations": {
          "Prefix Sum": "Pivot has equal left and right sums. Total - leftSum - nums[i] = rightSum. At pivot: leftSum = rightSum."
      },
      "hints": [
          "Pivot index has equal sum on both sides (excluding itself).",
          "leftSum + nums[pivot] + rightSum = total. At pivot: leftSum = rightSum.",
          "rightSum = total - leftSum - nums[i]. Check if leftSum == rightSum."
      ],
      "solution": {
          "approach": "Compute total sum. Track leftSum. At each i, if leftSum == total - leftSum - nums[i], return i.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "keyInsight": "Right sum can be derived from total and left sum without computing it separately."
      }
  },
  725: {
      "title": "Split Linked List in Parts",
      "slug": "split-linked-list-in-parts",
      "difficulty": "medium",
      "primaryPattern": "Linked List",
      "acceptablePatterns": [],
      "explanation": "Pointer manipulation for reversing, merging, detecting cycles, or finding intersections in linked structures."
  },
  726: {
      "title": "Number of Atoms",
      "slug": "number-of-atoms",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Stack",
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  728: {
      "title": "Self Dividing Numbers",
      "slug": "self-dividing-numbers",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  729: {
      "title": "My Calendar I",
      "slug": "my-calendar-i",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  730: {
      "title": "Count Different Palindromic Subsequences",
      "slug": "count-different-palindromic-subsequences",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  731: {
      "title": "My Calendar II",
      "slug": "my-calendar-ii",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  732: {
      "title": "My Calendar III",
      "slug": "my-calendar-iii",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  733: {
      "title": "Flood Fill",
      "slug": "flood-fill",
      "difficulty": "easy",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map",
          "BFS"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  735: {
      "title": "Asteroid Collision",
      "slug": "asteroid-collision",
      "difficulty": "medium",
      "lists": [
          "leetcode-75"
      ],
      "category": "Stack",
      "primaryPattern": "Stack",
      "acceptablePatterns": [],
      "patternExplanations": {
          "Stack": "Push asteroids. Collision happens when stack top is positive and current is negative. Resolve collisions: larger survives, equal both explode."
      },
      "hints": [
          "Positive = moving right, negative = moving left. Collision if right-moving meets left-moving.",
          "Stack keeps asteroids not yet destroyed. Collision: current negative, stack top positive.",
          "While collision possible: compare sizes. Smaller explodes. Equal = both explode."
      ],
      "solution": {
          "approach": "Stack. For each asteroid: while collision (top > 0, curr < 0), compare sizes. Push if curr survives.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)",
          "keyInsight": "Stack resolves collisions in order, letting larger asteroids 'crush' smaller ones."
      }
  },
  736: {
      "title": "Parse Lisp Expression",
      "slug": "parse-lisp-expression",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Stack",
          "DFS"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  738: {
      "title": "Monotone Increasing Digits",
      "slug": "monotone-increasing-digits",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  739: {
      "title": "Daily Temperatures",
      "slug": "daily-temperatures",
      "difficulty": "medium",
      "lists": [
          "neetcode-150",
          "leetcode-75"
      ],
      "category": "Stack",
      "primaryPattern": "Stack",
      "acceptablePatterns": [],
      "patternExplanations": {
          "Stack": "Monotonic decreasing stack of indices. When current temp > stack top, pop and record the difference in days. Stack stores days waiting for warmer weather."
      },
      "hints": [
          "For each day, you want the next day that's warmer. This is 'next greater element'.",
          "Process right to left and maintain a stack of candidates? Or left to right resolving when you find greater?",
          "Left to right: stack holds indices of days waiting for warmer day. Pop when you find it."
      ],
      "solution": {
          "approach": "Monotonic decreasing stack. Push indices. When temp[i] > temp[stack.top], pop and set result[popped] = i - popped.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)",
          "keyInsight": "Monotonic stack efficiently finds 'next greater element' for all positions."
      }
  },
  740: {
      "title": "Delete and Earn",
      "slug": "delete-and-earn",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Dynamic Programming"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  741: {
      "title": "Cherry Pickup",
      "slug": "cherry-pickup",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "DFS"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  743: {
      "title": "Network Delay Time",
      "slug": "network-delay-time",
      "difficulty": "medium",
      "primaryPattern": "BFS",
      "acceptablePatterns": [
          "DFS"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation.",
      "lists": [
          "neetcode-150"
      ],
      "category": "Graphs",
      "patternExplanations": {
          "BFS": "Dijkstra's algorithm: find shortest paths from source to all nodes. Return max of shortest paths.",
          "DFS": "BFS/Dijkstra from source k. Track time to reach each node. Answer is max time."
      },
      "hints": [
          "Find shortest path from k to every other node. Time to reach all = max of those times.",
          "This is single-source shortest path. Use Dijkstra's algorithm.",
          "Min-heap ordered by time. Process node, update neighbors' times. Track max time."
      ],
      "solution": {
          "approach": "Dijkstra from node k. Use min-heap (time, node). Return max time when all nodes visited, or -1 if not all reachable.",
          "timeComplexity": "O((V + E) log V)",
          "spaceComplexity": "O(V + E)",
          "keyInsight": "Dijkstra gives shortest paths from source. Max of those is time to reach all."
      }
  },
  744: {
      "title": "Find Smallest Letter Greater Than Target",
      "slug": "find-smallest-letter-greater-than-target",
      "difficulty": "easy",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  745: {
      "title": "Prefix and Suffix Search",
      "slug": "prefix-and-suffix-search",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Trie"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  746: {
      "title": "Min Cost Climbing Stairs",
      "slug": "min-cost-climbing-stairs",
      "difficulty": "easy",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization.",
      "lists": [
          "neetcode-150",
          "leetcode-75"
      ],
      "category": "Dynamic Programming",
      "patternExplanations": {
          "Dynamic Programming": "dp[i] = min cost to reach step i. Can come from i-1 or i-2."
      },
      "hints": [
          "You can start from step 0 or 1. You can climb 1 or 2 steps.",
          "At each step, min cost = cost[i] + min(cost to reach from i-1, cost to reach from i-2).",
          "dp[i] = cost[i] + min(dp[i-1], dp[i-2]). Answer is min(dp[n-1], dp[n-2])."
      ],
      "solution": {
          "approach": "dp[i] = cost[i] + min(dp[i-1], dp[i-2]). Return min(dp[n-1], dp[n-2]) - can reach top from either.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1) with optimization",
          "keyInsight": "Like climbing stairs, but add cost. Can reach top from last or second-to-last step."
      }
  },
  747: {
      "title": "Largest Number At Least Twice of Others",
      "slug": "largest-number-at-least-twice-of-others",
      "difficulty": "easy",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  748: {
      "title": "Shortest Completing Word",
      "slug": "shortest-completing-word",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  749: {
      "title": "Contain Virus",
      "slug": "contain-virus",
      "difficulty": "hard",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map",
          "BFS"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  752: {
      "title": "Open the Lock",
      "slug": "open-the-lock",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "BFS"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  753: {
      "title": "Cracking the Safe",
      "slug": "cracking-the-safe",
      "difficulty": "hard",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Graph"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  754: {
      "title": "Reach a Number",
      "slug": "reach-a-number",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  756: {
      "title": "Pyramid Transition Matrix",
      "slug": "pyramid-transition-matrix",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Backtracking"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  757: {
      "title": "Set Intersection Size At Least Two",
      "slug": "set-intersection-size-at-least-two",
      "difficulty": "hard",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  761: {
      "title": "Special Binary String",
      "slug": "special-binary-string",
      "difficulty": "hard",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  762: {
      "title": "Prime Number of Set Bits in Binary Representation",
      "slug": "prime-number-of-set-bits-in-binary-representation",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  763: {
      "title": "Partition Labels",
      "slug": "partition-labels",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships.",
      "lists": [
          "neetcode-150"
      ],
      "category": "Greedy",
      "patternExplanations": {
          "Greedy": "Find last occurrence of each char. Partition ends when current index = max last occurrence of chars in partition.",
          "Hash Map": "Store last index of each char. Greedy partition at points where all chars' last occurrences are covered."
      },
      "hints": [
          "Each char must appear in exactly one partition.",
          "If a char appears at index i, the partition containing i must extend to char's last occurrence.",
          "Track last occurrence of each char. Partition ends when i reaches max last occurrence of all chars so far."
      ],
      "solution": {
          "approach": "Map char to last index. Traverse: update end = max(end, lastIndex[char]). When i == end, partition ends.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1) - 26 chars",
          "keyInsight": "Partition must contain all occurrences of its chars. Greedily end when possible."
      }
  },
  764: {
      "title": "Largest Plus Sign",
      "slug": "largest-plus-sign",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  765: {
      "title": "Couples Holding Hands",
      "slug": "couples-holding-hands",
      "difficulty": "hard",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "DFS",
          "BFS",
          "Graph"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  766: {
      "title": "Toeplitz Matrix",
      "slug": "toeplitz-matrix",
      "difficulty": "easy",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  767: {
      "title": "Reorganize String",
      "slug": "reorganize-string",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Greedy",
          "Two Pointers",
          "Heap/Priority Queue"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  768: {
      "title": "Max Chunks To Make Sorted II",
      "slug": "max-chunks-to-make-sorted-ii",
      "difficulty": "hard",
      "primaryPattern": "Stack",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy",
          "Two Pointers"
      ],
      "explanation": "LIFO structure for nested patterns, matching pairs, or maintaining monotonic sequences."
  },
  769: {
      "title": "Max Chunks To Make Sorted",
      "slug": "max-chunks-to-make-sorted",
      "difficulty": "medium",
      "primaryPattern": "Stack",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy",
          "Two Pointers"
      ],
      "explanation": "LIFO structure for nested patterns, matching pairs, or maintaining monotonic sequences."
  },
  770: {
      "title": "Basic Calculator IV",
      "slug": "basic-calculator-iv",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Stack",
          "DFS"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  771: {
      "title": "Jewels and Stones",
      "slug": "jewels-and-stones",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  773: {
      "title": "Sliding Puzzle",
      "slug": "sliding-puzzle",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Backtracking",
          "BFS",
          "DFS"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  775: {
      "title": "Global and Local Inversions",
      "slug": "global-and-local-inversions",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  777: {
      "title": "Swap Adjacent in LR String",
      "slug": "swap-adjacent-in-lr-string",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  778: {
      "title": "Swim in Rising Water",
      "slug": "swim-in-rising-water",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Union Find",
          "BFS"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element.",
      "lists": [
          "neetcode-150"
      ],
      "category": "Graphs",
      "patternExplanations": {
          "Binary Search": "Binary search on answer (max elevation). Check if path exists using BFS/DFS with that limit.",
          "Union Find": "Sort cells by elevation. Add cells in order. Check when (0,0) and (n-1,n-1) are connected.",
          "BFS": "Modified Dijkstra: min-heap by max elevation on path. First path to destination has minimum max elevation."
      },
      "hints": [
          "We want minimum T such that there's a path from (0,0) to (n-1,n-1) with all cells <= T.",
          "Binary search on T. For each T, BFS/DFS to check if path exists.",
          "Or: use modified Dijkstra where priority = max elevation on path to this cell."
      ],
      "solution": {
          "approach": "Dijkstra variant: min-heap by max elevation on path. Return answer when reaching (n-1,n-1).",
          "timeComplexity": "O(n^2 log n)",
          "spaceComplexity": "O(n^2)",
          "keyInsight": "Modified Dijkstra: instead of summing edge weights, take max. Finds minimum-maximum path."
      }
  },
  779: {
      "title": "K-th Symbol in Grammar",
      "slug": "k-th-symbol-in-grammar",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "DFS"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  780: {
      "title": "Reaching Points",
      "slug": "reaching-points",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  781: {
      "title": "Rabbits in Forest",
      "slug": "rabbits-in-forest",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Greedy"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  782: {
      "title": "Transform to Chessboard",
      "slug": "transform-to-chessboard",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "DFS"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  783: {
      "title": "Minimum Distance Between BST Nodes",
      "slug": "minimum-distance-between-bst-nodes",
      "difficulty": "easy",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Tree Traversal",
          "BFS"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  784: {
      "title": "Letter Case Permutation",
      "slug": "letter-case-permutation",
      "difficulty": "medium",
      "primaryPattern": "Backtracking",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Explore all possible solutions recursively. Build candidates incrementally and abandon paths that cannot lead to solution."
  },
  785: {
      "title": "Is Graph Bipartite?",
      "slug": "is-graph-bipartite",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "BFS",
          "Graph"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  786: {
      "title": "K-th Smallest Prime Fraction",
      "slug": "k-th-smallest-prime-fraction",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map",
          "Binary Search",
          "Heap/Priority Queue"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  787: {
      "title": "Cheapest Flights Within K Stops",
      "slug": "cheapest-flights-within-k-stops",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "BFS"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization.",
      "lists": [
          "neetcode-150"
      ],
      "category": "Graphs",
      "patternExplanations": {
          "Dynamic Programming": "Bellman-Ford: dp[i][v] = min cost to reach v with at most i edges. Run k+1 iterations.",
          "BFS": "BFS with k levels. Track min cost to each node at each number of stops."
      },
      "hints": [
          "At most k stops means at most k+1 edges.",
          "Bellman-Ford finds shortest paths with limited edges.",
          "dp[i][v] = min cost to v using at most i edges. Relax all edges k+1 times."
      ],
      "solution": {
          "approach": "Bellman-Ford with k+1 iterations. dp[v] = min cost to reach v. Update by relaxing all edges.",
          "timeComplexity": "O(k * E)",
          "spaceComplexity": "O(V)",
          "keyInsight": "Bellman-Ford naturally limits edge count. k stops = k+1 edges = k+1 iterations."
      }
  },
  788: {
      "title": "Rotated Digits",
      "slug": "rotated-digits",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  789: {
      "title": "Escape The Ghosts",
      "slug": "escape-the-ghosts",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  790: {
      "title": "Domino and Tromino Tiling",
      "slug": "domino-and-tromino-tiling",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization.",
      "lists": [
          "leetcode-75"
      ],
      "category": "Dynamic Programming",
      "patternExplanations": {
          "Dynamic Programming": "Track full rows and rows missing a corner. Derive recurrence from how pieces fit."
      },
      "hints": [
          "Think about states: fully filled rows vs rows with one corner missing.",
          "dp[i] = ways to fill i full columns. But you need another state for partial columns.",
          "Let f(n) = full tilings, p(n) = partial (L-shaped gap). Derive recurrence from piece placements."
      ],
      "solution": {
          "approach": "f(n) = f(n-1) + f(n-2) + 2*p(n-1). p(n) = p(n-1) + f(n-2). Base: f(0)=1, f(1)=1, p(0)=0, p(1)=1.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "keyInsight": "Two states needed: complete columns and columns with L-shaped gap."
      }
  },
  791: {
      "title": "Custom Sort String",
      "slug": "custom-sort-string",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  792: {
      "title": "Number of Matching Subsequences",
      "slug": "number-of-matching-subsequences",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Binary Search",
          "Dynamic Programming",
          "Trie",
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  793: {
      "title": "Preimage Size of Factorial Zeroes Function",
      "slug": "preimage-size-of-factorial-zeroes-function",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  794: {
      "title": "Valid Tic-Tac-Toe State",
      "slug": "valid-tic-tac-toe-state",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  795: {
      "title": "Number of Subarrays with Bounded Maximum",
      "slug": "number-of-subarrays-with-bounded-maximum",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  796: {
      "title": "Rotate String",
      "slug": "rotate-string",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  797: {
      "title": "All Paths From Source to Target",
      "slug": "all-paths-from-source-to-target",
      "difficulty": "medium",
      "primaryPattern": "Backtracking",
      "acceptablePatterns": [
          "DFS",
          "BFS",
          "Graph"
      ],
      "explanation": "Explore all possible solutions recursively. Build candidates incrementally and abandon paths that cannot lead to solution."
  },
  798: {
      "title": "Smallest Rotation with Highest Score",
      "slug": "smallest-rotation-with-highest-score",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  799: {
      "title": "Champagne Tower",
      "slug": "champagne-tower",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  801: {
      "title": "Minimum Swaps To Make Sequences Increasing",
      "slug": "minimum-swaps-to-make-sequences-increasing",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  802: {
      "title": "Find Eventual Safe States",
      "slug": "find-eventual-safe-states",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "BFS",
          "Graph"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  803: {
      "title": "Bricks Falling When Hit",
      "slug": "bricks-falling-when-hit",
      "difficulty": "hard",
      "primaryPattern": "Graph",
      "acceptablePatterns": [
          "Hash Map",
          "DFS"
      ],
      "explanation": "Graph algorithms - may involve topological sort, cycle detection, union find, or connectivity checks."
  },
  804: {
      "title": "Unique Morse Code Words",
      "slug": "unique-morse-code-words",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  805: {
      "title": "Split Array With Same Average",
      "slug": "split-array-with-same-average",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  806: {
      "title": "Number of Lines To Write String",
      "slug": "number-of-lines-to-write-string",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  807: {
      "title": "Max Increase to Keep City Skyline",
      "slug": "max-increase-to-keep-city-skyline",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "DFS"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  808: {
      "title": "Soup Servings",
      "slug": "soup-servings",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  809: {
      "title": "Expressive Words",
      "slug": "expressive-words",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  810: {
      "title": "Chalkboard XOR Game",
      "slug": "chalkboard-xor-game",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  811: {
      "title": "Subdomain Visit Count",
      "slug": "subdomain-visit-count",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  812: {
      "title": "Largest Triangle Area",
      "slug": "largest-triangle-area",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  813: {
      "title": "Largest Sum of Averages",
      "slug": "largest-sum-of-averages",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  814: {
      "title": "Binary Tree Pruning",
      "slug": "binary-tree-pruning",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Tree Traversal"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  815: {
      "title": "Bus Routes",
      "slug": "bus-routes",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "BFS"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  816: {
      "title": "Ambiguous Coordinates",
      "slug": "ambiguous-coordinates",
      "difficulty": "medium",
      "primaryPattern": "Backtracking",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Explore all possible solutions recursively. Build candidates incrementally and abandon paths that cannot lead to solution."
  },
  817: {
      "title": "Linked List Components",
      "slug": "linked-list-components",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Linked List"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  818: {
      "title": "Race Car",
      "slug": "race-car",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  819: {
      "title": "Most Common Word",
      "slug": "most-common-word",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  820: {
      "title": "Short Encoding of Words",
      "slug": "short-encoding-of-words",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Trie"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  821: {
      "title": "Shortest Distance to a Character",
      "slug": "shortest-distance-to-a-character",
      "difficulty": "easy",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  822: {
      "title": "Card Flipping Game",
      "slug": "card-flipping-game",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  823: {
      "title": "Binary Trees With Factors",
      "slug": "binary-trees-with-factors",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Dynamic Programming",
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  824: {
      "title": "Goat Latin",
      "slug": "goat-latin",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  825: {
      "title": "Friends Of Appropriate Ages",
      "slug": "friends-of-appropriate-ages",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map",
          "Binary Search"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  826: {
      "title": "Most Profit Assigning Work",
      "slug": "most-profit-assigning-work",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map",
          "Binary Search",
          "Greedy"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  827: {
      "title": "Making A Large Island",
      "slug": "making-a-large-island",
      "difficulty": "hard",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map",
          "BFS",
          "Graph"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  828: {
      "title": "Count Unique Characters of All Substrings of a Given String",
      "slug": "count-unique-characters-of-all-substrings-of-a-given-string",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Dynamic Programming"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  829: {
      "title": "Consecutive Numbers Sum",
      "slug": "consecutive-numbers-sum",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  830: {
      "title": "Positions of Large Groups",
      "slug": "positions-of-large-groups",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  831: {
      "title": "Masking Personal Information",
      "slug": "masking-personal-information",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  832: {
      "title": "Flipping an Image",
      "slug": "flipping-an-image",
      "difficulty": "easy",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map",
          "DFS"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  833: {
      "title": "Find And Replace in String",
      "slug": "find-and-replace-in-string",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  834: {
      "title": "Sum of Distances in Tree",
      "slug": "sum-of-distances-in-tree",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Tree Traversal",
          "DFS",
          "Graph"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  835: {
      "title": "Image Overlap",
      "slug": "image-overlap",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  836: {
      "title": "Rectangle Overlap",
      "slug": "rectangle-overlap",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  837: {
      "title": "New 21 Game",
      "slug": "new-21-game",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Sliding Window"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  838: {
      "title": "Push Dominoes",
      "slug": "push-dominoes",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map",
          "Dynamic Programming"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  839: {
      "title": "Similar String Groups",
      "slug": "similar-string-groups",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "DFS",
          "BFS",
          "Graph"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  840: {
      "title": "Magic Squares In Grid",
      "slug": "magic-squares-in-grid",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "DFS"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  841: {
      "title": "Keys and Rooms",
      "slug": "keys-and-rooms",
      "difficulty": "medium",
      "lists": [
          "leetcode-75"
      ],
      "category": "Graphs - DFS",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "BFS"
      ],
      "patternExplanations": {
          "DFS": "Start from room 0. DFS to all reachable rooms via keys. Check if all rooms visited.",
          "BFS": "BFS from room 0, exploring rooms as keys are found."
      },
      "hints": [
          "Start in room 0 (unlocked). Each room has keys to other rooms.",
          "This is graph reachability: can you visit all nodes from node 0?",
          "DFS/BFS from 0. Track visited rooms. Return visited.size == n."
      ],
      "solution": {
          "approach": "DFS from room 0. Mark visited. For each key in room, visit that room if not visited. Check if all visited.",
          "timeComplexity": "O(n + e) where e = total keys",
          "spaceComplexity": "O(n)",
          "keyInsight": "Graph traversal: rooms are nodes, keys are edges."
      }
  },
  842: {
      "title": "Split Array into Fibonacci Sequence",
      "slug": "split-array-into-fibonacci-sequence",
      "difficulty": "medium",
      "primaryPattern": "Backtracking",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Explore all possible solutions recursively. Build candidates incrementally and abandon paths that cannot lead to solution."
  },
  843: {
      "title": "Guess the Word",
      "slug": "guess-the-word",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  844: {
      "title": "Backspace String Compare",
      "slug": "backspace-string-compare",
      "difficulty": "easy",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map",
          "Stack"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  845: {
      "title": "Longest Mountain in Array",
      "slug": "longest-mountain-in-array",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map",
          "Dynamic Programming"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  846: {
      "title": "Hand of Straights",
      "slug": "hand-of-straights",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Greedy"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships.",
      "lists": [
          "neetcode-150"
      ],
      "category": "Greedy",
      "patternExplanations": {
          "Hash Map": "Count cards. For smallest card, try to form group starting there. Decrease counts.",
          "Greedy": "Process smallest cards first. Each must start a group (or be invalid)."
      },
      "hints": [
          "Each group is consecutive numbers of size groupSize.",
          "Start with the smallest card. It must begin a group.",
          "Sort or use min-heap. For each min card, try to form a group of consecutive values."
      ],
      "solution": {
          "approach": "Count cards in map. Process smallest first. For each, try to use it and next (groupSize-1) consecutive cards.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(n)",
          "keyInsight": "Smallest card must start a group. Greedily form groups from smallest available."
      }
  },
  847: {
      "title": "Shortest Path Visiting All Nodes",
      "slug": "shortest-path-visiting-all-nodes",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "BFS",
          "Graph"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  848: {
      "title": "Shifting Letters",
      "slug": "shifting-letters",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  849: {
      "title": "Maximize Distance to Closest Person",
      "slug": "maximize-distance-to-closest-person",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  850: {
      "title": "Rectangle Area II",
      "slug": "rectangle-area-ii",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  851: {
      "title": "Loud and Rich",
      "slug": "loud-and-rich",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map",
          "Graph"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  852: {
      "title": "Peak Index in a Mountain Array",
      "slug": "peak-index-in-a-mountain-array",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  853: {
      "title": "Car Fleet",
      "slug": "car-fleet",
      "difficulty": "medium",
      "primaryPattern": "Stack",
      "acceptablePatterns": [
          "Greedy"
      ],
      "explanation": "LIFO structure for nested patterns, matching pairs, or maintaining monotonic sequences.",
      "lists": [
          "neetcode-150"
      ],
      "category": "Stack",
      "patternExplanations": {
          "Stack": "Sort by position. Calculate arrival times. Stack tracks fleets: cars that don't catch up form new fleets.",
          "Greedy": "Sort by position descending. Track latest arrival. Cars arriving earlier catch up (same fleet)."
      },
      "hints": [
          "Calculate time each car takes to reach target: (target - position) / speed.",
          "A car behind cannot pass. If it catches up, they become a fleet.",
          "Sort by position (descending). If car takes longer than the one ahead, it's a new fleet."
      ],
      "solution": {
          "approach": "Sort by position descending. Calculate arrival times. Count times where current > previous (new fleet).",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(n)",
          "keyInsight": "Cars closer to target set the pace. Cars behind either catch up (merge) or form new fleet."
      }
  },
  854: {
      "title": "K-Similar Strings",
      "slug": "k-similar-strings",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "BFS"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  855: {
      "title": "Exam Room",
      "slug": "exam-room",
      "difficulty": "medium",
      "primaryPattern": "Heap/Priority Queue",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Maintain ordered access to min/max elements. Useful for k-largest/smallest, merging, or scheduling problems."
  },
  856: {
      "title": "Score of Parentheses",
      "slug": "score-of-parentheses",
      "difficulty": "medium",
      "primaryPattern": "Stack",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "LIFO structure for nested patterns, matching pairs, or maintaining monotonic sequences."
  },
  857: {
      "title": "Minimum Cost to Hire K Workers",
      "slug": "minimum-cost-to-hire-k-workers",
      "difficulty": "hard",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers",
          "Heap/Priority Queue"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  858: {
      "title": "Mirror Reflection",
      "slug": "mirror-reflection",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  859: {
      "title": "Buddy Strings",
      "slug": "buddy-strings",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  860: {
      "title": "Lemonade Change",
      "slug": "lemonade-change",
      "difficulty": "easy",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  861: {
      "title": "Score After Flipping Matrix",
      "slug": "score-after-flipping-matrix",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "DFS"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  862: {
      "title": "Shortest Subarray with Sum at Least K",
      "slug": "shortest-subarray-with-sum-at-least-k",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "BFS",
          "Sliding Window",
          "Heap/Priority Queue"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  863: {
      "title": "All Nodes Distance K in Binary Tree",
      "slug": "all-nodes-distance-k-in-binary-tree",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Tree Traversal",
          "DFS",
          "BFS"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  864: {
      "title": "Shortest Path to Get All Keys",
      "slug": "shortest-path-to-get-all-keys",
      "difficulty": "hard",
      "primaryPattern": "BFS",
      "acceptablePatterns": [
          "Hash Map",
          "DFS"
      ],
      "explanation": "Breadth-first search - explore level by level using a queue. Ideal for shortest path in unweighted graphs or level-order traversal."
  },
  865: {
      "title": "Smallest Subtree with all the Deepest Nodes",
      "slug": "smallest-subtree-with-all-the-deepest-nodes",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Tree Traversal",
          "DFS",
          "BFS"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  866: {
      "title": "Prime Palindrome",
      "slug": "prime-palindrome",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  867: {
      "title": "Transpose Matrix",
      "slug": "transpose-matrix",
      "difficulty": "easy",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  868: {
      "title": "Binary Gap",
      "slug": "binary-gap",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  869: {
      "title": "Reordered Power of 2",
      "slug": "reordered-power-of-2",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  870: {
      "title": "Advantage Shuffle",
      "slug": "advantage-shuffle",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  871: {
      "title": "Minimum Number of Refueling Stops",
      "slug": "minimum-number-of-refueling-stops",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy",
          "Heap/Priority Queue"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  872: {
      "title": "Leaf-Similar Trees",
      "slug": "leaf-similar-trees",
      "difficulty": "easy",
      "lists": [
          "leetcode-75"
      ],
      "category": "Binary Tree - DFS",
      "primaryPattern": "DFS",
      "acceptablePatterns": [],
      "patternExplanations": {
          "DFS": "DFS both trees, collect leaf values in order. Compare leaf sequences."
      },
      "hints": [
          "Leaf = node with no children. Extract leaf sequence from left to right.",
          "DFS traversal naturally visits leaves in left-to-right order.",
          "Collect leaves from both trees, compare sequences."
      ],
      "solution": {
          "approach": "DFS to collect leaves in array. Compare arrays from both trees.",
          "timeComplexity": "O(n + m)",
          "spaceComplexity": "O(n + m)",
          "keyInsight": "DFS visits leaves in consistent order, enabling sequence comparison."
      }
  },
  873: {
      "title": "Length of Longest Fibonacci Subsequence",
      "slug": "length-of-longest-fibonacci-subsequence",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Dynamic Programming"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  874: {
      "title": "Walking Robot Simulation",
      "slug": "walking-robot-simulation",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  875: {
      "title": "Koko Eating Bananas",
      "slug": "koko-eating-bananas",
      "difficulty": "medium",
      "lists": [
          "neetcode-150",
          "leetcode-75"
      ],
      "category": "Binary Search",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [],
      "patternExplanations": {
          "Binary Search": "Binary search on the answer (eating speed k). For each k, check if all piles can be finished in h hours. Find minimum valid k."
      },
      "hints": [
          "If Koko eats at speed k, hours for pile p = ceil(p/k). Can she finish all piles in h hours?",
          "You're searching for minimum k where total hours <= h. What's the range for k?",
          "k ranges from 1 to max(piles). Binary search: if current k works, try smaller. If not, try larger."
      ],
      "solution": {
          "approach": "Binary search on k in [1, max(piles)]. For each k, sum ceil(pile/k) for all piles. If <= h, try smaller k.",
          "timeComplexity": "O(n log m) where m = max pile",
          "spaceComplexity": "O(1)",
          "keyInsight": "Binary search on the answer space when you can verify a candidate in O(n)."
      }
  },
  876: {
      "title": "Middle of the Linked List",
      "slug": "middle-of-the-linked-list",
      "difficulty": "easy",
      "primaryPattern": "Linked List",
      "acceptablePatterns": [
          "Two Pointers"
      ],
      "explanation": "Pointer manipulation for reversing, merging, detecting cycles, or finding intersections in linked structures."
  },
  877: {
      "title": "Stone Game",
      "slug": "stone-game",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  878: {
      "title": "Nth Magical Number",
      "slug": "nth-magical-number",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  879: {
      "title": "Profitable Schemes",
      "slug": "profitable-schemes",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  880: {
      "title": "Decoded String at Index",
      "slug": "decoded-string-at-index",
      "difficulty": "medium",
      "primaryPattern": "Stack",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "LIFO structure for nested patterns, matching pairs, or maintaining monotonic sequences."
  },
  881: {
      "title": "Boats to Save People",
      "slug": "boats-to-save-people",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  882: {
      "title": "Reachable Nodes In Subdivided Graph",
      "slug": "reachable-nodes-in-subdivided-graph",
      "difficulty": "hard",
      "primaryPattern": "Heap/Priority Queue",
      "acceptablePatterns": [
          "Graph",
          "BFS"
      ],
      "explanation": "Maintain ordered access to min/max elements. Useful for k-largest/smallest, merging, or scheduling problems."
  },
  883: {
      "title": "Projection Area of 3D Shapes",
      "slug": "projection-area-of-3d-shapes",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "DFS"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  884: {
      "title": "Uncommon Words from Two Sentences",
      "slug": "uncommon-words-from-two-sentences",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  885: {
      "title": "Spiral Matrix III",
      "slug": "spiral-matrix-iii",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  886: {
      "title": "Possible Bipartition",
      "slug": "possible-bipartition",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "BFS",
          "Graph"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  887: {
      "title": "Super Egg Drop",
      "slug": "super-egg-drop",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Dynamic Programming"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  888: {
      "title": "Fair Candy Swap",
      "slug": "fair-candy-swap",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Binary Search",
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  889: {
      "title": "Construct Binary Tree from Preorder and Postorder Traversal",
      "slug": "construct-binary-tree-from-preorder-and-postorder-traversal",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Binary Search",
          "Tree Traversal"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  890: {
      "title": "Find and Replace Pattern",
      "slug": "find-and-replace-pattern",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  891: {
      "title": "Sum of Subsequence Widths",
      "slug": "sum-of-subsequence-widths",
      "difficulty": "hard",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  892: {
      "title": "Surface Area of 3D Shapes",
      "slug": "surface-area-of-3d-shapes",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "DFS"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  893: {
      "title": "Groups of Special-Equivalent Strings",
      "slug": "groups-of-special-equivalent-strings",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  894: {
      "title": "All Possible Full Binary Trees",
      "slug": "all-possible-full-binary-trees",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Tree Traversal",
          "DFS"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  895: {
      "title": "Maximum Frequency Stack",
      "slug": "maximum-frequency-stack",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Stack"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  896: {
      "title": "Monotonic Array",
      "slug": "monotonic-array",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  897: {
      "title": "Increasing Order Search Tree",
      "slug": "increasing-order-search-tree",
      "difficulty": "easy",
      "primaryPattern": "Stack",
      "acceptablePatterns": [
          "Tree Traversal",
          "DFS"
      ],
      "explanation": "LIFO structure for nested patterns, matching pairs, or maintaining monotonic sequences."
  },
  898: {
      "title": "Bitwise ORs of Subarrays",
      "slug": "bitwise-ors-of-subarrays",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  899: {
      "title": "Orderly Queue",
      "slug": "orderly-queue",
      "difficulty": "hard",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  900: {
      "title": "RLE Iterator",
      "slug": "rle-iterator",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  901: {
      "title": "Online Stock Span",
      "slug": "online-stock-span",
      "difficulty": "medium",
      "primaryPattern": "Stack",
      "acceptablePatterns": [],
      "explanation": "LIFO structure for nested patterns, matching pairs, or maintaining monotonic sequences.",
      "lists": [
          "leetcode-75"
      ],
      "category": "Stack",
      "patternExplanations": {
          "Stack": "Monotonic decreasing stack of (price, span). Pop smaller, accumulate their spans."
      },
      "hints": [
          "Span = consecutive days (including today) where price was <= today's price.",
          "Think about what happens when today's price is higher than yesterday's.",
          "Use a stack of (price, span). Pop all smaller prices, accumulate their spans."
      ],
      "solution": {
          "approach": "Stack of (price, span). On next: pop all smaller, add their spans. Push (price, total span). Return span.",
          "timeComplexity": "O(1) amortized per call",
          "spaceComplexity": "O(n)",
          "keyInsight": "When we see a higher price, it 'absorbs' the spans of all smaller prices."
      }
  },
  902: {
      "title": "Numbers At Most N Given Digit Set",
      "slug": "numbers-at-most-n-given-digit-set",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Dynamic Programming"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  903: {
      "title": "Valid Permutations for DI Sequence",
      "slug": "valid-permutations-for-di-sequence",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  904: {
      "title": "Fruit Into Baskets",
      "slug": "fruit-into-baskets",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Sliding Window"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  905: {
      "title": "Sort Array By Parity",
      "slug": "sort-array-by-parity",
      "difficulty": "easy",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  906: {
      "title": "Super Palindromes",
      "slug": "super-palindromes",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  907: {
      "title": "Sum of Subarray Minimums",
      "slug": "sum-of-subarray-minimums",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Stack"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  908: {
      "title": "Smallest Range I",
      "slug": "smallest-range-i",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  909: {
      "title": "Snakes and Ladders",
      "slug": "snakes-and-ladders",
      "difficulty": "medium",
      "primaryPattern": "BFS",
      "acceptablePatterns": [
          "Hash Map",
          "DFS"
      ],
      "explanation": "Breadth-first search - explore level by level using a queue. Ideal for shortest path in unweighted graphs or level-order traversal."
  },
  910: {
      "title": "Smallest Range II",
      "slug": "smallest-range-ii",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  911: {
      "title": "Online Election",
      "slug": "online-election",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Binary Search"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  912: {
      "title": "Sort an Array",
      "slug": "sort-an-array",
      "difficulty": "medium",
      "primaryPattern": "Heap/Priority Queue",
      "acceptablePatterns": [
          "Hash Map",
          "Binary Search",
          "Two Pointers"
      ],
      "explanation": "Maintain ordered access to min/max elements. Useful for k-largest/smallest, merging, or scheduling problems."
  },
  913: {
      "title": "Cat and Mouse",
      "slug": "cat-and-mouse",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Graph"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  914: {
      "title": "X of a Kind in a Deck of Cards",
      "slug": "x-of-a-kind-in-a-deck-of-cards",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  915: {
      "title": "Partition Array into Disjoint Intervals",
      "slug": "partition-array-into-disjoint-intervals",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  916: {
      "title": "Word Subsets",
      "slug": "word-subsets",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  917: {
      "title": "Reverse Only Letters",
      "slug": "reverse-only-letters",
      "difficulty": "easy",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  918: {
      "title": "Maximum Sum Circular Subarray",
      "slug": "maximum-sum-circular-subarray",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Binary Search",
          "BFS",
          "Sliding Window"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  919: {
      "title": "Complete Binary Tree Inserter",
      "slug": "complete-binary-tree-inserter",
      "difficulty": "medium",
      "primaryPattern": "BFS",
      "acceptablePatterns": [
          "Tree Traversal",
          "Hash Map"
      ],
      "explanation": "Breadth-first search - explore level by level using a queue. Ideal for shortest path in unweighted graphs or level-order traversal."
  },
  920: {
      "title": "Number of Music Playlists",
      "slug": "number-of-music-playlists",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  921: {
      "title": "Minimum Add to Make Parentheses Valid",
      "slug": "minimum-add-to-make-parentheses-valid",
      "difficulty": "medium",
      "primaryPattern": "Stack",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy"
      ],
      "explanation": "LIFO structure for nested patterns, matching pairs, or maintaining monotonic sequences."
  },
  922: {
      "title": "Sort Array By Parity II",
      "slug": "sort-array-by-parity-ii",
      "difficulty": "easy",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  923: {
      "title": "3Sum With Multiplicity",
      "slug": "3sum-with-multiplicity",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  924: {
      "title": "Minimize Malware Spread",
      "slug": "minimize-malware-spread",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "DFS",
          "BFS",
          "Graph"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  925: {
      "title": "Long Pressed Name",
      "slug": "long-pressed-name",
      "difficulty": "easy",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  926: {
      "title": "Flip String to Monotone Increasing",
      "slug": "flip-string-to-monotone-increasing",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  927: {
      "title": "Three Equal Parts",
      "slug": "three-equal-parts",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  928: {
      "title": "Minimize Malware Spread II",
      "slug": "minimize-malware-spread-ii",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "DFS",
          "BFS",
          "Graph"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  929: {
      "title": "Unique Email Addresses",
      "slug": "unique-email-addresses",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  930: {
      "title": "Binary Subarrays With Sum",
      "slug": "binary-subarrays-with-sum",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Sliding Window"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  931: {
      "title": "Minimum Falling Path Sum",
      "slug": "minimum-falling-path-sum",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "DFS"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  932: {
      "title": "Beautiful Array",
      "slug": "beautiful-array",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  933: {
      "title": "Number of Recent Calls",
      "slug": "number-of-recent-calls",
      "difficulty": "easy",
      "lists": [
          "leetcode-75"
      ],
      "category": "Queue",
      "primaryPattern": "Queue",
      "acceptablePatterns": [
          "Sliding Window"
      ],
      "patternExplanations": {
          "Queue": "Queue stores timestamps of recent calls. Add new timestamp, remove timestamps older than t-3000. Return queue size.",
          "Sliding Window": "Window of valid timestamps. Slide by adding new and removing old."
      },
      "hints": [
          "Count calls in last 3000 milliseconds including current.",
          "New calls have increasing timestamps. What can you remove?",
          "Queue: add new timestamp, remove from front while front < t - 3000."
      ],
      "solution": {
          "approach": "Queue of timestamps. On ping(t): add t, remove while front < t - 3000. Return queue size.",
          "timeComplexity": "O(1) amortized",
          "spaceComplexity": "O(3000) = O(1)",
          "keyInsight": "FIFO queue naturally handles time-windowed operations."
      }
  },
  934: {
      "title": "Shortest Bridge",
      "slug": "shortest-bridge",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map",
          "BFS"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  935: {
      "title": "Knight Dialer",
      "slug": "knight-dialer",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  936: {
      "title": "Stamping The Sequence",
      "slug": "stamping-the-sequence",
      "difficulty": "hard",
      "primaryPattern": "Stack",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy",
          "BFS"
      ],
      "explanation": "LIFO structure for nested patterns, matching pairs, or maintaining monotonic sequences."
  },
  937: {
      "title": "Reorder Data in Log Files",
      "slug": "reorder-data-in-log-files",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  938: {
      "title": "Range Sum of BST",
      "slug": "range-sum-of-bst",
      "difficulty": "easy",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Tree Traversal"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  939: {
      "title": "Minimum Area Rectangle",
      "slug": "minimum-area-rectangle",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  940: {
      "title": "Distinct Subsequences II",
      "slug": "distinct-subsequences-ii",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  941: {
      "title": "Valid Mountain Array",
      "slug": "valid-mountain-array",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  942: {
      "title": "DI String Match",
      "slug": "di-string-match",
      "difficulty": "easy",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  943: {
      "title": "Find the Shortest Superstring",
      "slug": "find-the-shortest-superstring",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  944: {
      "title": "Delete Columns to Make Sorted",
      "slug": "delete-columns-to-make-sorted",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  945: {
      "title": "Minimum Increment to Make Array Unique",
      "slug": "minimum-increment-to-make-array-unique",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  946: {
      "title": "Validate Stack Sequences",
      "slug": "validate-stack-sequences",
      "difficulty": "medium",
      "primaryPattern": "Stack",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "LIFO structure for nested patterns, matching pairs, or maintaining monotonic sequences."
  },
  947: {
      "title": "Most Stones Removed with Same Row or Column",
      "slug": "most-stones-removed-with-same-row-or-column",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "DFS",
          "Graph"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  948: {
      "title": "Bag of Tokens",
      "slug": "bag-of-tokens",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  949: {
      "title": "Largest Time for Given Digits",
      "slug": "largest-time-for-given-digits",
      "difficulty": "medium",
      "primaryPattern": "Backtracking",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Explore all possible solutions recursively. Build candidates incrementally and abandon paths that cannot lead to solution."
  },
  950: {
      "title": "Reveal Cards In Increasing Order",
      "slug": "reveal-cards-in-increasing-order",
      "difficulty": "medium",
      "primaryPattern": "BFS",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Breadth-first search - explore level by level using a queue. Ideal for shortest path in unweighted graphs or level-order traversal."
  },
  951: {
      "title": "Flip Equivalent Binary Trees",
      "slug": "flip-equivalent-binary-trees",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Tree Traversal"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  952: {
      "title": "Largest Component Size by Common Factor",
      "slug": "largest-component-size-by-common-factor",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Graph"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  953: {
      "title": "Verifying an Alien Dictionary",
      "slug": "verifying-an-alien-dictionary",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  954: {
      "title": "Array of Doubled Pairs",
      "slug": "array-of-doubled-pairs",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Greedy",
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  955: {
      "title": "Delete Columns to Make Sorted II",
      "slug": "delete-columns-to-make-sorted-ii",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  956: {
      "title": "Tallest Billboard",
      "slug": "tallest-billboard",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  957: {
      "title": "Prison Cells After N Days",
      "slug": "prison-cells-after-n-days",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  958: {
      "title": "Check Completeness of a Binary Tree",
      "slug": "check-completeness-of-a-binary-tree",
      "difficulty": "medium",
      "primaryPattern": "BFS",
      "acceptablePatterns": [
          "Tree Traversal"
      ],
      "explanation": "Breadth-first search - explore level by level using a queue. Ideal for shortest path in unweighted graphs or level-order traversal."
  },
  959: {
      "title": "Regions Cut By Slashes",
      "slug": "regions-cut-by-slashes",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "DFS",
          "BFS",
          "Graph"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  960: {
      "title": "Delete Columns to Make Sorted III",
      "slug": "delete-columns-to-make-sorted-iii",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  961: {
      "title": "N-Repeated Element in Size 2N Array",
      "slug": "n-repeated-element-in-size-2n-array",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  962: {
      "title": "Maximum Width Ramp",
      "slug": "maximum-width-ramp",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map",
          "Stack"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  963: {
      "title": "Minimum Area Rectangle II",
      "slug": "minimum-area-rectangle-ii",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  964: {
      "title": "Least Operators to Express Number",
      "slug": "least-operators-to-express-number",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  965: {
      "title": "Univalued Binary Tree",
      "slug": "univalued-binary-tree",
      "difficulty": "easy",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Tree Traversal",
          "BFS"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  966: {
      "title": "Vowel Spellchecker",
      "slug": "vowel-spellchecker",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  967: {
      "title": "Numbers With Same Consecutive Differences",
      "slug": "numbers-with-same-consecutive-differences",
      "difficulty": "medium",
      "primaryPattern": "Backtracking",
      "acceptablePatterns": [
          "BFS"
      ],
      "explanation": "Explore all possible solutions recursively. Build candidates incrementally and abandon paths that cannot lead to solution."
  },
  968: {
      "title": "Binary Tree Cameras",
      "slug": "binary-tree-cameras",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Tree Traversal",
          "DFS"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  969: {
      "title": "Pancake Sorting",
      "slug": "pancake-sorting",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  970: {
      "title": "Powerful Integers",
      "slug": "powerful-integers",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  971: {
      "title": "Flip Binary Tree To Match Preorder Traversal",
      "slug": "flip-binary-tree-to-match-preorder-traversal",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Tree Traversal"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  972: {
      "title": "Equal Rational Numbers",
      "slug": "equal-rational-numbers",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  973: {
      "title": "K Closest Points to Origin",
      "slug": "k-closest-points-to-origin",
      "difficulty": "medium",
      "primaryPattern": "Heap",
      "acceptablePatterns": [
          "Quickselect"
      ],
      "explanation": "Maintain ordered access to min/max elements. Useful for k-largest/smallest, merging, or scheduling problems.",
      "lists": [
          "neetcode-150"
      ],
      "category": "Heap / Priority Queue",
      "patternExplanations": {
          "Heap": "Max-heap of size k by distance. Keep k closest by removing farther points.",
          "Quickselect": "Quickselect to partition around kth closest. O(n) average."
      },
      "hints": [
          "Compute distance for each point. Find k smallest distances.",
          "Don't need sqrt for distance - compare squared distances.",
          "Use max-heap of size k. Or quickselect for O(n) average."
      ],
      "solution": {
          "approach": "Max-heap of size k. For each point, push. If size > k, pop (removes farthest). Return heap contents.",
          "timeComplexity": "O(n log k)",
          "spaceComplexity": "O(k)",
          "keyInsight": "Max-heap of k elements naturally keeps k smallest (largest gets removed)."
      }
  },
  974: {
      "title": "Subarray Sums Divisible by K",
      "slug": "subarray-sums-divisible-by-k",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  975: {
      "title": "Odd Even Jump",
      "slug": "odd-even-jump",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Stack",
          "Two Pointers"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  976: {
      "title": "Largest Perimeter Triangle",
      "slug": "largest-perimeter-triangle",
      "difficulty": "easy",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  977: {
      "title": "Squares of a Sorted Array",
      "slug": "squares-of-a-sorted-array",
      "difficulty": "easy",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  978: {
      "title": "Longest Turbulent Subarray",
      "slug": "longest-turbulent-subarray",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Sliding Window"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  979: {
      "title": "Distribute Coins in Binary Tree",
      "slug": "distribute-coins-in-binary-tree",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Tree Traversal"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  980: {
      "title": "Unique Paths III",
      "slug": "unique-paths-iii",
      "difficulty": "hard",
      "primaryPattern": "Backtracking",
      "acceptablePatterns": [
          "Hash Map",
          "DFS"
      ],
      "explanation": "Explore all possible solutions recursively. Build candidates incrementally and abandon paths that cannot lead to solution."
  },
  981: {
      "title": "Time Based Key-Value Store",
      "slug": "time-based-key-value-store",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Binary Search"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships.",
      "lists": [
          "neetcode-150"
      ],
      "category": "Binary Search",
      "patternExplanations": {
          "Hash Map": "Map key to list of (timestamp, value). Binary search list for largest timestamp <= given.",
          "Binary Search": "Store (timestamp, value) pairs per key. Binary search for floor timestamp."
      },
      "hints": [
          "For each key, store all (timestamp, value) pairs.",
          "Timestamps are strictly increasing per key, so the list is sorted.",
          "Binary search for largest timestamp <= query timestamp."
      ],
      "solution": {
          "approach": "HashMap: key -> list of (timestamp, value). Get: binary search for floor timestamp in list.",
          "timeComplexity": "O(1) set, O(log n) get",
          "spaceComplexity": "O(n)",
          "keyInsight": "Sorted timestamps allow binary search. Find rightmost timestamp <= query."
      }
  },
  982: {
      "title": "Triples with Bitwise AND Equal To Zero",
      "slug": "triples-with-bitwise-and-equal-to-zero",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  983: {
      "title": "Minimum Cost For Tickets",
      "slug": "minimum-cost-for-tickets",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  984: {
      "title": "String Without AAA or BBB",
      "slug": "string-without-aaa-or-bbb",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  985: {
      "title": "Sum of Even Numbers After Queries",
      "slug": "sum-of-even-numbers-after-queries",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  986: {
      "title": "Interval List Intersections",
      "slug": "interval-list-intersections",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  987: {
      "title": "Vertical Order Traversal of a Binary Tree",
      "slug": "vertical-order-traversal-of-a-binary-tree",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Tree Traversal",
          "DFS",
          "BFS",
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  988: {
      "title": "Smallest String Starting From Leaf",
      "slug": "smallest-string-starting-from-leaf",
      "difficulty": "medium",
      "primaryPattern": "Backtracking",
      "acceptablePatterns": [
          "Hash Map",
          "Tree Traversal",
          "DFS"
      ],
      "explanation": "Explore all possible solutions recursively. Build candidates incrementally and abandon paths that cannot lead to solution."
  },
  989: {
      "title": "Add to Array-Form of Integer",
      "slug": "add-to-array-form-of-integer",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  990: {
      "title": "Satisfiability of Equality Equations",
      "slug": "satisfiability-of-equality-equations",
      "difficulty": "medium",
      "primaryPattern": "Graph",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Graph algorithms - may involve topological sort, cycle detection, union find, or connectivity checks."
  },
  991: {
      "title": "Broken Calculator",
      "slug": "broken-calculator",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  992: {
      "title": "Subarrays with K Different Integers",
      "slug": "subarrays-with-k-different-integers",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Sliding Window"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  993: {
      "title": "Cousins in Binary Tree",
      "slug": "cousins-in-binary-tree",
      "difficulty": "easy",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Tree Traversal",
          "BFS"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  994: {
      "title": "Rotting Oranges",
      "slug": "rotting-oranges",
      "difficulty": "medium",
      "lists": [
          "neetcode-150",
          "leetcode-75"
      ],
      "category": "Graphs",
      "primaryPattern": "BFS",
      "acceptablePatterns": [],
      "patternExplanations": {
          "BFS": "Multi-source BFS from all rotten oranges simultaneously. Each BFS level = 1 minute. Track fresh oranges remaining."
      },
      "hints": [
          "All rotten oranges spread simultaneously. This is multi-source, not single-source.",
          "BFS from all rotten oranges at once. Each 'wave' of BFS is one minute.",
          "Count fresh oranges initially. Decrement as they rot. Time = BFS levels. Check if all rotted."
      ],
      "solution": {
          "approach": "Add all rotten oranges to queue. BFS: for each level (minute), rot adjacent fresh oranges. Track time and fresh count.",
          "timeComplexity": "O(m * n)",
          "spaceComplexity": "O(m * n)",
          "keyInsight": "Multi-source BFS simulates simultaneous spreading. Level = time unit."
      }
  },
  995: {
      "title": "Minimum Number of K Consecutive Bit Flips",
      "slug": "minimum-number-of-k-consecutive-bit-flips",
      "difficulty": "hard",
      "primaryPattern": "Sliding Window",
      "acceptablePatterns": [
          "Hash Map",
          "BFS"
      ],
      "explanation": "Maintain a window of elements that slides through the array. Expand when adding elements, contract when removing. Track window state."
  },
  996: {
      "title": "Number of Squareful Arrays",
      "slug": "number-of-squareful-arrays",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Dynamic Programming",
          "Backtracking"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  997: {
      "title": "Find the Town Judge",
      "slug": "find-the-town-judge",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Graph"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  998: {
      "title": "Maximum Binary Tree II",
      "slug": "maximum-binary-tree-ii",
      "difficulty": "medium",
      "primaryPattern": "Tree Traversal",
      "acceptablePatterns": [],
      "explanation": "Navigate tree structures using inorder, preorder, or postorder traversal. Consider recursive or iterative approaches."
  },
  999: {
      "title": "Available Captures for Rook",
      "slug": "available-captures-for-rook",
      "difficulty": "easy",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  1000: {
      "title": "Minimum Cost to Merge Stones",
      "slug": "minimum-cost-to-merge-stones",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1001: {
      "title": "Grid Illumination",
      "slug": "grid-illumination",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1002: {
      "title": "Find Common Characters",
      "slug": "find-common-characters",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1003: {
      "title": "Check If Word Is Valid After Substitutions",
      "slug": "check-if-word-is-valid-after-substitutions",
      "difficulty": "medium",
      "primaryPattern": "Stack",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "LIFO structure for nested patterns, matching pairs, or maintaining monotonic sequences."
  },
  1004: {
      "title": "Max Consecutive Ones III",
      "slug": "max-consecutive-ones-iii",
      "difficulty": "medium",
      "lists": [
          "leetcode-75"
      ],
      "category": "Sliding Window",
      "primaryPattern": "Sliding Window",
      "acceptablePatterns": [],
      "patternExplanations": {
          "Sliding Window": "Window contains at most k zeros. Expand right adding elements. When zeros > k, shrink left. Track max window size."
      },
      "hints": [
          "You can flip at most k zeros to ones. Find longest subarray of all 1s after flipping.",
          "Window is valid if it contains at most k zeros.",
          "Expand right, count zeros. When zeros > k, shrink left until zeros <= k."
      ],
      "solution": {
          "approach": "Track zeros count in window. Expand right always. When zeros > k, shrink left. Max length = right - left + 1.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "keyInsight": "Sliding window with constraint: at most k zeros allowed."
      }
  },
  1005: {
      "title": "Maximize Sum Of Array After K Negations",
      "slug": "maximize-sum-of-array-after-k-negations",
      "difficulty": "easy",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  1006: {
      "title": "Clumsy Factorial",
      "slug": "clumsy-factorial",
      "difficulty": "medium",
      "primaryPattern": "Stack",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "LIFO structure for nested patterns, matching pairs, or maintaining monotonic sequences."
  },
  1007: {
      "title": "Minimum Domino Rotations For Equal Row",
      "slug": "minimum-domino-rotations-for-equal-row",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  1008: {
      "title": "Construct Binary Search Tree from Preorder Traversal",
      "slug": "construct-binary-search-tree-from-preorder-traversal",
      "difficulty": "medium",
      "primaryPattern": "Stack",
      "acceptablePatterns": [
          "Hash Map",
          "Tree Traversal"
      ],
      "explanation": "LIFO structure for nested patterns, matching pairs, or maintaining monotonic sequences."
  },
  1009: {
      "title": "Complement of Base 10 Integer",
      "slug": "complement-of-base-10-integer",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1010: {
      "title": "Pairs of Songs With Total Durations Divisible by 60",
      "slug": "pairs-of-songs-with-total-durations-divisible-by-60",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1011: {
      "title": "Capacity To Ship Packages Within D Days",
      "slug": "capacity-to-ship-packages-within-d-days",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  1012: {
      "title": "Numbers With Repeated Digits",
      "slug": "numbers-with-repeated-digits",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1013: {
      "title": "Partition Array Into Three Parts With Equal Sum",
      "slug": "partition-array-into-three-parts-with-equal-sum",
      "difficulty": "easy",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  1014: {
      "title": "Best Sightseeing Pair",
      "slug": "best-sightseeing-pair",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1015: {
      "title": "Smallest Integer Divisible by K",
      "slug": "smallest-integer-divisible-by-k",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1016: {
      "title": "Binary String With Substrings Representing 1 To N",
      "slug": "binary-string-with-substrings-representing-1-to-n",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Sliding Window"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1017: {
      "title": "Convert to Base -2",
      "slug": "convert-to-base-2",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1018: {
      "title": "Binary Prefix Divisible By 5",
      "slug": "binary-prefix-divisible-by-5",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1019: {
      "title": "Next Greater Node In Linked List",
      "slug": "next-greater-node-in-linked-list",
      "difficulty": "medium",
      "primaryPattern": "Linked List",
      "acceptablePatterns": [
          "Hash Map",
          "Stack"
      ],
      "explanation": "Pointer manipulation for reversing, merging, detecting cycles, or finding intersections in linked structures."
  },
  1020: {
      "title": "Number of Enclaves",
      "slug": "number-of-enclaves",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map",
          "BFS",
          "Graph"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  1021: {
      "title": "Remove Outermost Parentheses",
      "slug": "remove-outermost-parentheses",
      "difficulty": "easy",
      "primaryPattern": "Stack",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "LIFO structure for nested patterns, matching pairs, or maintaining monotonic sequences."
  },
  1022: {
      "title": "Sum of Root To Leaf Binary Numbers",
      "slug": "sum-of-root-to-leaf-binary-numbers",
      "difficulty": "easy",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Tree Traversal"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  1023: {
      "title": "Camelcase Matching",
      "slug": "camelcase-matching",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map",
          "Trie"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  1024: {
      "title": "Video Stitching",
      "slug": "video-stitching",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1025: {
      "title": "Divisor Game",
      "slug": "divisor-game",
      "difficulty": "easy",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1026: {
      "title": "Maximum Difference Between Node and Ancestor",
      "slug": "maximum-difference-between-node-and-ancestor",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Tree Traversal"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  1027: {
      "title": "Longest Arithmetic Subsequence",
      "slug": "longest-arithmetic-subsequence",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Binary Search",
          "Dynamic Programming"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1028: {
      "title": "Recover a Tree From Preorder Traversal",
      "slug": "recover-a-tree-from-preorder-traversal",
      "difficulty": "hard",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map",
          "Tree Traversal"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  1029: {
      "title": "Two City Scheduling",
      "slug": "two-city-scheduling",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  1030: {
      "title": "Matrix Cells in Distance Order",
      "slug": "matrix-cells-in-distance-order",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Two Pointers",
          "DFS"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1031: {
      "title": "Maximum Sum of Two Non-Overlapping Subarrays",
      "slug": "maximum-sum-of-two-non-overlapping-subarrays",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Sliding Window"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1032: {
      "title": "Stream of Characters",
      "slug": "stream-of-characters",
      "difficulty": "hard",
      "primaryPattern": "Trie",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Prefix tree for efficient string operations. Each node represents a character, paths represent strings."
  },
  1033: {
      "title": "Moving Stones Until Consecutive",
      "slug": "moving-stones-until-consecutive",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1034: {
      "title": "Coloring A Border",
      "slug": "coloring-a-border",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map",
          "BFS"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  1035: {
      "title": "Uncrossed Lines",
      "slug": "uncrossed-lines",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1036: {
      "title": "Escape a Large Maze",
      "slug": "escape-a-large-maze",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "DFS",
          "BFS"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1037: {
      "title": "Valid Boomerang",
      "slug": "valid-boomerang",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1038: {
      "title": "Binary Search Tree to Greater Sum Tree",
      "slug": "binary-search-tree-to-greater-sum-tree",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Tree Traversal"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  1039: {
      "title": "Minimum Score Triangulation of Polygon",
      "slug": "minimum-score-triangulation-of-polygon",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1040: {
      "title": "Moving Stones Until Consecutive II",
      "slug": "moving-stones-until-consecutive-ii",
      "difficulty": "medium",
      "primaryPattern": "Sliding Window",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Maintain a window of elements that slides through the array. Expand when adding elements, contract when removing. Track window state."
  },
  1041: {
      "title": "Robot Bounded In Circle",
      "slug": "robot-bounded-in-circle",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1042: {
      "title": "Flower Planting With No Adjacent",
      "slug": "flower-planting-with-no-adjacent",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "BFS",
          "Graph"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  1043: {
      "title": "Partition Array for Maximum Sum",
      "slug": "partition-array-for-maximum-sum",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1044: {
      "title": "Longest Duplicate Substring",
      "slug": "longest-duplicate-substring",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Sliding Window"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  1045: {
      "title": "Customers Who Bought All Products",
      "slug": "customers-who-bought-all-products",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1046: {
      "title": "Last Stone Weight",
      "slug": "last-stone-weight",
      "difficulty": "easy",
      "primaryPattern": "Heap",
      "acceptablePatterns": [],
      "explanation": "Maintain ordered access to min/max elements. Useful for k-largest/smallest, merging, or scheduling problems.",
      "lists": [
          "neetcode-150"
      ],
      "category": "Heap / Priority Queue",
      "patternExplanations": {
          "Heap": "Max-heap. Pop two largest, push difference (if nonzero). Continue until <= 1 stone."
      },
      "hints": [
          "Always smash two heaviest stones. Result is their difference (or both destroyed if equal).",
          "Need to repeatedly get two maximum values. What data structure?",
          "Max-heap: pop two, push difference if nonzero. Stop when 0 or 1 stones left."
      ],
      "solution": {
          "approach": "Max-heap of stones. While size > 1: pop two, push |diff| if nonzero. Return last stone or 0.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(n)",
          "keyInsight": "Max-heap efficiently maintains largest elements for repeated extraction."
      }
  },
  1047: {
      "title": "Remove All Adjacent Duplicates In String",
      "slug": "remove-all-adjacent-duplicates-in-string",
      "difficulty": "easy",
      "primaryPattern": "Stack",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "LIFO structure for nested patterns, matching pairs, or maintaining monotonic sequences."
  },
  1048: {
      "title": "Longest String Chain",
      "slug": "longest-string-chain",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Two Pointers",
          "Dynamic Programming"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1049: {
      "title": "Last Stone Weight II",
      "slug": "last-stone-weight-ii",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1050: {
      "title": "Actors and Directors Who Cooperated At Least Three Times",
      "slug": "actors-and-directors-who-cooperated-at-least-three-times",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1051: {
      "title": "Height Checker",
      "slug": "height-checker",
      "difficulty": "easy",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  1052: {
      "title": "Grumpy Bookstore Owner",
      "slug": "grumpy-bookstore-owner",
      "difficulty": "medium",
      "primaryPattern": "Sliding Window",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Maintain a window of elements that slides through the array. Expand when adding elements, contract when removing. Track window state."
  },
  1053: {
      "title": "Previous Permutation With One Swap",
      "slug": "previous-permutation-with-one-swap",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  1054: {
      "title": "Distant Barcodes",
      "slug": "distant-barcodes",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Greedy",
          "Two Pointers",
          "Heap/Priority Queue"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1061: {
      "title": "Lexicographically Smallest Equivalent String",
      "slug": "lexicographically-smallest-equivalent-string",
      "difficulty": "medium",
      "primaryPattern": "Graph",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Graph algorithms - may involve topological sort, cycle detection, union find, or connectivity checks."
  },
  1068: {
      "title": "Product Sales Analysis I",
      "slug": "product-sales-analysis-i",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1070: {
      "title": "Product Sales Analysis III",
      "slug": "product-sales-analysis-iii",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1071: {
      "title": "Greatest Common Divisor of Strings",
      "slug": "greatest-common-divisor-of-strings",
      "difficulty": "easy",
      "primaryPattern": "Math",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships.",
      "lists": [
          "leetcode-75"
      ],
      "category": "Math",
      "patternExplanations": {
          "Math": "If GCD exists, str1 + str2 = str2 + str1. GCD length = gcd(len1, len2)."
      },
      "hints": [
          "If both strings have a common divisor, concatenating them in either order gives same result.",
          "Check if str1 + str2 == str2 + str1. If not, no common divisor.",
          "If yes, the GCD string has length gcd(len(str1), len(str2))."
      ],
      "solution": {
          "approach": "If str1 + str2 != str2 + str1, return ''. Else return str1[0:gcd(len1, len2)].",
          "timeComplexity": "O(n + m)",
          "spaceComplexity": "O(n + m)",
          "keyInsight": "Commutative concatenation implies common divisor exists. GCD of lengths gives divisor length."
      }
  },
  1072: {
      "title": "Flip Columns For Maximum Number of Equal Rows",
      "slug": "flip-columns-for-maximum-number-of-equal-rows",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "DFS"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1073: {
      "title": "Adding Two Negabinary Numbers",
      "slug": "adding-two-negabinary-numbers",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1074: {
      "title": "Number of Submatrices That Sum to Target",
      "slug": "number-of-submatrices-that-sum-to-target",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "DFS"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1075: {
      "title": "Project Employees I",
      "slug": "project-employees-i",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1078: {
      "title": "Occurrences After Bigram",
      "slug": "occurrences-after-bigram",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1079: {
      "title": "Letter Tile Possibilities",
      "slug": "letter-tile-possibilities",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Backtracking"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1080: {
      "title": "Insufficient Nodes in Root to Leaf Paths",
      "slug": "insufficient-nodes-in-root-to-leaf-paths",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Tree Traversal"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  1081: {
      "title": "Smallest Subsequence of Distinct Characters",
      "slug": "smallest-subsequence-of-distinct-characters",
      "difficulty": "medium",
      "primaryPattern": "Stack",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy"
      ],
      "explanation": "LIFO structure for nested patterns, matching pairs, or maintaining monotonic sequences."
  },
  1084: {
      "title": "Sales Analysis III",
      "slug": "sales-analysis-iii",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1089: {
      "title": "Duplicate Zeros",
      "slug": "duplicate-zeros",
      "difficulty": "easy",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  1090: {
      "title": "Largest Values From Labels",
      "slug": "largest-values-from-labels",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Greedy",
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1091: {
      "title": "Shortest Path in Binary Matrix",
      "slug": "shortest-path-in-binary-matrix",
      "difficulty": "medium",
      "primaryPattern": "BFS",
      "acceptablePatterns": [
          "Hash Map",
          "DFS"
      ],
      "explanation": "Breadth-first search - explore level by level using a queue. Ideal for shortest path in unweighted graphs or level-order traversal."
  },
  1092: {
      "title": "Shortest Common Supersequence ",
      "slug": "shortest-common-supersequence",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1093: {
      "title": "Statistics from a Large Sample",
      "slug": "statistics-from-a-large-sample",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1094: {
      "title": "Car Pooling",
      "slug": "car-pooling",
      "difficulty": "medium",
      "primaryPattern": "Heap/Priority Queue",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Maintain ordered access to min/max elements. Useful for k-largest/smallest, merging, or scheduling problems."
  },
  1095: {
      "title": "Find in Mountain Array",
      "slug": "find-in-mountain-array",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  1096: {
      "title": "Brace Expansion II",
      "slug": "brace-expansion-ii",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Backtracking",
          "Stack",
          "BFS",
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1103: {
      "title": "Distribute Candies to People",
      "slug": "distribute-candies-to-people",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1104: {
      "title": "Path In Zigzag Labelled Binary Tree",
      "slug": "path-in-zigzag-labelled-binary-tree",
      "difficulty": "medium",
      "primaryPattern": "Tree Traversal",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Navigate tree structures using inorder, preorder, or postorder traversal. Consider recursive or iterative approaches."
  },
  1105: {
      "title": "Filling Bookcase Shelves",
      "slug": "filling-bookcase-shelves",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1106: {
      "title": "Parsing A Boolean Expression",
      "slug": "parsing-a-boolean-expression",
      "difficulty": "hard",
      "primaryPattern": "Stack",
      "acceptablePatterns": [
          "Hash Map",
          "DFS"
      ],
      "explanation": "LIFO structure for nested patterns, matching pairs, or maintaining monotonic sequences."
  },
  1108: {
      "title": "Defanging an IP Address",
      "slug": "defanging-an-ip-address",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1109: {
      "title": "Corporate Flight Bookings",
      "slug": "corporate-flight-bookings",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1110: {
      "title": "Delete Nodes And Return Forest",
      "slug": "delete-nodes-and-return-forest",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Tree Traversal",
          "DFS"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1111: {
      "title": "Maximum Nesting Depth of Two Valid Parentheses Strings",
      "slug": "maximum-nesting-depth-of-two-valid-parentheses-strings",
      "difficulty": "medium",
      "primaryPattern": "Stack",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "LIFO structure for nested patterns, matching pairs, or maintaining monotonic sequences."
  },
  1114: {
      "title": "Print in Order",
      "slug": "print-in-order",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1115: {
      "title": "Print FooBar Alternately",
      "slug": "print-foobar-alternately",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1116: {
      "title": "Print Zero Even Odd",
      "slug": "print-zero-even-odd",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1117: {
      "title": "Building H2O",
      "slug": "building-h2o",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1122: {
      "title": "Relative Sort Array",
      "slug": "relative-sort-array",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1123: {
      "title": "Lowest Common Ancestor of Deepest Leaves",
      "slug": "lowest-common-ancestor-of-deepest-leaves",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Tree Traversal",
          "DFS",
          "BFS"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1124: {
      "title": "Longest Well-Performing Interval",
      "slug": "longest-well-performing-interval",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Stack"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1125: {
      "title": "Smallest Sufficient Team",
      "slug": "smallest-sufficient-team",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1128: {
      "title": "Number of Equivalent Domino Pairs",
      "slug": "number-of-equivalent-domino-pairs",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1129: {
      "title": "Shortest Path with Alternating Colors",
      "slug": "shortest-path-with-alternating-colors",
      "difficulty": "medium",
      "primaryPattern": "BFS",
      "acceptablePatterns": [
          "Graph"
      ],
      "explanation": "Breadth-first search - explore level by level using a queue. Ideal for shortest path in unweighted graphs or level-order traversal."
  },
  1130: {
      "title": "Minimum Cost Tree From Leaf Values",
      "slug": "minimum-cost-tree-from-leaf-values",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Stack",
          "Greedy"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1131: {
      "title": "Maximum of Absolute Value Expression",
      "slug": "maximum-of-absolute-value-expression",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1137: {
      "title": "N-th Tribonacci Number",
      "slug": "n-th-tribonacci-number",
      "difficulty": "easy",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization.",
      "lists": [
          "leetcode-75"
      ],
      "category": "Dynamic Programming",
      "patternExplanations": {
          "Dynamic Programming": "Like Fibonacci but with 3 terms: T(n) = T(n-1) + T(n-2) + T(n-3)."
      },
      "hints": [
          "T(0) = 0, T(1) = 1, T(2) = 1. For n >= 3, T(n) = T(n-1) + T(n-2) + T(n-3).",
          "Keep track of last three values.",
          "Similar to Fibonacci, just with one more term in the recurrence."
      ],
      "solution": {
          "approach": "Iteratively compute T(n) using T(n) = T(n-1) + T(n-2) + T(n-3). Track last 3 values.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "keyInsight": "Simple DP recurrence. Only need last 3 values, so O(1) space."
      }
  },
  1138: {
      "title": "Alphabet Board Path",
      "slug": "alphabet-board-path",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1139: {
      "title": "Largest 1-Bordered Square",
      "slug": "largest-1-bordered-square",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "DFS"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1140: {
      "title": "Stone Game II",
      "slug": "stone-game-ii",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1141: {
      "title": "User Activity for the Past 30 Days I",
      "slug": "user-activity-for-the-past-30-days-i",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1143: {
      "title": "Longest Common Subsequence",
      "slug": "longest-common-subsequence",
      "difficulty": "medium",
      "lists": [
          "neetcode-150",
          "leetcode-75"
      ],
      "category": "2-D Dynamic Programming",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [],
      "patternExplanations": {
          "Dynamic Programming": "dp[i][j] = LCS of text1[0:i] and text2[0:j]. If chars match, dp[i][j] = dp[i-1][j-1] + 1. Else max(dp[i-1][j], dp[i][j-1])."
      },
      "hints": [
          "Subsequence doesn't need to be contiguous. What's the longest common one?",
          "Compare last characters. If they match, they're part of LCS. If not, try excluding one or the other.",
          "Match: dp[i][j] = 1 + dp[i-1][j-1]. No match: dp[i][j] = max(dp[i-1][j], dp[i][j-1])."
      ],
      "solution": {
          "approach": "2D DP: if text1[i] == text2[j], dp[i][j] = dp[i-1][j-1] + 1, else max(dp[i-1][j], dp[i][j-1]).",
          "timeComplexity": "O(m * n)",
          "spaceComplexity": "O(m * n), can be O(min(m,n))",
          "keyInsight": "Classic 2D DP: match characters or skip one string's character."
      }
  },
  1144: {
      "title": "Decrease Elements To Make Array Zigzag",
      "slug": "decrease-elements-to-make-array-zigzag",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  1145: {
      "title": "Binary Tree Coloring Game",
      "slug": "binary-tree-coloring-game",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Tree Traversal"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  1146: {
      "title": "Snapshot Array",
      "slug": "snapshot-array",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Binary Search"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1147: {
      "title": "Longest Chunked Palindrome Decomposition",
      "slug": "longest-chunked-palindrome-decomposition",
      "difficulty": "hard",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map",
          "Dynamic Programming",
          "Greedy"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  1148: {
      "title": "Article Views I",
      "slug": "article-views-i",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1154: {
      "title": "Day of the Year",
      "slug": "day-of-the-year",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1155: {
      "title": "Number of Dice Rolls With Target Sum",
      "slug": "number-of-dice-rolls-with-target-sum",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1156: {
      "title": "Swap For Longest Repeated Character Substring",
      "slug": "swap-for-longest-repeated-character-substring",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Sliding Window"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1157: {
      "title": "Online Majority Element In Subarray",
      "slug": "online-majority-element-in-subarray",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  1158: {
      "title": "Market Analysis I",
      "slug": "market-analysis-i",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1160: {
      "title": "Find Words That Can Be Formed by Characters",
      "slug": "find-words-that-can-be-formed-by-characters",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1161: {
      "title": "Maximum Level Sum of a Binary Tree",
      "slug": "maximum-level-sum-of-a-binary-tree",
      "difficulty": "medium",
      "lists": [
          "leetcode-75"
      ],
      "category": "Binary Tree - BFS",
      "primaryPattern": "BFS",
      "acceptablePatterns": [
          "DFS"
      ],
      "patternExplanations": {
          "BFS": "Level order traversal. For each level, sum all node values. Track level with maximum sum.",
          "DFS": "Can also use DFS with level parameter, accumulating sums per level in an array."
      },
      "hints": [
          "Find the level (1-indexed) with the largest sum.",
          "BFS processes level by level. Sum each level, track max.",
          "Return smallest level number if there are ties."
      ],
      "solution": {
          "approach": "BFS: for each level, sum values. Track maxSum and corresponding level. Return level.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(w) where w is max width",
          "keyInsight": "BFS naturally groups nodes by level for sum calculation."
      }
  },
  1162: {
      "title": "As Far from Land as Possible",
      "slug": "as-far-from-land-as-possible",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "BFS",
          "DFS"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1163: {
      "title": "Last Substring in Lexicographical Order",
      "slug": "last-substring-in-lexicographical-order",
      "difficulty": "hard",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  1164: {
      "title": "Product Price at a Given Date",
      "slug": "product-price-at-a-given-date",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1169: {
      "title": "Invalid Transactions",
      "slug": "invalid-transactions",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1170: {
      "title": "Compare Strings by Frequency of the Smallest Character",
      "slug": "compare-strings-by-frequency-of-the-smallest-character",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Binary Search",
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1171: {
      "title": "Remove Zero Sum Consecutive Nodes from Linked List",
      "slug": "remove-zero-sum-consecutive-nodes-from-linked-list",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Linked List"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1172: {
      "title": "Dinner Plate Stacks",
      "slug": "dinner-plate-stacks",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Stack",
          "Heap/Priority Queue"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1174: {
      "title": "Immediate Food Delivery II",
      "slug": "immediate-food-delivery-ii",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1175: {
      "title": "Prime Arrangements",
      "slug": "prime-arrangements",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1177: {
      "title": "Can Make Palindrome from Substring",
      "slug": "can-make-palindrome-from-substring",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1178: {
      "title": "Number of Valid Words for Each Puzzle",
      "slug": "number-of-valid-words-for-each-puzzle",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Trie"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1179: {
      "title": "Reformat Department Table",
      "slug": "reformat-department-table",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1184: {
      "title": "Distance Between Bus Stops",
      "slug": "distance-between-bus-stops",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1185: {
      "title": "Day of the Week",
      "slug": "day-of-the-week",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1186: {
      "title": "Maximum Subarray Sum with One Deletion",
      "slug": "maximum-subarray-sum-with-one-deletion",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1187: {
      "title": "Make Array Strictly Increasing",
      "slug": "make-array-strictly-increasing",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Dynamic Programming",
          "Two Pointers"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  1189: {
      "title": "Maximum Number of Balloons",
      "slug": "maximum-number-of-balloons",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1190: {
      "title": "Reverse Substrings Between Each Pair of Parentheses",
      "slug": "reverse-substrings-between-each-pair-of-parentheses",
      "difficulty": "medium",
      "primaryPattern": "Stack",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "LIFO structure for nested patterns, matching pairs, or maintaining monotonic sequences."
  },
  1191: {
      "title": "K-Concatenation Maximum Sum",
      "slug": "k-concatenation-maximum-sum",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1192: {
      "title": "Critical Connections in a Network",
      "slug": "critical-connections-in-a-network",
      "difficulty": "hard",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Graph"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  1193: {
      "title": "Monthly Transactions I",
      "slug": "monthly-transactions-i",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1195: {
      "title": "Fizz Buzz Multithreaded",
      "slug": "fizz-buzz-multithreaded",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1200: {
      "title": "Minimum Absolute Difference",
      "slug": "minimum-absolute-difference",
      "difficulty": "easy",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  1201: {
      "title": "Ugly Number III",
      "slug": "ugly-number-iii",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  1202: {
      "title": "Smallest String With Swaps",
      "slug": "smallest-string-with-swaps",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "DFS",
          "BFS",
          "Graph",
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1203: {
      "title": "Sort Items by Groups Respecting Dependencies",
      "slug": "sort-items-by-groups-respecting-dependencies",
      "difficulty": "hard",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "BFS",
          "Graph"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  1204: {
      "title": "Last Person to Fit in the Bus",
      "slug": "last-person-to-fit-in-the-bus",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1206: {
      "title": "Design Skiplist",
      "slug": "design-skiplist",
      "difficulty": "hard",
      "primaryPattern": "Linked List",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Pointer manipulation for reversing, merging, detecting cycles, or finding intersections in linked structures."
  },
  1207: {
      "title": "Unique Number of Occurrences",
      "slug": "unique-number-of-occurrences",
      "difficulty": "easy",
      "lists": [
          "leetcode-75"
      ],
      "category": "Hash Map / Set",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "patternExplanations": {
          "Hash Map": "Count occurrences with map. Check if all counts are unique using a set."
      },
      "hints": [
          "Count how often each number appears.",
          "Are all the occurrence counts unique?",
          "Put counts in a set. If set size == map size, all counts are unique."
      ],
      "solution": {
          "approach": "Count frequencies with map. Put counts in a set. Return counts.size == set.size.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)",
          "keyInsight": "Map for counting, set for uniqueness check."
      }
  },
  1208: {
      "title": "Get Equal Substrings Within Budget",
      "slug": "get-equal-substrings-within-budget",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Sliding Window"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  1209: {
      "title": "Remove All Adjacent Duplicates in String II",
      "slug": "remove-all-adjacent-duplicates-in-string-ii",
      "difficulty": "medium",
      "primaryPattern": "Stack",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "LIFO structure for nested patterns, matching pairs, or maintaining monotonic sequences."
  },
  1210: {
      "title": "Minimum Moves to Reach Target with Rotations",
      "slug": "minimum-moves-to-reach-target-with-rotations",
      "difficulty": "hard",
      "primaryPattern": "BFS",
      "acceptablePatterns": [
          "Hash Map",
          "DFS"
      ],
      "explanation": "Breadth-first search - explore level by level using a queue. Ideal for shortest path in unweighted graphs or level-order traversal."
  },
  1211: {
      "title": "Queries Quality and Percentage",
      "slug": "queries-quality-and-percentage",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1217: {
      "title": "Minimum Cost to Move Chips to The Same Position",
      "slug": "minimum-cost-to-move-chips-to-the-same-position",
      "difficulty": "easy",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  1218: {
      "title": "Longest Arithmetic Subsequence of Given Difference",
      "slug": "longest-arithmetic-subsequence-of-given-difference",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Dynamic Programming"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1219: {
      "title": "Path with Maximum Gold",
      "slug": "path-with-maximum-gold",
      "difficulty": "medium",
      "primaryPattern": "Backtracking",
      "acceptablePatterns": [
          "Hash Map",
          "DFS"
      ],
      "explanation": "Explore all possible solutions recursively. Build candidates incrementally and abandon paths that cannot lead to solution."
  },
  1220: {
      "title": "Count Vowels Permutation",
      "slug": "count-vowels-permutation",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1221: {
      "title": "Split a String in Balanced Strings",
      "slug": "split-a-string-in-balanced-strings",
      "difficulty": "easy",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  1222: {
      "title": "Queens That Can Attack the King",
      "slug": "queens-that-can-attack-the-king",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  1223: {
      "title": "Dice Roll Simulation",
      "slug": "dice-roll-simulation",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1224: {
      "title": "Maximum Equal Frequency",
      "slug": "maximum-equal-frequency",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1226: {
      "title": "The Dining Philosophers",
      "slug": "the-dining-philosophers",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1227: {
      "title": "Airplane Seat Assignment Probability",
      "slug": "airplane-seat-assignment-probability",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1232: {
      "title": "Check If It Is a Straight Line",
      "slug": "check-if-it-is-a-straight-line",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1233: {
      "title": "Remove Sub-Folders from the Filesystem",
      "slug": "remove-sub-folders-from-the-filesystem",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map",
          "Trie"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  1234: {
      "title": "Replace the Substring for Balanced String",
      "slug": "replace-the-substring-for-balanced-string",
      "difficulty": "medium",
      "primaryPattern": "Sliding Window",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Maintain a window of elements that slides through the array. Expand when adding elements, contract when removing. Track window state."
  },
  1235: {
      "title": "Maximum Profit in Job Scheduling",
      "slug": "maximum-profit-in-job-scheduling",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Dynamic Programming",
          "Two Pointers"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  1237: {
      "title": "Find Positive Integer Solution for a Given Equation",
      "slug": "find-positive-integer-solution-for-a-given-equation",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map",
          "Binary Search"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  1238: {
      "title": "Circular Permutation in Binary Representation",
      "slug": "circular-permutation-in-binary-representation",
      "difficulty": "medium",
      "primaryPattern": "Backtracking",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Explore all possible solutions recursively. Build candidates incrementally and abandon paths that cannot lead to solution."
  },
  1239: {
      "title": "Maximum Length of a Concatenated String with Unique Characters",
      "slug": "maximum-length-of-a-concatenated-string-with-unique-characters",
      "difficulty": "medium",
      "primaryPattern": "Backtracking",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Explore all possible solutions recursively. Build candidates incrementally and abandon paths that cannot lead to solution."
  },
  1240: {
      "title": "Tiling a Rectangle with the Fewest Squares",
      "slug": "tiling-a-rectangle-with-the-fewest-squares",
      "difficulty": "hard",
      "primaryPattern": "Backtracking",
      "acceptablePatterns": [],
      "explanation": "Explore all possible solutions recursively. Build candidates incrementally and abandon paths that cannot lead to solution."
  },
  1247: {
      "title": "Minimum Swaps to Make Strings Equal",
      "slug": "minimum-swaps-to-make-strings-equal",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  1248: {
      "title": "Count Number of Nice Subarrays",
      "slug": "count-number-of-nice-subarrays",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Sliding Window"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1249: {
      "title": "Minimum Remove to Make Valid Parentheses",
      "slug": "minimum-remove-to-make-valid-parentheses",
      "difficulty": "medium",
      "primaryPattern": "Stack",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "LIFO structure for nested patterns, matching pairs, or maintaining monotonic sequences."
  },
  1250: {
      "title": "Check If It Is a Good Array",
      "slug": "check-if-it-is-a-good-array",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1251: {
      "title": "Average Selling Price",
      "slug": "average-selling-price",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1252: {
      "title": "Cells with Odd Values in a Matrix",
      "slug": "cells-with-odd-values-in-a-matrix",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1253: {
      "title": "Reconstruct a 2-Row Binary Matrix",
      "slug": "reconstruct-a-2-row-binary-matrix",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "DFS"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  1254: {
      "title": "Number of Closed Islands",
      "slug": "number-of-closed-islands",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map",
          "BFS",
          "Graph"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  1255: {
      "title": "Maximum Score Words Formed by Letters",
      "slug": "maximum-score-words-formed-by-letters",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Dynamic Programming",
          "Backtracking"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1260: {
      "title": "Shift 2D Grid",
      "slug": "shift-2d-grid",
      "difficulty": "easy",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  1261: {
      "title": "Find Elements in a Contaminated Binary Tree",
      "slug": "find-elements-in-a-contaminated-binary-tree",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Tree Traversal",
          "DFS",
          "BFS"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1262: {
      "title": "Greatest Sum Divisible by Three",
      "slug": "greatest-sum-divisible-by-three",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy",
          "Two Pointers"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1263: {
      "title": "Minimum Moves to Move a Box to Their Target Location",
      "slug": "minimum-moves-to-move-a-box-to-their-target-location",
      "difficulty": "hard",
      "primaryPattern": "BFS",
      "acceptablePatterns": [
          "Hash Map",
          "Heap/Priority Queue",
          "DFS"
      ],
      "explanation": "Breadth-first search - explore level by level using a queue. Ideal for shortest path in unweighted graphs or level-order traversal."
  },
  1266: {
      "title": "Minimum Time Visiting All Points",
      "slug": "minimum-time-visiting-all-points",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1267: {
      "title": "Count Servers that Communicate",
      "slug": "count-servers-that-communicate",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map",
          "BFS",
          "Graph"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  1268: {
      "title": "Search Suggestions System",
      "slug": "search-suggestions-system",
      "difficulty": "medium",
      "primaryPattern": "Trie",
      "acceptablePatterns": [
          "Binary Search"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element.",
      "lists": [
          "leetcode-75"
      ],
      "category": "Trie",
      "patternExplanations": {
          "Trie": "Build trie from products. For each prefix of searchWord, traverse trie and collect up to 3 suggestions.",
          "Binary Search": "Sort products. For each prefix, binary search for first match, take up to 3."
      },
      "hints": [
          "For each prefix of searchWord, find products that start with that prefix.",
          "Trie naturally gives you words with a given prefix.",
          "Or: sort products, binary search for prefix, take first 3 matches."
      ],
      "solution": {
          "approach": "Sort products. For each prefix, binary search to find first match. Collect up to 3 that share prefix.",
          "timeComplexity": "O(n log n + m * n) where m is searchWord length",
          "spaceComplexity": "O(n)",
          "keyInsight": "Sorted array + binary search is simpler than trie for this problem."
      }
  },
  1269: {
      "title": "Number of Ways to Stay in the Same Place After Some Steps",
      "slug": "number-of-ways-to-stay-in-the-same-place-after-some-steps",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1275: {
      "title": "Find Winner on a Tic Tac Toe Game",
      "slug": "find-winner-on-a-tic-tac-toe-game",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "DFS"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1276: {
      "title": "Number of Burgers with No Waste of Ingredients",
      "slug": "number-of-burgers-with-no-waste-of-ingredients",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1277: {
      "title": "Count Square Submatrices with All Ones",
      "slug": "count-square-submatrices-with-all-ones",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "DFS"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1278: {
      "title": "Palindrome Partitioning III",
      "slug": "palindrome-partitioning-iii",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1280: {
      "title": "Students and Examinations",
      "slug": "students-and-examinations",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1281: {
      "title": "Subtract the Product and Sum of Digits of an Integer",
      "slug": "subtract-the-product-and-sum-of-digits-of-an-integer",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1282: {
      "title": "Group the People Given the Group Size They Belong To",
      "slug": "group-the-people-given-the-group-size-they-belong-to",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Greedy"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1283: {
      "title": "Find the Smallest Divisor Given a Threshold",
      "slug": "find-the-smallest-divisor-given-a-threshold",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  1284: {
      "title": "Minimum Number of Flips to Convert Binary Matrix to Zero Matrix",
      "slug": "minimum-number-of-flips-to-convert-binary-matrix-to-zero-matrix",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "BFS",
          "DFS"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1286: {
      "title": "Iterator for Combination",
      "slug": "iterator-for-combination",
      "difficulty": "medium",
      "primaryPattern": "Backtracking",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Explore all possible solutions recursively. Build candidates incrementally and abandon paths that cannot lead to solution."
  },
  1287: {
      "title": "Element Appearing More Than 25% In Sorted Array",
      "slug": "element-appearing-more-than-25-in-sorted-array",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1288: {
      "title": "Remove Covered Intervals",
      "slug": "remove-covered-intervals",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  1289: {
      "title": "Minimum Falling Path Sum II",
      "slug": "minimum-falling-path-sum-ii",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "DFS"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1290: {
      "title": "Convert Binary Number in a Linked List to Integer",
      "slug": "convert-binary-number-in-a-linked-list-to-integer",
      "difficulty": "easy",
      "primaryPattern": "Linked List",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Pointer manipulation for reversing, merging, detecting cycles, or finding intersections in linked structures."
  },
  1291: {
      "title": "Sequential Digits",
      "slug": "sequential-digits",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1292: {
      "title": "Maximum Side Length of a Square with Sum Less than or Equal to Threshold",
      "slug": "maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "DFS"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  1293: {
      "title": "Shortest Path in a Grid with Obstacles Elimination",
      "slug": "shortest-path-in-a-grid-with-obstacles-elimination",
      "difficulty": "hard",
      "primaryPattern": "BFS",
      "acceptablePatterns": [
          "Hash Map",
          "DFS"
      ],
      "explanation": "Breadth-first search - explore level by level using a queue. Ideal for shortest path in unweighted graphs or level-order traversal."
  },
  1295: {
      "title": "Find Numbers with Even Number of Digits",
      "slug": "find-numbers-with-even-number-of-digits",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1296: {
      "title": "Divide Array in Sets of K Consecutive Numbers",
      "slug": "divide-array-in-sets-of-k-consecutive-numbers",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Greedy",
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1297: {
      "title": "Maximum Number of Occurrences of a Substring",
      "slug": "maximum-number-of-occurrences-of-a-substring",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Sliding Window"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1298: {
      "title": "Maximum Candies You Can Get from Boxes",
      "slug": "maximum-candies-you-can-get-from-boxes",
      "difficulty": "hard",
      "primaryPattern": "BFS",
      "acceptablePatterns": [
          "Hash Map",
          "Graph"
      ],
      "explanation": "Breadth-first search - explore level by level using a queue. Ideal for shortest path in unweighted graphs or level-order traversal."
  },
  1299: {
      "title": "Replace Elements with Greatest Element on Right Side",
      "slug": "replace-elements-with-greatest-element-on-right-side",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1300: {
      "title": "Sum of Mutated Array Closest to Target",
      "slug": "sum-of-mutated-array-closest-to-target",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  1301: {
      "title": "Number of Paths with Max Score",
      "slug": "number-of-paths-with-max-score",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "DFS"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1302: {
      "title": "Deepest Leaves Sum",
      "slug": "deepest-leaves-sum",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Tree Traversal",
          "BFS"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  1304: {
      "title": "Find N Unique Integers Sum up to Zero",
      "slug": "find-n-unique-integers-sum-up-to-zero",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1305: {
      "title": "All Elements in Two Binary Search Trees",
      "slug": "all-elements-in-two-binary-search-trees",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Tree Traversal",
          "Two Pointers"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  1306: {
      "title": "Jump Game III",
      "slug": "jump-game-iii",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map",
          "BFS"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  1307: {
      "title": "Verbal Arithmetic Puzzle",
      "slug": "verbal-arithmetic-puzzle",
      "difficulty": "hard",
      "primaryPattern": "Backtracking",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Explore all possible solutions recursively. Build candidates incrementally and abandon paths that cannot lead to solution."
  },
  1309: {
      "title": "Decrypt String from Alphabet to Integer Mapping",
      "slug": "decrypt-string-from-alphabet-to-integer-mapping",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1310: {
      "title": "XOR Queries of a Subarray",
      "slug": "xor-queries-of-a-subarray",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1311: {
      "title": "Get Watched Videos by Your Friends",
      "slug": "get-watched-videos-by-your-friends",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "BFS",
          "Graph",
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1312: {
      "title": "Minimum Insertion Steps to Make a String Palindrome",
      "slug": "minimum-insertion-steps-to-make-a-string-palindrome",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1313: {
      "title": "Decompress Run-Length Encoded List",
      "slug": "decompress-run-length-encoded-list",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1314: {
      "title": "Matrix Block Sum",
      "slug": "matrix-block-sum",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "DFS"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1315: {
      "title": "Sum of Nodes with Even-Valued Grandparent",
      "slug": "sum-of-nodes-with-even-valued-grandparent",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Tree Traversal",
          "BFS"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  1316: {
      "title": "Distinct Echo Substrings",
      "slug": "distinct-echo-substrings",
      "difficulty": "hard",
      "primaryPattern": "Trie",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Prefix tree for efficient string operations. Each node represents a character, paths represent strings."
  },
  1317: {
      "title": "Convert Integer to the Sum of Two No-Zero Integers",
      "slug": "convert-integer-to-the-sum-of-two-no-zero-integers",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1318: {
      "title": "Minimum Flips to Make a OR b Equal to c",
      "slug": "minimum-flips-to-make-a-or-b-equal-to-c",
      "difficulty": "medium",
      "primaryPattern": "Bit Manipulation",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships.",
      "lists": [
          "leetcode-75"
      ],
      "category": "Bit Manipulation",
      "patternExplanations": {
          "Bit Manipulation": "For each bit position, count flips needed to make (a_bit | b_bit) = c_bit."
      },
      "hints": [
          "For each bit position, consider what flips are needed.",
          "If c_bit is 1: at least one of a_bit or b_bit must be 1.",
          "If c_bit is 0: both a_bit and b_bit must be 0. Count 1s that need flipping."
      ],
      "solution": {
          "approach": "For each bit: if c_bit=1 and both a,b bits are 0, flip 1. If c_bit=0, flip each 1 in a,b.",
          "timeComplexity": "O(1) - 32 bits",
          "spaceComplexity": "O(1)",
          "keyInsight": "Analyze each bit independently. c=0 requires both inputs to be 0. c=1 requires at least one 1."
      }
  },
  1319: {
      "title": "Number of Operations to Make Network Connected",
      "slug": "number-of-operations-to-make-network-connected",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "BFS",
          "Graph"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  1320: {
      "title": "Minimum Distance to Type a Word Using Two Fingers",
      "slug": "minimum-distance-to-type-a-word-using-two-fingers",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1321: {
      "title": "Restaurant Growth",
      "slug": "restaurant-growth",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1323: {
      "title": "Maximum 69 Number",
      "slug": "maximum-69-number",
      "difficulty": "easy",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  1324: {
      "title": "Print Words Vertically",
      "slug": "print-words-vertically",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1325: {
      "title": "Delete Leaves With a Given Value",
      "slug": "delete-leaves-with-a-given-value",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Tree Traversal"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  1326: {
      "title": "Minimum Number of Taps to Open to Water a Garden",
      "slug": "minimum-number-of-taps-to-open-to-water-a-garden",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1327: {
      "title": "List the Products Ordered in a Period",
      "slug": "list-the-products-ordered-in-a-period",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1328: {
      "title": "Break a Palindrome",
      "slug": "break-a-palindrome",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  1329: {
      "title": "Sort the Matrix Diagonally",
      "slug": "sort-the-matrix-diagonally",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map",
          "DFS"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  1330: {
      "title": "Reverse Subarray To Maximize Array Value",
      "slug": "reverse-subarray-to-maximize-array-value",
      "difficulty": "hard",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  1331: {
      "title": "Rank Transform of an Array",
      "slug": "rank-transform-of-an-array",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1332: {
      "title": "Remove Palindromic Subsequences",
      "slug": "remove-palindromic-subsequences",
      "difficulty": "easy",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  1333: {
      "title": "Filter Restaurants by Vegan-Friendly, Price and Distance",
      "slug": "filter-restaurants-by-vegan-friendly-price-and-distance",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  1334: {
      "title": "Find the City With the Smallest Number of Neighbors at a Threshold Distance",
      "slug": "find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Graph",
          "BFS"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1335: {
      "title": "Minimum Difficulty of a Job Schedule",
      "slug": "minimum-difficulty-of-a-job-schedule",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1337: {
      "title": "The K Weakest Rows in a Matrix",
      "slug": "the-k-weakest-rows-in-a-matrix",
      "difficulty": "easy",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers",
          "Heap/Priority Queue",
          "DFS"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  1338: {
      "title": "Reduce Array Size to The Half",
      "slug": "reduce-array-size-to-the-half",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Greedy",
          "Two Pointers",
          "Heap/Priority Queue"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1339: {
      "title": "Maximum Product of Splitted Binary Tree",
      "slug": "maximum-product-of-splitted-binary-tree",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Tree Traversal"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  1340: {
      "title": "Jump Game V",
      "slug": "jump-game-v",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1341: {
      "title": "Movie Rating",
      "slug": "movie-rating",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1342: {
      "title": "Number of Steps to Reduce a Number to Zero",
      "slug": "number-of-steps-to-reduce-a-number-to-zero",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1343: {
      "title": "Number of Sub-arrays of Size K and Average Greater than or Equal to Threshold",
      "slug": "number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold",
      "difficulty": "medium",
      "primaryPattern": "Sliding Window",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Maintain a window of elements that slides through the array. Expand when adding elements, contract when removing. Track window state."
  },
  1344: {
      "title": "Angle Between Hands of a Clock",
      "slug": "angle-between-hands-of-a-clock",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1345: {
      "title": "Jump Game IV",
      "slug": "jump-game-iv",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "BFS"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1346: {
      "title": "Check If N and Its Double Exist",
      "slug": "check-if-n-and-its-double-exist",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Two Pointers",
          "Binary Search"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1347: {
      "title": "Minimum Number of Steps to Make Two Strings Anagram",
      "slug": "minimum-number-of-steps-to-make-two-strings-anagram",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1348: {
      "title": "Tweet Counts Per Frequency",
      "slug": "tweet-counts-per-frequency",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Binary Search",
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1349: {
      "title": "Maximum Students Taking Exam",
      "slug": "maximum-students-taking-exam",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "DFS"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1351: {
      "title": "Count Negative Numbers in a Sorted Matrix",
      "slug": "count-negative-numbers-in-a-sorted-matrix",
      "difficulty": "easy",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "DFS"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  1352: {
      "title": "Product of the Last K Numbers",
      "slug": "product-of-the-last-k-numbers",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1353: {
      "title": "Maximum Number of Events That Can Be Attended",
      "slug": "maximum-number-of-events-that-can-be-attended",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers",
          "Heap/Priority Queue"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  1354: {
      "title": "Construct Target Array With Multiple Sums",
      "slug": "construct-target-array-with-multiple-sums",
      "difficulty": "hard",
      "primaryPattern": "Heap/Priority Queue",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Maintain ordered access to min/max elements. Useful for k-largest/smallest, merging, or scheduling problems."
  },
  1356: {
      "title": "Sort Integers by The Number of 1 Bits",
      "slug": "sort-integers-by-the-number-of-1-bits",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1357: {
      "title": "Apply Discount Every n Orders",
      "slug": "apply-discount-every-n-orders",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1358: {
      "title": "Number of Substrings Containing All Three Characters",
      "slug": "number-of-substrings-containing-all-three-characters",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Sliding Window"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1359: {
      "title": "Count All Valid Pickup and Delivery Options",
      "slug": "count-all-valid-pickup-and-delivery-options",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1360: {
      "title": "Number of Days Between Two Dates",
      "slug": "number-of-days-between-two-dates",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1361: {
      "title": "Validate Binary Tree Nodes",
      "slug": "validate-binary-tree-nodes",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Tree Traversal",
          "BFS",
          "Graph"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  1362: {
      "title": "Closest Divisors",
      "slug": "closest-divisors",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1363: {
      "title": "Largest Multiple of Three",
      "slug": "largest-multiple-of-three",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy",
          "Two Pointers"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1365: {
      "title": "How Many Numbers Are Smaller Than the Current Number",
      "slug": "how-many-numbers-are-smaller-than-the-current-number",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1366: {
      "title": "Rank Teams by Votes",
      "slug": "rank-teams-by-votes",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1367: {
      "title": "Linked List in Binary Tree",
      "slug": "linked-list-in-binary-tree",
      "difficulty": "medium",
      "primaryPattern": "Linked List",
      "acceptablePatterns": [
          "Tree Traversal",
          "DFS"
      ],
      "explanation": "Pointer manipulation for reversing, merging, detecting cycles, or finding intersections in linked structures."
  },
  1368: {
      "title": "Minimum Cost to Make at Least One Valid Path in a Grid",
      "slug": "minimum-cost-to-make-at-least-one-valid-path-in-a-grid",
      "difficulty": "hard",
      "primaryPattern": "BFS",
      "acceptablePatterns": [
          "Hash Map",
          "Graph",
          "Heap/Priority Queue",
          "DFS"
      ],
      "explanation": "Breadth-first search - explore level by level using a queue. Ideal for shortest path in unweighted graphs or level-order traversal."
  },
  1370: {
      "title": "Increasing Decreasing String",
      "slug": "increasing-decreasing-string",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1371: {
      "title": "Find the Longest Substring Containing Vowels in Even Counts",
      "slug": "find-the-longest-substring-containing-vowels-in-even-counts",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1372: {
      "title": "Longest ZigZag Path in a Binary Tree",
      "slug": "longest-zigzag-path-in-a-binary-tree",
      "difficulty": "medium",
      "lists": [
          "leetcode-75"
      ],
      "category": "Binary Tree - DFS",
      "primaryPattern": "DFS",
      "acceptablePatterns": [],
      "patternExplanations": {
          "DFS": "DFS tracking direction and current zigzag length. Going opposite direction extends, same direction resets to 1."
      },
      "hints": [
          "ZigZag: go left, then right, then left... alternating directions.",
          "At each node, track: length if we came from left, length if we came from right.",
          "Going left: extend right-path count, reset left-path. Going right: extend left-path, reset right-path."
      ],
      "solution": {
          "approach": "DFS(node, direction, length). Going opposite direction: length+1. Same direction: reset to 1. Track max.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(h)",
          "keyInsight": "Track current zigzag length and direction at each node."
      }
  },
  1373: {
      "title": "Maximum Sum BST in Binary Tree",
      "slug": "maximum-sum-bst-in-binary-tree",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Tree Traversal",
          "DFS"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1374: {
      "title": "Generate a String With Characters That Have Odd Counts",
      "slug": "generate-a-string-with-characters-that-have-odd-counts",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1375: {
      "title": "Number of Times Binary String Is Prefix-Aligned",
      "slug": "number-of-times-binary-string-is-prefix-aligned",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1376: {
      "title": "Time Needed to Inform All Employees",
      "slug": "time-needed-to-inform-all-employees",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Tree Traversal",
          "BFS"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  1377: {
      "title": "Frog Position After T Seconds",
      "slug": "frog-position-after-t-seconds",
      "difficulty": "hard",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Tree Traversal",
          "BFS",
          "Graph"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  1378: {
      "title": "Replace Employee ID With The Unique Identifier",
      "slug": "replace-employee-id-with-the-unique-identifier",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1379: {
      "title": "Find a Corresponding Node of a Binary Tree in a Clone of That Tree",
      "slug": "find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree",
      "difficulty": "easy",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Tree Traversal",
          "BFS"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  1380: {
      "title": "Lucky Numbers in a Matrix",
      "slug": "lucky-numbers-in-a-matrix",
      "difficulty": "easy",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  1381: {
      "title": "Design a Stack With Increment Operation",
      "slug": "design-a-stack-with-increment-operation",
      "difficulty": "medium",
      "primaryPattern": "Stack",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "LIFO structure for nested patterns, matching pairs, or maintaining monotonic sequences."
  },
  1382: {
      "title": "Balance a Binary Search Tree",
      "slug": "balance-a-binary-search-tree",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Binary Search",
          "Tree Traversal",
          "DFS"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  1383: {
      "title": "Maximum Performance of a Team",
      "slug": "maximum-performance-of-a-team",
      "difficulty": "hard",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers",
          "Heap/Priority Queue"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  1385: {
      "title": "Find the Distance Value Between Two Arrays",
      "slug": "find-the-distance-value-between-two-arrays",
      "difficulty": "easy",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map",
          "Binary Search"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  1386: {
      "title": "Cinema Seat Allocation",
      "slug": "cinema-seat-allocation",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Greedy"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1387: {
      "title": "Sort Integers by The Power Value",
      "slug": "sort-integers-by-the-power-value",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Two Pointers"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1388: {
      "title": "Pizza With 3n Slices",
      "slug": "pizza-with-3n-slices",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy",
          "Heap/Priority Queue"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1389: {
      "title": "Create Target Array in the Given Order",
      "slug": "create-target-array-in-the-given-order",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1390: {
      "title": "Four Divisors",
      "slug": "four-divisors",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1391: {
      "title": "Check if There is a Valid Path in a Grid",
      "slug": "check-if-there-is-a-valid-path-in-a-grid",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map",
          "BFS",
          "Graph"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  1392: {
      "title": "Longest Happy Prefix",
      "slug": "longest-happy-prefix",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1393: {
      "title": "Capital Gain/Loss",
      "slug": "capital-gainloss",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1394: {
      "title": "Find Lucky Integer in an Array",
      "slug": "find-lucky-integer-in-an-array",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1395: {
      "title": "Count Number of Teams",
      "slug": "count-number-of-teams",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1396: {
      "title": "Design Underground System",
      "slug": "design-underground-system",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1397: {
      "title": "Find All Good Strings",
      "slug": "find-all-good-strings",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1399: {
      "title": "Count Largest Group",
      "slug": "count-largest-group",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1400: {
      "title": "Construct K Palindrome Strings",
      "slug": "construct-k-palindrome-strings",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Greedy"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1401: {
      "title": "Circle and Rectangle Overlapping",
      "slug": "circle-and-rectangle-overlapping",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1402: {
      "title": "Reducing Dishes",
      "slug": "reducing-dishes",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy",
          "Two Pointers"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1403: {
      "title": "Minimum Subsequence in Non-Increasing Order",
      "slug": "minimum-subsequence-in-non-increasing-order",
      "difficulty": "easy",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  1404: {
      "title": "Number of Steps to Reduce a Number in Binary Representation to One",
      "slug": "number-of-steps-to-reduce-a-number-in-binary-representation-to-one",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1405: {
      "title": "Longest Happy String",
      "slug": "longest-happy-string",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Heap/Priority Queue"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  1406: {
      "title": "Stone Game III",
      "slug": "stone-game-iii",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1407: {
      "title": "Top Travellers",
      "slug": "top-travellers",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1408: {
      "title": "String Matching in an Array",
      "slug": "string-matching-in-an-array",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1409: {
      "title": "Queries on a Permutation With Key",
      "slug": "queries-on-a-permutation-with-key",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1410: {
      "title": "HTML Entity Parser",
      "slug": "html-entity-parser",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1411: {
      "title": "Number of Ways to Paint N × 3 Grid",
      "slug": "number-of-ways-to-paint-n-3-grid",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1413: {
      "title": "Minimum Value to Get Positive Step by Step Sum",
      "slug": "minimum-value-to-get-positive-step-by-step-sum",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1414: {
      "title": "Find the Minimum Number of Fibonacci Numbers Whose Sum Is K",
      "slug": "find-the-minimum-number-of-fibonacci-numbers-whose-sum-is-k",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  1415: {
      "title": "The k-th Lexicographical String of All Happy Strings of Length n",
      "slug": "the-k-th-lexicographical-string-of-all-happy-strings-of-length-n",
      "difficulty": "medium",
      "primaryPattern": "Backtracking",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Explore all possible solutions recursively. Build candidates incrementally and abandon paths that cannot lead to solution."
  },
  1416: {
      "title": "Restore The Array",
      "slug": "restore-the-array",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1417: {
      "title": "Reformat The String",
      "slug": "reformat-the-string",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1418: {
      "title": "Display Table of Food Orders in a Restaurant",
      "slug": "display-table-of-food-orders-in-a-restaurant",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1419: {
      "title": "Minimum Number of Frogs Croaking",
      "slug": "minimum-number-of-frogs-croaking",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1420: {
      "title": "Build Array Where You Can Find The Maximum Exactly K Comparisons",
      "slug": "build-array-where-you-can-find-the-maximum-exactly-k-comparisons",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1422: {
      "title": "Maximum Score After Splitting a String",
      "slug": "maximum-score-after-splitting-a-string",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1423: {
      "title": "Maximum Points You Can Obtain from Cards",
      "slug": "maximum-points-you-can-obtain-from-cards",
      "difficulty": "medium",
      "primaryPattern": "Sliding Window",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Maintain a window of elements that slides through the array. Expand when adding elements, contract when removing. Track window state."
  },
  1424: {
      "title": "Diagonal Traverse II",
      "slug": "diagonal-traverse-ii",
      "difficulty": "medium",
      "primaryPattern": "Heap/Priority Queue",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Maintain ordered access to min/max elements. Useful for k-largest/smallest, merging, or scheduling problems."
  },
  1425: {
      "title": "Constrained Subsequence Sum",
      "slug": "constrained-subsequence-sum",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "BFS",
          "Sliding Window",
          "Heap/Priority Queue"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1431: {
      "title": "Kids With the Greatest Number of Candies",
      "slug": "kids-with-the-greatest-number-of-candies",
      "difficulty": "easy",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships.",
      "lists": [
          "leetcode-75"
      ],
      "category": "Arrays",
      "patternExplanations": {
          "Greedy": "Find max candies. Check if each kid can have greatest (their candies + extra >= max)."
      },
      "hints": [
          "A kid can have the greatest if candies[i] + extraCandies >= max(candies).",
          "Find the maximum candies any kid has.",
          "For each kid, check if adding extra gets them to at least the max."
      ],
      "solution": {
          "approach": "Find max = max(candies). For each kid, result[i] = (candies[i] + extraCandies >= max).",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)",
          "keyInsight": "Simple comparison after finding global maximum."
      }
  },
  1432: {
      "title": "Max Difference You Can Get From Changing an Integer",
      "slug": "max-difference-you-can-get-from-changing-an-integer",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  1433: {
      "title": "Check If a String Can Break Another String",
      "slug": "check-if-a-string-can-break-another-string",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  1434: {
      "title": "Number of Ways to Wear Different Hats to Each Other",
      "slug": "number-of-ways-to-wear-different-hats-to-each-other",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1436: {
      "title": "Destination City",
      "slug": "destination-city",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1437: {
      "title": "Check If All 1's Are at Least Length K Places Away",
      "slug": "check-if-all-1s-are-at-least-length-k-places-away",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1438: {
      "title": "Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit",
      "slug": "longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit",
      "difficulty": "medium",
      "primaryPattern": "Sliding Window",
      "acceptablePatterns": [
          "Hash Map",
          "BFS",
          "Heap/Priority Queue"
      ],
      "explanation": "Maintain a window of elements that slides through the array. Expand when adding elements, contract when removing. Track window state."
  },
  1439: {
      "title": "Find the Kth Smallest Sum of a Matrix With Sorted Rows",
      "slug": "find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Heap/Priority Queue",
          "DFS"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  1441: {
      "title": "Build an Array With Stack Operations",
      "slug": "build-an-array-with-stack-operations",
      "difficulty": "medium",
      "primaryPattern": "Stack",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "LIFO structure for nested patterns, matching pairs, or maintaining monotonic sequences."
  },
  1442: {
      "title": "Count Triplets That Can Form Two Arrays of Equal XOR",
      "slug": "count-triplets-that-can-form-two-arrays-of-equal-xor",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1443: {
      "title": "Minimum Time to Collect All Apples in a Tree",
      "slug": "minimum-time-to-collect-all-apples-in-a-tree",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Tree Traversal",
          "DFS",
          "BFS"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1444: {
      "title": "Number of Ways of Cutting a Pizza",
      "slug": "number-of-ways-of-cutting-a-pizza",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "DFS"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1446: {
      "title": "Consecutive Characters",
      "slug": "consecutive-characters",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1447: {
      "title": "Simplified Fractions",
      "slug": "simplified-fractions",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1448: {
      "title": "Count Good Nodes in Binary Tree",
      "slug": "count-good-nodes-in-binary-tree",
      "difficulty": "medium",
      "lists": [
          "neetcode-150",
          "leetcode-75"
      ],
      "category": "Trees",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "BFS"
      ],
      "patternExplanations": {
          "DFS": "Pass max-so-far down the path. A node is 'good' if its value >= max-so-far. Update max and recurse.",
          "BFS": "Can also use BFS with (node, maxSoFar) pairs, but DFS is more natural for path-based conditions."
      },
      "hints": [
          "A node is 'good' if no node on the path from root has a greater value.",
          "Track the maximum value seen on the path from root to current node.",
          "If current value >= max, it's good. Either way, update max and continue to children."
      ],
      "solution": {
          "approach": "DFS with maxSoFar parameter. If node.val >= maxSoFar, count it. Recurse with max(maxSoFar, node.val).",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(h)",
          "keyInsight": "Path-based conditions naturally use DFS with accumulated state."
      }
  },
  1449: {
      "title": "Form Largest Integer With Digits That Add up to Target",
      "slug": "form-largest-integer-with-digits-that-add-up-to-target",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1450: {
      "title": "Number of Students Doing Homework at a Given Time",
      "slug": "number-of-students-doing-homework-at-a-given-time",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1451: {
      "title": "Rearrange Words in a Sentence",
      "slug": "rearrange-words-in-a-sentence",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  1452: {
      "title": "People Whose List of Favorite Companies Is Not a Subset of Another List",
      "slug": "people-whose-list-of-favorite-companies-is-not-a-subset-of-another-list",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1453: {
      "title": "Maximum Number of Darts Inside of a Circular Dartboard",
      "slug": "maximum-number-of-darts-inside-of-a-circular-dartboard",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1455: {
      "title": "Check If a Word Occurs As a Prefix of Any Word in a Sentence",
      "slug": "check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence",
      "difficulty": "easy",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  1456: {
      "title": "Maximum Number of Vowels in a Substring of Given Length",
      "slug": "maximum-number-of-vowels-in-a-substring-of-given-length",
      "difficulty": "medium",
      "primaryPattern": "Sliding Window",
      "acceptablePatterns": [],
      "explanation": "Maintain a window of elements that slides through the array. Expand when adding elements, contract when removing. Track window state.",
      "lists": [
          "leetcode-75"
      ],
      "category": "Sliding Window",
      "patternExplanations": {
          "Sliding Window": "Fixed window of size k. Count vowels in window. Slide and update count."
      },
      "hints": [
          "Fixed-size sliding window of size k.",
          "Count vowels in initial window. As window slides, update count.",
          "Add new char (if vowel), remove old char (if vowel). Track max count."
      ],
      "solution": {
          "approach": "Count vowels in first k chars. Slide window: subtract leaving char, add entering char (if vowels). Track max.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "keyInsight": "Classic fixed-size sliding window. Efficiently maintain count by adding/subtracting at edges."
      }
  },
  1457: {
      "title": "Pseudo-Palindromic Paths in a Binary Tree",
      "slug": "pseudo-palindromic-paths-in-a-binary-tree",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map",
          "Tree Traversal",
          "BFS"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  1458: {
      "title": "Max Dot Product of Two Subsequences",
      "slug": "max-dot-product-of-two-subsequences",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1460: {
      "title": "Make Two Arrays Equal by Reversing Subarrays",
      "slug": "make-two-arrays-equal-by-reversing-subarrays",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1461: {
      "title": "Check If a String Contains All Binary Codes of Size K",
      "slug": "check-if-a-string-contains-all-binary-codes-of-size-k",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1462: {
      "title": "Course Schedule IV",
      "slug": "course-schedule-iv",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "BFS",
          "Graph"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  1463: {
      "title": "Cherry Pickup II",
      "slug": "cherry-pickup-ii",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "DFS"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1464: {
      "title": "Maximum Product of Two Elements in an Array",
      "slug": "maximum-product-of-two-elements-in-an-array",
      "difficulty": "easy",
      "primaryPattern": "Heap/Priority Queue",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Maintain ordered access to min/max elements. Useful for k-largest/smallest, merging, or scheduling problems."
  },
  1465: {
      "title": "Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts",
      "slug": "maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  1466: {
      "title": "Reorder Routes to Make All Paths Lead to the City Zero",
      "slug": "reorder-routes-to-make-all-paths-lead-to-the-city-zero",
      "difficulty": "medium",
      "lists": [
          "leetcode-75"
      ],
      "category": "Graphs - DFS",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "BFS"
      ],
      "patternExplanations": {
          "DFS": "Build graph with edge direction info. DFS from 0. Count edges pointing away from 0 (need reversal).",
          "BFS": "Same logic with BFS - count outward edges."
      },
      "hints": [
          "Roads are directed. All cities should reach city 0. Minimum changes needed?",
          "From city 0's perspective: edges pointing toward 0 are good, away from 0 need reversal.",
          "DFS from 0. Track edge direction. Count edges going 'wrong way' (away from 0)."
      ],
      "solution": {
          "approach": "Build adjacency with direction marker. DFS from 0. Count edges pointing away (need to flip).",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)",
          "keyInsight": "Reverse perspective: from 0, count edges pointing outward (wrong direction)."
      }
  },
  1467: {
      "title": "Probability of a Two Boxes Having The Same Number of Distinct Balls",
      "slug": "probability-of-a-two-boxes-having-the-same-number-of-distinct-balls",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Backtracking"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1470: {
      "title": "Shuffle the Array",
      "slug": "shuffle-the-array",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1471: {
      "title": "The k Strongest Values in an Array",
      "slug": "the-k-strongest-values-in-an-array",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  1472: {
      "title": "Design Browser History",
      "slug": "design-browser-history",
      "difficulty": "medium",
      "primaryPattern": "Linked List",
      "acceptablePatterns": [
          "Hash Map",
          "Stack"
      ],
      "explanation": "Pointer manipulation for reversing, merging, detecting cycles, or finding intersections in linked structures."
  },
  1473: {
      "title": "Paint House III",
      "slug": "paint-house-iii",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1475: {
      "title": "Final Prices With a Special Discount in a Shop",
      "slug": "final-prices-with-a-special-discount-in-a-shop",
      "difficulty": "easy",
      "primaryPattern": "Stack",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "LIFO structure for nested patterns, matching pairs, or maintaining monotonic sequences."
  },
  1476: {
      "title": "Subrectangle Queries",
      "slug": "subrectangle-queries",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "DFS"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1477: {
      "title": "Find Two Non-overlapping Sub-arrays Each With Target Sum",
      "slug": "find-two-non-overlapping-sub-arrays-each-with-target-sum",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Binary Search",
          "Dynamic Programming",
          "Sliding Window"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1478: {
      "title": "Allocate Mailboxes",
      "slug": "allocate-mailboxes",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1480: {
      "title": "Running Sum of 1d Array",
      "slug": "running-sum-of-1d-array",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1481: {
      "title": "Least Number of Unique Integers after K Removals",
      "slug": "least-number-of-unique-integers-after-k-removals",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Greedy",
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1482: {
      "title": "Minimum Number of Days to Make m Bouquets",
      "slug": "minimum-number-of-days-to-make-m-bouquets",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  1483: {
      "title": "Kth Ancestor of a Tree Node",
      "slug": "kth-ancestor-of-a-tree-node",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Dynamic Programming",
          "Hash Map",
          "Tree Traversal",
          "DFS",
          "BFS"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  1484: {
      "title": "Group Sold Products By The Date",
      "slug": "group-sold-products-by-the-date",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1486: {
      "title": "XOR Operation in an Array",
      "slug": "xor-operation-in-an-array",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1487: {
      "title": "Making File Names Unique",
      "slug": "making-file-names-unique",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1488: {
      "title": "Avoid Flood in The City",
      "slug": "avoid-flood-in-the-city",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Binary Search",
          "Greedy",
          "Heap/Priority Queue"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1489: {
      "title": "Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree",
      "slug": "find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree",
      "difficulty": "hard",
      "primaryPattern": "Graph",
      "acceptablePatterns": [
          "Two Pointers"
      ],
      "explanation": "Graph algorithms - may involve topological sort, cycle detection, union find, or connectivity checks."
  },
  1491: {
      "title": "Average Salary Excluding the Minimum and Maximum Salary",
      "slug": "average-salary-excluding-the-minimum-and-maximum-salary",
      "difficulty": "easy",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  1492: {
      "title": "The kth Factor of n",
      "slug": "the-kth-factor-of-n",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1493: {
      "title": "Longest Subarray of 1's After Deleting One Element",
      "slug": "longest-subarray-of-1s-after-deleting-one-element",
      "difficulty": "medium",
      "lists": [
          "leetcode-75"
      ],
      "category": "Sliding Window",
      "primaryPattern": "Sliding Window",
      "acceptablePatterns": [],
      "patternExplanations": {
          "Sliding Window": "Must delete exactly one element. Window can have at most one 0. Track max window size - 1 (for the deletion)."
      },
      "hints": [
          "You must delete exactly one element. Find longest subarray of 1s after deletion.",
          "Window can contain at most one 0 (that's the element we'll delete).",
          "Like Max Consecutive Ones III with k=1, but always subtract 1 for the required deletion."
      ],
      "solution": {
          "approach": "Sliding window allowing at most 1 zero. Track max (right - left). Answer = max window size since we must delete one.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "keyInsight": "Similar to flipping k=1 zeros, but must delete so result is window size - 1 (or handle all-1s edge case)."
      }
  },
  1494: {
      "title": "Parallel Courses II",
      "slug": "parallel-courses-ii",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Graph"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1496: {
      "title": "Path Crossing",
      "slug": "path-crossing",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1497: {
      "title": "Check If Array Pairs Are Divisible by k",
      "slug": "check-if-array-pairs-are-divisible-by-k",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1498: {
      "title": "Number of Subsequences That Satisfy the Given Sum Condition",
      "slug": "number-of-subsequences-that-satisfy-the-given-sum-condition",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map",
          "Binary Search"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  1499: {
      "title": "Max Value of Equation",
      "slug": "max-value-of-equation",
      "difficulty": "hard",
      "primaryPattern": "Sliding Window",
      "acceptablePatterns": [
          "Hash Map",
          "BFS",
          "Heap/Priority Queue"
      ],
      "explanation": "Maintain a window of elements that slides through the array. Expand when adding elements, contract when removing. Track window state."
  },
  1502: {
      "title": "Can Make Arithmetic Progression From Sequence",
      "slug": "can-make-arithmetic-progression-from-sequence",
      "difficulty": "easy",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  1503: {
      "title": "Last Moment Before All Ants Fall Out of a Plank",
      "slug": "last-moment-before-all-ants-fall-out-of-a-plank",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1504: {
      "title": "Count Submatrices With All Ones",
      "slug": "count-submatrices-with-all-ones",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Stack",
          "DFS"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1505: {
      "title": "Minimum Possible Integer After at Most K Adjacent Swaps On Digits",
      "slug": "minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits",
      "difficulty": "hard",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  1507: {
      "title": "Reformat Date",
      "slug": "reformat-date",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1508: {
      "title": "Range Sum of Sorted Subarray Sums",
      "slug": "range-sum-of-sorted-subarray-sums",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map",
          "Binary Search"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  1509: {
      "title": "Minimum Difference Between Largest and Smallest Value in Three Moves",
      "slug": "minimum-difference-between-largest-and-smallest-value-in-three-moves",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  1510: {
      "title": "Stone Game IV",
      "slug": "stone-game-iv",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1512: {
      "title": "Number of Good Pairs",
      "slug": "number-of-good-pairs",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1513: {
      "title": "Number of Substrings With Only 1s",
      "slug": "number-of-substrings-with-only-1s",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1514: {
      "title": "Path with Maximum Probability",
      "slug": "path-with-maximum-probability",
      "difficulty": "medium",
      "primaryPattern": "Heap/Priority Queue",
      "acceptablePatterns": [
          "Hash Map",
          "Graph",
          "BFS"
      ],
      "explanation": "Maintain ordered access to min/max elements. Useful for k-largest/smallest, merging, or scheduling problems."
  },
  1515: {
      "title": "Best Position for a Service Centre",
      "slug": "best-position-for-a-service-centre",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1517: {
      "title": "Find Users With Valid E-Mails",
      "slug": "find-users-with-valid-e-mails",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1518: {
      "title": "Water Bottles",
      "slug": "water-bottles",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1519: {
      "title": "Number of Nodes in the Sub-Tree With the Same Label",
      "slug": "number-of-nodes-in-the-sub-tree-with-the-same-label",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Tree Traversal",
          "DFS",
          "BFS"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1520: {
      "title": "Maximum Number of Non-Overlapping Substrings",
      "slug": "maximum-number-of-non-overlapping-substrings",
      "difficulty": "hard",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  1521: {
      "title": "Find a Value of a Mysterious Function Closest to Target",
      "slug": "find-a-value-of-a-mysterious-function-closest-to-target",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  1523: {
      "title": "Count Odd Numbers in an Interval Range",
      "slug": "count-odd-numbers-in-an-interval-range",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1524: {
      "title": "Number of Sub-arrays With Odd Sum",
      "slug": "number-of-sub-arrays-with-odd-sum",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1525: {
      "title": "Number of Good Ways to Split a String",
      "slug": "number-of-good-ways-to-split-a-string",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Dynamic Programming"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1526: {
      "title": "Minimum Number of Increments on Subarrays to Form a Target Array",
      "slug": "minimum-number-of-increments-on-subarrays-to-form-a-target-array",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Stack",
          "Greedy"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1527: {
      "title": "Patients With a Condition",
      "slug": "patients-with-a-condition",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1528: {
      "title": "Shuffle String",
      "slug": "shuffle-string",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1529: {
      "title": "Minimum Suffix Flips",
      "slug": "minimum-suffix-flips",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  1530: {
      "title": "Number of Good Leaf Nodes Pairs",
      "slug": "number-of-good-leaf-nodes-pairs",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Tree Traversal"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  1531: {
      "title": "String Compression II",
      "slug": "string-compression-ii",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1534: {
      "title": "Count Good Triplets",
      "slug": "count-good-triplets",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1535: {
      "title": "Find the Winner of an Array Game",
      "slug": "find-the-winner-of-an-array-game",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1536: {
      "title": "Minimum Swaps to Arrange a Binary Grid",
      "slug": "minimum-swaps-to-arrange-a-binary-grid",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "DFS"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  1537: {
      "title": "Get the Maximum Score",
      "slug": "get-the-maximum-score",
      "difficulty": "hard",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map",
          "Dynamic Programming",
          "Greedy"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  1539: {
      "title": "Kth Missing Positive Number",
      "slug": "kth-missing-positive-number",
      "difficulty": "easy",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  1540: {
      "title": "Can Convert String in K Moves",
      "slug": "can-convert-string-in-k-moves",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1541: {
      "title": "Minimum Insertions to Balance a Parentheses String",
      "slug": "minimum-insertions-to-balance-a-parentheses-string",
      "difficulty": "medium",
      "primaryPattern": "Stack",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy"
      ],
      "explanation": "LIFO structure for nested patterns, matching pairs, or maintaining monotonic sequences."
  },
  1542: {
      "title": "Find Longest Awesome Substring",
      "slug": "find-longest-awesome-substring",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1544: {
      "title": "Make The String Great",
      "slug": "make-the-string-great",
      "difficulty": "easy",
      "primaryPattern": "Stack",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "LIFO structure for nested patterns, matching pairs, or maintaining monotonic sequences."
  },
  1545: {
      "title": "Find Kth Bit in Nth Binary String",
      "slug": "find-kth-bit-in-nth-binary-string",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  1546: {
      "title": "Maximum Number of Non-Overlapping Subarrays With Sum Equals Target",
      "slug": "maximum-number-of-non-overlapping-subarrays-with-sum-equals-target",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Greedy"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1547: {
      "title": "Minimum Cost to Cut a Stick",
      "slug": "minimum-cost-to-cut-a-stick",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1550: {
      "title": "Three Consecutive Odds",
      "slug": "three-consecutive-odds",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1551: {
      "title": "Minimum Operations to Make Array Equal",
      "slug": "minimum-operations-to-make-array-equal",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1552: {
      "title": "Magnetic Force Between Two Balls",
      "slug": "magnetic-force-between-two-balls",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  1553: {
      "title": "Minimum Number of Days to Eat N Oranges",
      "slug": "minimum-number-of-days-to-eat-n-oranges",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1556: {
      "title": "Thousand Separator",
      "slug": "thousand-separator",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1557: {
      "title": "Minimum Number of Vertices to Reach All Nodes",
      "slug": "minimum-number-of-vertices-to-reach-all-nodes",
      "difficulty": "medium",
      "primaryPattern": "Graph",
      "acceptablePatterns": [],
      "explanation": "Graph algorithms - may involve topological sort, cycle detection, union find, or connectivity checks."
  },
  1558: {
      "title": "Minimum Numbers of Function Calls to Make Target Array",
      "slug": "minimum-numbers-of-function-calls-to-make-target-array",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  1559: {
      "title": "Detect Cycles in 2D Grid",
      "slug": "detect-cycles-in-2d-grid",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map",
          "BFS",
          "Graph"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  1560: {
      "title": "Most Visited Sector in  a Circular Track",
      "slug": "most-visited-sector-in-a-circular-track",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1561: {
      "title": "Maximum Number of Coins You Can Get",
      "slug": "maximum-number-of-coins-you-can-get",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  1562: {
      "title": "Find Latest Group of Size M",
      "slug": "find-latest-group-of-size-m",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Binary Search"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1563: {
      "title": "Stone Game V",
      "slug": "stone-game-v",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1566: {
      "title": "Detect Pattern of Length M Repeated K or More Times",
      "slug": "detect-pattern-of-length-m-repeated-k-or-more-times",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1567: {
      "title": "Maximum Length of Subarray With Positive Product",
      "slug": "maximum-length-of-subarray-with-positive-product",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1568: {
      "title": "Minimum Number of Days to Disconnect Island",
      "slug": "minimum-number-of-days-to-disconnect-island",
      "difficulty": "hard",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map",
          "BFS"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  1569: {
      "title": "Number of Ways to Reorder Array to Get Same BST",
      "slug": "number-of-ways-to-reorder-array-to-get-same-bst",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Binary Search",
          "Tree Traversal",
          "Graph"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1572: {
      "title": "Matrix Diagonal Sum",
      "slug": "matrix-diagonal-sum",
      "difficulty": "easy",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  1573: {
      "title": "Number of Ways to Split a String",
      "slug": "number-of-ways-to-split-a-string",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1574: {
      "title": "Shortest Subarray to be Removed to Make Array Sorted",
      "slug": "shortest-subarray-to-be-removed-to-make-array-sorted",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map",
          "Binary Search",
          "Stack"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  1575: {
      "title": "Count All Possible Routes",
      "slug": "count-all-possible-routes",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1576: {
      "title": "Replace All ?'s to Avoid Consecutive Repeating Characters",
      "slug": "replace-all-s-to-avoid-consecutive-repeating-characters",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1577: {
      "title": "Number of Ways Where Square of Number Is Equal to Product of Two Numbers",
      "slug": "number-of-ways-where-square-of-number-is-equal-to-product-of-two-numbers",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1578: {
      "title": "Minimum Time to Make Rope Colorful",
      "slug": "minimum-time-to-make-rope-colorful",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1579: {
      "title": "Remove Max Number of Edges to Keep Graph Fully Traversable",
      "slug": "remove-max-number-of-edges-to-keep-graph-fully-traversable",
      "difficulty": "hard",
      "primaryPattern": "Graph",
      "acceptablePatterns": [],
      "explanation": "Graph algorithms - may involve topological sort, cycle detection, union find, or connectivity checks."
  },
  1581: {
      "title": "Customer Who Visited but Did Not Make Any Transactions",
      "slug": "customer-who-visited-but-did-not-make-any-transactions",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1582: {
      "title": "Special Positions in a Binary Matrix",
      "slug": "special-positions-in-a-binary-matrix",
      "difficulty": "easy",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  1583: {
      "title": "Count Unhappy Friends",
      "slug": "count-unhappy-friends",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1584: {
      "title": "Min Cost to Connect All Points",
      "slug": "min-cost-to-connect-all-points",
      "difficulty": "medium",
      "primaryPattern": "Union Find",
      "acceptablePatterns": [
          "Heap"
      ],
      "explanation": "Graph algorithms - may involve topological sort, cycle detection, union find, or connectivity checks.",
      "lists": [
          "neetcode-150"
      ],
      "category": "Graphs",
      "patternExplanations": {
          "Union Find": "Kruskal's MST: sort all edges by weight, add edges that connect different components.",
          "Heap": "Prim's MST: start from any node, greedily add cheapest edge to unvisited node."
      },
      "hints": [
          "This is Minimum Spanning Tree with Manhattan distance as edge weight.",
          "All pairs of points are potential edges. Sort by distance.",
          "Kruskal's: sort edges, union-find to add edges not creating cycle. Stop at n-1 edges."
      ],
      "solution": {
          "approach": "Generate all O(n^2) edges with Manhattan distance. Sort by weight. Kruskal's with union-find.",
          "timeComplexity": "O(n^2 log n)",
          "spaceComplexity": "O(n^2)",
          "keyInsight": "MST problem. Kruskal's is straightforward when all edges are enumerable."
      }
  },
  1585: {
      "title": "Check If String Is Transformable With Substring Sort Operations",
      "slug": "check-if-string-is-transformable-with-substring-sort-operations",
      "difficulty": "hard",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  1587: {
      "title": "Bank Account Summary II",
      "slug": "bank-account-summary-ii",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1588: {
      "title": "Sum of All Odd Length Subarrays",
      "slug": "sum-of-all-odd-length-subarrays",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1589: {
      "title": "Maximum Sum Obtained of Any Permutation",
      "slug": "maximum-sum-obtained-of-any-permutation",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  1590: {
      "title": "Make Sum Divisible by P",
      "slug": "make-sum-divisible-by-p",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1591: {
      "title": "Strange Printer II",
      "slug": "strange-printer-ii",
      "difficulty": "hard",
      "primaryPattern": "Graph",
      "acceptablePatterns": [
          "Hash Map",
          "DFS"
      ],
      "explanation": "Graph algorithms - may involve topological sort, cycle detection, union find, or connectivity checks."
  },
  1592: {
      "title": "Rearrange Spaces Between Words",
      "slug": "rearrange-spaces-between-words",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1593: {
      "title": "Split a String Into the Max Number of Unique Substrings",
      "slug": "split-a-string-into-the-max-number-of-unique-substrings",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Backtracking"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1594: {
      "title": "Maximum Non Negative Product in a Matrix",
      "slug": "maximum-non-negative-product-in-a-matrix",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "DFS"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1595: {
      "title": "Minimum Cost to Connect Two Groups of Points",
      "slug": "minimum-cost-to-connect-two-groups-of-points",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "DFS"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1598: {
      "title": "Crawler Log Folder",
      "slug": "crawler-log-folder",
      "difficulty": "easy",
      "primaryPattern": "Stack",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "LIFO structure for nested patterns, matching pairs, or maintaining monotonic sequences."
  },
  1599: {
      "title": "Maximum Profit of Operating a Centennial Wheel",
      "slug": "maximum-profit-of-operating-a-centennial-wheel",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1600: {
      "title": "Throne Inheritance",
      "slug": "throne-inheritance",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Tree Traversal",
          "DFS"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1601: {
      "title": "Maximum Number of Achievable Transfer Requests",
      "slug": "maximum-number-of-achievable-transfer-requests",
      "difficulty": "hard",
      "primaryPattern": "Backtracking",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Explore all possible solutions recursively. Build candidates incrementally and abandon paths that cannot lead to solution."
  },
  1603: {
      "title": "Design Parking System",
      "slug": "design-parking-system",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1604: {
      "title": "Alert Using Same Key-Card Three or More Times in a One Hour Period",
      "slug": "alert-using-same-key-card-three-or-more-times-in-a-one-hour-period",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1605: {
      "title": "Find Valid Matrix Given Row and Column Sums",
      "slug": "find-valid-matrix-given-row-and-column-sums",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "DFS"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  1606: {
      "title": "Find Servers That Handled Most Number of Requests",
      "slug": "find-servers-that-handled-most-number-of-requests",
      "difficulty": "hard",
      "primaryPattern": "Heap/Priority Queue",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Maintain ordered access to min/max elements. Useful for k-largest/smallest, merging, or scheduling problems."
  },
  1608: {
      "title": "Special Array With X Elements Greater Than or Equal X",
      "slug": "special-array-with-x-elements-greater-than-or-equal-x",
      "difficulty": "easy",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  1609: {
      "title": "Even Odd Tree",
      "slug": "even-odd-tree",
      "difficulty": "medium",
      "primaryPattern": "BFS",
      "acceptablePatterns": [
          "Tree Traversal"
      ],
      "explanation": "Breadth-first search - explore level by level using a queue. Ideal for shortest path in unweighted graphs or level-order traversal."
  },
  1610: {
      "title": "Maximum Number of Visible Points",
      "slug": "maximum-number-of-visible-points",
      "difficulty": "hard",
      "primaryPattern": "Sliding Window",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Maintain a window of elements that slides through the array. Expand when adding elements, contract when removing. Track window state."
  },
  1611: {
      "title": "Minimum One Bit Operations to Make Integers Zero",
      "slug": "minimum-one-bit-operations-to-make-integers-zero",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1614: {
      "title": "Maximum Nesting Depth of the Parentheses",
      "slug": "maximum-nesting-depth-of-the-parentheses",
      "difficulty": "easy",
      "primaryPattern": "Stack",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "LIFO structure for nested patterns, matching pairs, or maintaining monotonic sequences."
  },
  1615: {
      "title": "Maximal Network Rank",
      "slug": "maximal-network-rank",
      "difficulty": "medium",
      "primaryPattern": "Graph",
      "acceptablePatterns": [],
      "explanation": "Graph algorithms - may involve topological sort, cycle detection, union find, or connectivity checks."
  },
  1616: {
      "title": "Split Two Strings to Make Palindrome",
      "slug": "split-two-strings-to-make-palindrome",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  1617: {
      "title": "Count Subtrees With Max Distance Between Cities",
      "slug": "count-subtrees-with-max-distance-between-cities",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Tree Traversal"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1619: {
      "title": "Mean of Array After Removing Some Elements",
      "slug": "mean-of-array-after-removing-some-elements",
      "difficulty": "easy",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  1620: {
      "title": "Coordinate With Maximum Network Quality",
      "slug": "coordinate-with-maximum-network-quality",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1621: {
      "title": "Number of Sets of K Non-Overlapping Line Segments",
      "slug": "number-of-sets-of-k-non-overlapping-line-segments",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1622: {
      "title": "Fancy Sequence",
      "slug": "fancy-sequence",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1624: {
      "title": "Largest Substring Between Two Equal Characters",
      "slug": "largest-substring-between-two-equal-characters",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1625: {
      "title": "Lexicographically Smallest String After Applying Operations",
      "slug": "lexicographically-smallest-string-after-applying-operations",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map",
          "BFS"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  1626: {
      "title": "Best Team With No Conflicts",
      "slug": "best-team-with-no-conflicts",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1627: {
      "title": "Graph Connectivity With Threshold",
      "slug": "graph-connectivity-with-threshold",
      "difficulty": "hard",
      "primaryPattern": "Graph",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Graph algorithms - may involve topological sort, cycle detection, union find, or connectivity checks."
  },
  1629: {
      "title": "Slowest Key",
      "slug": "slowest-key",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1630: {
      "title": "Arithmetic Subarrays",
      "slug": "arithmetic-subarrays",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1631: {
      "title": "Path With Minimum Effort",
      "slug": "path-with-minimum-effort",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "DFS",
          "BFS",
          "Graph",
          "Heap/Priority Queue"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  1632: {
      "title": "Rank Transform of a Matrix",
      "slug": "rank-transform-of-a-matrix",
      "difficulty": "hard",
      "primaryPattern": "Graph",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers",
          "DFS"
      ],
      "explanation": "Graph algorithms - may involve topological sort, cycle detection, union find, or connectivity checks."
  },
  1633: {
      "title": "Percentage of Users Attended a Contest",
      "slug": "percentage-of-users-attended-a-contest",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1636: {
      "title": "Sort Array by Increasing Frequency",
      "slug": "sort-array-by-increasing-frequency",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1637: {
      "title": "Widest Vertical Area Between Two Points Containing No Points",
      "slug": "widest-vertical-area-between-two-points-containing-no-points",
      "difficulty": "easy",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  1638: {
      "title": "Count Substrings That Differ by One Character",
      "slug": "count-substrings-that-differ-by-one-character",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Dynamic Programming"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1639: {
      "title": "Number of Ways to Form a Target String Given a Dictionary",
      "slug": "number-of-ways-to-form-a-target-string-given-a-dictionary",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1640: {
      "title": "Check Array Formation Through Concatenation",
      "slug": "check-array-formation-through-concatenation",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1641: {
      "title": "Count Sorted Vowel Strings",
      "slug": "count-sorted-vowel-strings",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1642: {
      "title": "Furthest Building You Can Reach",
      "slug": "furthest-building-you-can-reach",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Heap/Priority Queue"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  1643: {
      "title": "Kth Smallest Instructions",
      "slug": "kth-smallest-instructions",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1646: {
      "title": "Get Maximum in Generated Array",
      "slug": "get-maximum-in-generated-array",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1647: {
      "title": "Minimum Deletions to Make Character Frequencies Unique",
      "slug": "minimum-deletions-to-make-character-frequencies-unique",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Greedy",
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1648: {
      "title": "Sell Diminishing-Valued Colored Balls",
      "slug": "sell-diminishing-valued-colored-balls",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy",
          "Two Pointers",
          "Heap/Priority Queue"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  1649: {
      "title": "Create Sorted Array through Instructions",
      "slug": "create-sorted-array-through-instructions",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  1652: {
      "title": "Defuse the Bomb",
      "slug": "defuse-the-bomb",
      "difficulty": "easy",
      "primaryPattern": "Sliding Window",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Maintain a window of elements that slides through the array. Expand when adding elements, contract when removing. Track window state."
  },
  1653: {
      "title": "Minimum Deletions to Make String Balanced",
      "slug": "minimum-deletions-to-make-string-balanced",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Stack"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1654: {
      "title": "Minimum Jumps to Reach Home",
      "slug": "minimum-jumps-to-reach-home",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "BFS"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1655: {
      "title": "Distribute Repeating Integers",
      "slug": "distribute-repeating-integers",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Backtracking"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1656: {
      "title": "Design an Ordered Stream",
      "slug": "design-an-ordered-stream",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1657: {
      "title": "Determine if Two Strings Are Close",
      "slug": "determine-if-two-strings-are-close",
      "difficulty": "medium",
      "lists": [
          "leetcode-75"
      ],
      "category": "Hash Map / Set",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "patternExplanations": {
          "Hash Map": "Two strings are close if: 1) same character set, 2) same multiset of frequencies. Count chars, compare sets and sorted frequency lists."
      },
      "hints": [
          "Operation 1: swap adjacent. Operation 2: transform all x's to y's and vice versa.",
          "Swapping can rearrange, so order doesn't matter. Transforming swaps frequencies between characters.",
          "Need: same characters present, and same frequency distribution (sorted frequencies match)."
      ],
      "solution": {
          "approach": "Count chars in both. Check same character set. Check sorted frequency arrays are equal.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1) - at most 26 chars",
          "keyInsight": "Transform swaps frequencies, so frequency multisets must match."
      }
  },
  1658: {
      "title": "Minimum Operations to Reduce X to Zero",
      "slug": "minimum-operations-to-reduce-x-to-zero",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Binary Search",
          "Sliding Window"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1659: {
      "title": "Maximize Grid Happiness",
      "slug": "maximize-grid-happiness",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1661: {
      "title": "Average Time of Process per Machine",
      "slug": "average-time-of-process-per-machine",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1662: {
      "title": "Check If Two String Arrays are Equivalent",
      "slug": "check-if-two-string-arrays-are-equivalent",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1663: {
      "title": "Smallest String With A Given Numeric Value",
      "slug": "smallest-string-with-a-given-numeric-value",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  1664: {
      "title": "Ways to Make a Fair Array",
      "slug": "ways-to-make-a-fair-array",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1665: {
      "title": "Minimum Initial Energy to Finish Tasks",
      "slug": "minimum-initial-energy-to-finish-tasks",
      "difficulty": "hard",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  1667: {
      "title": "Fix Names in a Table",
      "slug": "fix-names-in-a-table",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1668: {
      "title": "Maximum Repeating Substring",
      "slug": "maximum-repeating-substring",
      "difficulty": "easy",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1669: {
      "title": "Merge In Between Linked Lists",
      "slug": "merge-in-between-linked-lists",
      "difficulty": "medium",
      "primaryPattern": "Linked List",
      "acceptablePatterns": [],
      "explanation": "Pointer manipulation for reversing, merging, detecting cycles, or finding intersections in linked structures."
  },
  1670: {
      "title": "Design Front Middle Back Queue",
      "slug": "design-front-middle-back-queue",
      "difficulty": "medium",
      "primaryPattern": "Linked List",
      "acceptablePatterns": [
          "Hash Map",
          "BFS"
      ],
      "explanation": "Pointer manipulation for reversing, merging, detecting cycles, or finding intersections in linked structures."
  },
  1671: {
      "title": "Minimum Number of Removals to Make Mountain Array",
      "slug": "minimum-number-of-removals-to-make-mountain-array",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Dynamic Programming",
          "Greedy"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  1672: {
      "title": "Richest Customer Wealth",
      "slug": "richest-customer-wealth",
      "difficulty": "easy",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  1673: {
      "title": "Find the Most Competitive Subsequence",
      "slug": "find-the-most-competitive-subsequence",
      "difficulty": "medium",
      "primaryPattern": "Stack",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy"
      ],
      "explanation": "LIFO structure for nested patterns, matching pairs, or maintaining monotonic sequences."
  },
  1674: {
      "title": "Minimum Moves to Make Array Complementary",
      "slug": "minimum-moves-to-make-array-complementary",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1675: {
      "title": "Minimize Deviation in Array",
      "slug": "minimize-deviation-in-array",
      "difficulty": "hard",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Heap/Priority Queue"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  1678: {
      "title": "Goal Parser Interpretation",
      "slug": "goal-parser-interpretation",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1679: {
      "title": "Max Number of K-Sum Pairs",
      "slug": "max-number-of-k-sum-pairs",
      "difficulty": "medium",
      "lists": [
          "leetcode-75"
      ],
      "category": "Two Pointers",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "patternExplanations": {
          "Two Pointers": "Sort array. Two pointers from ends. If sum = k, pair found. If sum < k, move left up. If sum > k, move right down.",
          "Hash Map": "For each number, check if complement (k - num) exists in map. If yes, pair. Track counts for duplicates."
      },
      "hints": [
          "Find pairs that sum to k. Each element can be used once.",
          "Sorting + two pointers works like Two Sum II.",
          "Or use hash map: for each num, check if k-num is available, then remove both."
      ],
      "solution": {
          "approach": "Sort. Two pointers: if sum == k, count++, move both. If < k, move left. If > k, move right.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1) if sorting in place",
          "keyInsight": "Sorted two-pointer for pair sum is efficient and straightforward."
      }
  },
  1680: {
      "title": "Concatenation of Consecutive Binary Numbers",
      "slug": "concatenation-of-consecutive-binary-numbers",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1681: {
      "title": "Minimum Incompatibility",
      "slug": "minimum-incompatibility",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1683: {
      "title": "Invalid Tweets",
      "slug": "invalid-tweets",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1684: {
      "title": "Count the Number of Consistent Strings",
      "slug": "count-the-number-of-consistent-strings",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1685: {
      "title": "Sum of Absolute Differences in a Sorted Array",
      "slug": "sum-of-absolute-differences-in-a-sorted-array",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1686: {
      "title": "Stone Game VI",
      "slug": "stone-game-vi",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers",
          "Heap/Priority Queue"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  1687: {
      "title": "Delivering Boxes from Storage to Ports",
      "slug": "delivering-boxes-from-storage-to-ports",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "BFS",
          "Heap/Priority Queue",
          "Sliding Window"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1688: {
      "title": "Count of Matches in Tournament",
      "slug": "count-of-matches-in-tournament",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1689: {
      "title": "Partitioning Into Minimum Number Of Deci-Binary Numbers",
      "slug": "partitioning-into-minimum-number-of-deci-binary-numbers",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  1690: {
      "title": "Stone Game VII",
      "slug": "stone-game-vii",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1691: {
      "title": "Maximum Height by Stacking Cuboids ",
      "slug": "maximum-height-by-stacking-cuboids",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1693: {
      "title": "Daily Leads and Partners",
      "slug": "daily-leads-and-partners",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1694: {
      "title": "Reformat Phone Number",
      "slug": "reformat-phone-number",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1695: {
      "title": "Maximum Erasure Value",
      "slug": "maximum-erasure-value",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Sliding Window"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1696: {
      "title": "Jump Game VI",
      "slug": "jump-game-vi",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "BFS",
          "Heap/Priority Queue",
          "Sliding Window"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1697: {
      "title": "Checking Existence of Edge Length Limited Paths",
      "slug": "checking-existence-of-edge-length-limited-paths",
      "difficulty": "hard",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map",
          "Graph"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  1700: {
      "title": "Number of Students Unable to Eat Lunch",
      "slug": "number-of-students-unable-to-eat-lunch",
      "difficulty": "easy",
      "primaryPattern": "Stack",
      "acceptablePatterns": [
          "Hash Map",
          "BFS"
      ],
      "explanation": "LIFO structure for nested patterns, matching pairs, or maintaining monotonic sequences."
  },
  1701: {
      "title": "Average Waiting Time",
      "slug": "average-waiting-time",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1702: {
      "title": "Maximum Binary String After Change",
      "slug": "maximum-binary-string-after-change",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  1703: {
      "title": "Minimum Adjacent Swaps for K Consecutive Ones",
      "slug": "minimum-adjacent-swaps-for-k-consecutive-ones",
      "difficulty": "hard",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Sliding Window"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  1704: {
      "title": "Determine if String Halves Are Alike",
      "slug": "determine-if-string-halves-are-alike",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1705: {
      "title": "Maximum Number of Eaten Apples",
      "slug": "maximum-number-of-eaten-apples",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Heap/Priority Queue"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  1706: {
      "title": "Where Will the Ball Fall",
      "slug": "where-will-the-ball-fall",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  1707: {
      "title": "Maximum XOR With an Element From Array",
      "slug": "maximum-xor-with-an-element-from-array",
      "difficulty": "hard",
      "primaryPattern": "Trie",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Prefix tree for efficient string operations. Each node represents a character, paths represent strings."
  },
  1710: {
      "title": "Maximum Units on a Truck",
      "slug": "maximum-units-on-a-truck",
      "difficulty": "easy",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  1711: {
      "title": "Count Good Meals",
      "slug": "count-good-meals",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1712: {
      "title": "Ways to Split Array Into Three Subarrays",
      "slug": "ways-to-split-array-into-three-subarrays",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map",
          "Binary Search"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  1713: {
      "title": "Minimum Operations to Make a Subsequence",
      "slug": "minimum-operations-to-make-a-subsequence",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Binary Search",
          "Greedy"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1716: {
      "title": "Calculate Money in Leetcode Bank",
      "slug": "calculate-money-in-leetcode-bank",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1717: {
      "title": "Maximum Score From Removing Substrings",
      "slug": "maximum-score-from-removing-substrings",
      "difficulty": "medium",
      "primaryPattern": "Stack",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy"
      ],
      "explanation": "LIFO structure for nested patterns, matching pairs, or maintaining monotonic sequences."
  },
  1718: {
      "title": "Construct the Lexicographically Largest Valid Sequence",
      "slug": "construct-the-lexicographically-largest-valid-sequence",
      "difficulty": "medium",
      "primaryPattern": "Backtracking",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Explore all possible solutions recursively. Build candidates incrementally and abandon paths that cannot lead to solution."
  },
  1719: {
      "title": "Number Of Ways To Reconstruct A Tree",
      "slug": "number-of-ways-to-reconstruct-a-tree",
      "difficulty": "hard",
      "primaryPattern": "Tree Traversal",
      "acceptablePatterns": [
          "Graph"
      ],
      "explanation": "Navigate tree structures using inorder, preorder, or postorder traversal. Consider recursive or iterative approaches."
  },
  1720: {
      "title": "Decode XORed Array",
      "slug": "decode-xored-array",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1721: {
      "title": "Swapping Nodes in a Linked List",
      "slug": "swapping-nodes-in-a-linked-list",
      "difficulty": "medium",
      "primaryPattern": "Linked List",
      "acceptablePatterns": [
          "Two Pointers"
      ],
      "explanation": "Pointer manipulation for reversing, merging, detecting cycles, or finding intersections in linked structures."
  },
  1722: {
      "title": "Minimize Hamming Distance After Swap Operations",
      "slug": "minimize-hamming-distance-after-swap-operations",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map",
          "Graph"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  1723: {
      "title": "Find Minimum Time to Finish All Jobs",
      "slug": "find-minimum-time-to-finish-all-jobs",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Backtracking"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1725: {
      "title": "Number Of Rectangles That Can Form The Largest Square",
      "slug": "number-of-rectangles-that-can-form-the-largest-square",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1726: {
      "title": "Tuple with Same Product",
      "slug": "tuple-with-same-product",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1727: {
      "title": "Largest Submatrix With Rearrangements",
      "slug": "largest-submatrix-with-rearrangements",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers",
          "DFS"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  1728: {
      "title": "Cat and Mouse II",
      "slug": "cat-and-mouse-ii",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Graph",
          "DFS"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1729: {
      "title": "Find Followers Count",
      "slug": "find-followers-count",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1731: {
      "title": "The Number of Employees Which Report to Each Employee",
      "slug": "the-number-of-employees-which-report-to-each-employee",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1732: {
      "title": "Find the Highest Altitude",
      "slug": "find-the-highest-altitude",
      "difficulty": "easy",
      "lists": [
          "leetcode-75"
      ],
      "category": "Prefix Sum",
      "primaryPattern": "Prefix Sum",
      "acceptablePatterns": [],
      "patternExplanations": {
          "Prefix Sum": "Start at altitude 0. Each gain[i] changes altitude. Track running sum and find maximum."
      },
      "hints": [
          "Start at altitude 0. Each gain[i] adds to your current altitude.",
          "Track the running altitude sum as you traverse gains.",
          "Return the maximum altitude reached (including starting altitude 0)."
      ],
      "solution": {
          "approach": "altitude = 0, maxAlt = 0. For each gain: altitude += gain, maxAlt = max(maxAlt, altitude).",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "keyInsight": "Simple prefix sum - track running total and maximum."
      }
  },
  1733: {
      "title": "Minimum Number of People to Teach",
      "slug": "minimum-number-of-people-to-teach",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Greedy"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1734: {
      "title": "Decode XORed Permutation",
      "slug": "decode-xored-permutation",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1735: {
      "title": "Count Ways to Make Array With Product",
      "slug": "count-ways-to-make-array-with-product",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1736: {
      "title": "Latest Time by Replacing Hidden Digits",
      "slug": "latest-time-by-replacing-hidden-digits",
      "difficulty": "easy",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  1737: {
      "title": "Change Minimum Characters to Satisfy One of Three Conditions",
      "slug": "change-minimum-characters-to-satisfy-one-of-three-conditions",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1738: {
      "title": "Find Kth Largest XOR Coordinate Value",
      "slug": "find-kth-largest-xor-coordinate-value",
      "difficulty": "medium",
      "primaryPattern": "Heap/Priority Queue",
      "acceptablePatterns": [
          "Hash Map",
          "Binary Search",
          "Two Pointers",
          "DFS"
      ],
      "explanation": "Maintain ordered access to min/max elements. Useful for k-largest/smallest, merging, or scheduling problems."
  },
  1739: {
      "title": "Building Boxes",
      "slug": "building-boxes",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  1741: {
      "title": "Find Total Time Spent by Each Employee",
      "slug": "find-total-time-spent-by-each-employee",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1742: {
      "title": "Maximum Number of Balls in a Box",
      "slug": "maximum-number-of-balls-in-a-box",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1743: {
      "title": "Restore the Array From Adjacent Pairs",
      "slug": "restore-the-array-from-adjacent-pairs",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "DFS"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1744: {
      "title": "Can You Eat Your Favorite Candy on Your Favorite Day?",
      "slug": "can-you-eat-your-favorite-candy-on-your-favorite-day",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1745: {
      "title": "Palindrome Partitioning IV",
      "slug": "palindrome-partitioning-iv",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1748: {
      "title": "Sum of Unique Elements",
      "slug": "sum-of-unique-elements",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1749: {
      "title": "Maximum Absolute Sum of Any Subarray",
      "slug": "maximum-absolute-sum-of-any-subarray",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1750: {
      "title": "Minimum Length of String After Deleting Similar Ends",
      "slug": "minimum-length-of-string-after-deleting-similar-ends",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  1751: {
      "title": "Maximum Number of Events That Can Be Attended II",
      "slug": "maximum-number-of-events-that-can-be-attended-ii",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Dynamic Programming",
          "Two Pointers"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  1752: {
      "title": "Check if Array Is Sorted and Rotated",
      "slug": "check-if-array-is-sorted-and-rotated",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1753: {
      "title": "Maximum Score From Removing Stones",
      "slug": "maximum-score-from-removing-stones",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Heap/Priority Queue"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  1754: {
      "title": "Largest Merge Of Two Strings",
      "slug": "largest-merge-of-two-strings",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  1755: {
      "title": "Closest Subsequence Sum",
      "slug": "closest-subsequence-sum",
      "difficulty": "hard",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map",
          "Dynamic Programming"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  1757: {
      "title": "Recyclable and Low Fat Products",
      "slug": "recyclable-and-low-fat-products",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1758: {
      "title": "Minimum Changes To Make Alternating Binary String",
      "slug": "minimum-changes-to-make-alternating-binary-string",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1759: {
      "title": "Count Number of Homogenous Substrings",
      "slug": "count-number-of-homogenous-substrings",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1760: {
      "title": "Minimum Limit of Balls in a Bag",
      "slug": "minimum-limit-of-balls-in-a-bag",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  1761: {
      "title": "Minimum Degree of a Connected Trio in a Graph",
      "slug": "minimum-degree-of-a-connected-trio-in-a-graph",
      "difficulty": "hard",
      "primaryPattern": "Graph",
      "acceptablePatterns": [],
      "explanation": "Graph algorithms - may involve topological sort, cycle detection, union find, or connectivity checks."
  },
  1763: {
      "title": "Longest Nice Substring",
      "slug": "longest-nice-substring",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Binary Search",
          "Sliding Window"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1764: {
      "title": "Form Array by Concatenating Subarrays of Another Array",
      "slug": "form-array-by-concatenating-subarrays-of-another-array",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  1765: {
      "title": "Map of Highest Peak",
      "slug": "map-of-highest-peak",
      "difficulty": "medium",
      "primaryPattern": "BFS",
      "acceptablePatterns": [
          "Hash Map",
          "DFS"
      ],
      "explanation": "Breadth-first search - explore level by level using a queue. Ideal for shortest path in unweighted graphs or level-order traversal."
  },
  1766: {
      "title": "Tree of Coprimes",
      "slug": "tree-of-coprimes",
      "difficulty": "hard",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map",
          "Tree Traversal"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  1768: {
      "title": "Merge Strings Alternately",
      "slug": "merge-strings-alternately",
      "difficulty": "easy",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds.",
      "lists": [
          "leetcode-75"
      ],
      "category": "Two Pointers",
      "patternExplanations": {
          "Two Pointers": "Two pointers, one per string. Take alternating characters."
      },
      "hints": [
          "Take one char from word1, one from word2, repeat.",
          "Use two pointers i and j. Alternate: take word1[i++], then word2[j++].",
          "When one string is exhausted, append the rest of the other."
      ],
      "solution": {
          "approach": "Two pointers. While both have chars, alternate. Append remaining from whichever is longer.",
          "timeComplexity": "O(n + m)",
          "spaceComplexity": "O(n + m)",
          "keyInsight": "Simple two-pointer interleaving. Handle unequal lengths at end."
      }
  },
  1769: {
      "title": "Minimum Number of Operations to Move All Balls to Each Box",
      "slug": "minimum-number-of-operations-to-move-all-balls-to-each-box",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1770: {
      "title": "Maximum Score from Performing Multiplication Operations",
      "slug": "maximum-score-from-performing-multiplication-operations",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1771: {
      "title": "Maximize Palindrome Length From Subsequences",
      "slug": "maximize-palindrome-length-from-subsequences",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1773: {
      "title": "Count Items Matching a Rule",
      "slug": "count-items-matching-a-rule",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1774: {
      "title": "Closest Dessert Cost",
      "slug": "closest-dessert-cost",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Backtracking"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1775: {
      "title": "Equal Sum Arrays With Minimum Number of Operations",
      "slug": "equal-sum-arrays-with-minimum-number-of-operations",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Greedy"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1776: {
      "title": "Car Fleet II",
      "slug": "car-fleet-ii",
      "difficulty": "hard",
      "primaryPattern": "Stack",
      "acceptablePatterns": [
          "Hash Map",
          "Heap/Priority Queue"
      ],
      "explanation": "LIFO structure for nested patterns, matching pairs, or maintaining monotonic sequences."
  },
  1779: {
      "title": "Find Nearest Point That Has the Same X or Y Coordinate",
      "slug": "find-nearest-point-that-has-the-same-x-or-y-coordinate",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1780: {
      "title": "Check if Number is a Sum of Powers of Three",
      "slug": "check-if-number-is-a-sum-of-powers-of-three",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1781: {
      "title": "Sum of Beauty of All Substrings",
      "slug": "sum-of-beauty-of-all-substrings",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1782: {
      "title": "Count Pairs Of Nodes",
      "slug": "count-pairs-of-nodes",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Two Pointers",
          "Binary Search",
          "Graph"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1784: {
      "title": "Check if Binary String Has at Most One Segment of Ones",
      "slug": "check-if-binary-string-has-at-most-one-segment-of-ones",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1785: {
      "title": "Minimum Elements to Add to Form a Given Sum",
      "slug": "minimum-elements-to-add-to-form-a-given-sum",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  1786: {
      "title": "Number of Restricted Paths From First to Last Node",
      "slug": "number-of-restricted-paths-from-first-to-last-node",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Graph",
          "Heap/Priority Queue",
          "BFS"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1787: {
      "title": "Make the XOR of All Segments Equal to Zero",
      "slug": "make-the-xor-of-all-segments-equal-to-zero",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1789: {
      "title": "Primary Department for Each Employee",
      "slug": "primary-department-for-each-employee",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1790: {
      "title": "Check if One String Swap Can Make Strings Equal",
      "slug": "check-if-one-string-swap-can-make-strings-equal",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1791: {
      "title": "Find Center of Star Graph",
      "slug": "find-center-of-star-graph",
      "difficulty": "easy",
      "primaryPattern": "Graph",
      "acceptablePatterns": [],
      "explanation": "Graph algorithms - may involve topological sort, cycle detection, union find, or connectivity checks."
  },
  1792: {
      "title": "Maximum Average Pass Ratio",
      "slug": "maximum-average-pass-ratio",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Heap/Priority Queue"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  1793: {
      "title": "Maximum Score of a Good Subarray",
      "slug": "maximum-score-of-a-good-subarray",
      "difficulty": "hard",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map",
          "Binary Search",
          "Stack"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  1795: {
      "title": "Rearrange Products Table",
      "slug": "rearrange-products-table",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1796: {
      "title": "Second Largest Digit in a String",
      "slug": "second-largest-digit-in-a-string",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1797: {
      "title": "Design Authentication Manager",
      "slug": "design-authentication-manager",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Linked List"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1798: {
      "title": "Maximum Number of Consecutive Values You Can Make",
      "slug": "maximum-number-of-consecutive-values-you-can-make",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  1799: {
      "title": "Maximize Score After N Operations",
      "slug": "maximize-score-after-n-operations",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Backtracking"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1800: {
      "title": "Maximum Ascending Subarray Sum",
      "slug": "maximum-ascending-subarray-sum",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1801: {
      "title": "Number of Orders in the Backlog",
      "slug": "number-of-orders-in-the-backlog",
      "difficulty": "medium",
      "primaryPattern": "Heap/Priority Queue",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Maintain ordered access to min/max elements. Useful for k-largest/smallest, merging, or scheduling problems."
  },
  1802: {
      "title": "Maximum Value at a Given Index in a Bounded Array",
      "slug": "maximum-value-at-a-given-index-in-a-bounded-array",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  1803: {
      "title": "Count Pairs With XOR in a Range",
      "slug": "count-pairs-with-xor-in-a-range",
      "difficulty": "hard",
      "primaryPattern": "Trie",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Prefix tree for efficient string operations. Each node represents a character, paths represent strings."
  },
  1805: {
      "title": "Number of Different Integers in a String",
      "slug": "number-of-different-integers-in-a-string",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1806: {
      "title": "Minimum Number of Operations to Reinitialize a Permutation",
      "slug": "minimum-number-of-operations-to-reinitialize-a-permutation",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1807: {
      "title": "Evaluate the Bracket Pairs of a String",
      "slug": "evaluate-the-bracket-pairs-of-a-string",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1808: {
      "title": "Maximize Number of Nice Divisors",
      "slug": "maximize-number-of-nice-divisors",
      "difficulty": "hard",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  1812: {
      "title": "Determine Color of a Chessboard Square",
      "slug": "determine-color-of-a-chessboard-square",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1813: {
      "title": "Sentence Similarity III",
      "slug": "sentence-similarity-iii",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  1814: {
      "title": "Count Nice Pairs in an Array",
      "slug": "count-nice-pairs-in-an-array",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1815: {
      "title": "Maximum Number of Groups Getting Fresh Donuts",
      "slug": "maximum-number-of-groups-getting-fresh-donuts",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1816: {
      "title": "Truncate Sentence",
      "slug": "truncate-sentence",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1817: {
      "title": "Finding the Users Active Minutes",
      "slug": "finding-the-users-active-minutes",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1818: {
      "title": "Minimum Absolute Sum Difference",
      "slug": "minimum-absolute-sum-difference",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  1819: {
      "title": "Number of Different Subsequences GCDs",
      "slug": "number-of-different-subsequences-gcds",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1822: {
      "title": "Sign of the Product of an Array",
      "slug": "sign-of-the-product-of-an-array",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1823: {
      "title": "Find the Winner of the Circular Game",
      "slug": "find-the-winner-of-the-circular-game",
      "difficulty": "medium",
      "primaryPattern": "BFS",
      "acceptablePatterns": [
          "Hash Map",
          "DFS"
      ],
      "explanation": "Breadth-first search - explore level by level using a queue. Ideal for shortest path in unweighted graphs or level-order traversal."
  },
  1824: {
      "title": "Minimum Sideway Jumps",
      "slug": "minimum-sideway-jumps",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1825: {
      "title": "Finding MK Average",
      "slug": "finding-mk-average",
      "difficulty": "hard",
      "primaryPattern": "Heap/Priority Queue",
      "acceptablePatterns": [
          "Hash Map",
          "BFS"
      ],
      "explanation": "Maintain ordered access to min/max elements. Useful for k-largest/smallest, merging, or scheduling problems."
  },
  1827: {
      "title": "Minimum Operations to Make the Array Increasing",
      "slug": "minimum-operations-to-make-the-array-increasing",
      "difficulty": "easy",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  1828: {
      "title": "Queries on Number of Points Inside a Circle",
      "slug": "queries-on-number-of-points-inside-a-circle",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1829: {
      "title": "Maximum XOR for Each Query",
      "slug": "maximum-xor-for-each-query",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1830: {
      "title": "Minimum Number of Operations to Make String Sorted",
      "slug": "minimum-number-of-operations-to-make-string-sorted",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1832: {
      "title": "Check if the Sentence Is Pangram",
      "slug": "check-if-the-sentence-is-pangram",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1833: {
      "title": "Maximum Ice Cream Bars",
      "slug": "maximum-ice-cream-bars",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  1834: {
      "title": "Single-Threaded CPU",
      "slug": "single-threaded-cpu",
      "difficulty": "medium",
      "primaryPattern": "Heap/Priority Queue",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Maintain ordered access to min/max elements. Useful for k-largest/smallest, merging, or scheduling problems."
  },
  1835: {
      "title": "Find XOR Sum of All Pairs Bitwise AND",
      "slug": "find-xor-sum-of-all-pairs-bitwise-and",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1837: {
      "title": "Sum of Digits in Base K",
      "slug": "sum-of-digits-in-base-k",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1838: {
      "title": "Frequency of the Most Frequent Element",
      "slug": "frequency-of-the-most-frequent-element",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy",
          "Sliding Window",
          "Two Pointers"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  1839: {
      "title": "Longest Substring Of All Vowels in Order",
      "slug": "longest-substring-of-all-vowels-in-order",
      "difficulty": "medium",
      "primaryPattern": "Sliding Window",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Maintain a window of elements that slides through the array. Expand when adding elements, contract when removing. Track window state."
  },
  1840: {
      "title": "Maximum Building Height",
      "slug": "maximum-building-height",
      "difficulty": "hard",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  1844: {
      "title": "Replace All Digits with Characters",
      "slug": "replace-all-digits-with-characters",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1845: {
      "title": "Seat Reservation Manager",
      "slug": "seat-reservation-manager",
      "difficulty": "medium",
      "primaryPattern": "Heap/Priority Queue",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Maintain ordered access to min/max elements. Useful for k-largest/smallest, merging, or scheduling problems."
  },
  1846: {
      "title": "Maximum Element After Decreasing and Rearranging",
      "slug": "maximum-element-after-decreasing-and-rearranging",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  1847: {
      "title": "Closest Room",
      "slug": "closest-room",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  1848: {
      "title": "Minimum Distance to the Target Element",
      "slug": "minimum-distance-to-the-target-element",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1849: {
      "title": "Splitting a String Into Descending Consecutive Values",
      "slug": "splitting-a-string-into-descending-consecutive-values",
      "difficulty": "medium",
      "primaryPattern": "Backtracking",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Explore all possible solutions recursively. Build candidates incrementally and abandon paths that cannot lead to solution."
  },
  1850: {
      "title": "Minimum Adjacent Swaps to Reach the Kth Smallest Number",
      "slug": "minimum-adjacent-swaps-to-reach-the-kth-smallest-number",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  1851: {
      "title": "Minimum Interval to Include Each Query",
      "slug": "minimum-interval-to-include-each-query",
      "difficulty": "hard",
      "primaryPattern": "Heap",
      "acceptablePatterns": [
          "Binary Search"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element.",
      "lists": [
          "neetcode-150"
      ],
      "category": "Heap / Priority Queue",
      "patternExplanations": {
          "Heap": "Sort queries and intervals by start. Use min-heap by end. For each query, add valid intervals, get smallest.",
          "Binary Search": "Offline processing: sort queries. Use heap to track valid intervals for each query point."
      },
      "hints": [
          "For each query, find smallest interval containing it.",
          "Process queries in sorted order. Maintain heap of active intervals.",
          "Add intervals starting before query. Remove intervals ending before query. Heap gives smallest."
      ],
      "solution": {
          "approach": "Sort queries and intervals. For each query, add intervals with start <= query to min-heap (by size). Remove invalid. Answer = top.",
          "timeComplexity": "O((n + q) log n)",
          "spaceComplexity": "O(n + q)",
          "keyInsight": "Offline processing: sort queries to process intervals in order. Heap maintains smallest valid interval."
      }
  },
  1854: {
      "title": "Maximum Population Year",
      "slug": "maximum-population-year",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1855: {
      "title": "Maximum Distance Between a Pair of Values",
      "slug": "maximum-distance-between-a-pair-of-values",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map",
          "Binary Search"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  1856: {
      "title": "Maximum Subarray Min-Product",
      "slug": "maximum-subarray-min-product",
      "difficulty": "medium",
      "primaryPattern": "Stack",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "LIFO structure for nested patterns, matching pairs, or maintaining monotonic sequences."
  },
  1857: {
      "title": "Largest Color Value in a Directed Graph",
      "slug": "largest-color-value-in-a-directed-graph",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Dynamic Programming",
          "Graph"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1859: {
      "title": "Sorting the Sentence",
      "slug": "sorting-the-sentence",
      "difficulty": "easy",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  1860: {
      "title": "Incremental Memory Leak",
      "slug": "incremental-memory-leak",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1861: {
      "title": "Rotating the Box",
      "slug": "rotating-the-box",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map",
          "DFS"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  1862: {
      "title": "Sum of Floored Pairs",
      "slug": "sum-of-floored-pairs",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  1863: {
      "title": "Sum of All Subset XOR Totals",
      "slug": "sum-of-all-subset-xor-totals",
      "difficulty": "easy",
      "primaryPattern": "Backtracking",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Explore all possible solutions recursively. Build candidates incrementally and abandon paths that cannot lead to solution."
  },
  1864: {
      "title": "Minimum Number of Swaps to Make the Binary String Alternating",
      "slug": "minimum-number-of-swaps-to-make-the-binary-string-alternating",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  1865: {
      "title": "Finding Pairs With a Certain Sum",
      "slug": "finding-pairs-with-a-certain-sum",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1866: {
      "title": "Number of Ways to Rearrange Sticks With K Sticks Visible",
      "slug": "number-of-ways-to-rearrange-sticks-with-k-sticks-visible",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1869: {
      "title": "Longer Contiguous Segments of Ones than Zeros",
      "slug": "longer-contiguous-segments-of-ones-than-zeros",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1870: {
      "title": "Minimum Speed to Arrive on Time",
      "slug": "minimum-speed-to-arrive-on-time",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  1871: {
      "title": "Jump Game VII",
      "slug": "jump-game-vii",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Sliding Window"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1872: {
      "title": "Stone Game VIII",
      "slug": "stone-game-viii",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1873: {
      "title": "Calculate Special Bonus",
      "slug": "calculate-special-bonus",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1876: {
      "title": "Substrings of Size Three with Distinct Characters",
      "slug": "substrings-of-size-three-with-distinct-characters",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Sliding Window"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1877: {
      "title": "Minimize Maximum Pair Sum in Array",
      "slug": "minimize-maximum-pair-sum-in-array",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  1878: {
      "title": "Get Biggest Three Rhombus Sums in a Grid",
      "slug": "get-biggest-three-rhombus-sums-in-a-grid",
      "difficulty": "medium",
      "primaryPattern": "Heap/Priority Queue",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers",
          "DFS"
      ],
      "explanation": "Maintain ordered access to min/max elements. Useful for k-largest/smallest, merging, or scheduling problems."
  },
  1879: {
      "title": "Minimum XOR Sum of Two Arrays",
      "slug": "minimum-xor-sum-of-two-arrays",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1880: {
      "title": "Check if Word Equals Summation of Two Words",
      "slug": "check-if-word-equals-summation-of-two-words",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1881: {
      "title": "Maximum Value after Insertion",
      "slug": "maximum-value-after-insertion",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  1882: {
      "title": "Process Tasks Using Servers",
      "slug": "process-tasks-using-servers",
      "difficulty": "medium",
      "primaryPattern": "Heap/Priority Queue",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Maintain ordered access to min/max elements. Useful for k-largest/smallest, merging, or scheduling problems."
  },
  1883: {
      "title": "Minimum Skips to Arrive at Meeting On Time",
      "slug": "minimum-skips-to-arrive-at-meeting-on-time",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1884: {
      "title": "Egg Drop With 2 Eggs and N Floors",
      "slug": "egg-drop-with-2-eggs-and-n-floors",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1886: {
      "title": "Determine Whether Matrix Can Be Obtained By Rotation",
      "slug": "determine-whether-matrix-can-be-obtained-by-rotation",
      "difficulty": "easy",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  1887: {
      "title": "Reduction Operations to Make the Array Elements Equal",
      "slug": "reduction-operations-to-make-the-array-elements-equal",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  1888: {
      "title": "Minimum Number of Flips to Make the Binary String Alternating",
      "slug": "minimum-number-of-flips-to-make-the-binary-string-alternating",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Sliding Window"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1889: {
      "title": "Minimum Space Wasted From Packaging",
      "slug": "minimum-space-wasted-from-packaging",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  1890: {
      "title": "The Latest Login in 2020",
      "slug": "the-latest-login-in-2020",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1893: {
      "title": "Check if All the Integers in a Range Are Covered",
      "slug": "check-if-all-the-integers-in-a-range-are-covered",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1894: {
      "title": "Find the Student that Will Replace the Chalk",
      "slug": "find-the-student-that-will-replace-the-chalk",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  1895: {
      "title": "Largest Magic Square",
      "slug": "largest-magic-square",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "DFS"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1896: {
      "title": "Minimum Cost to Change the Final Value of Expression",
      "slug": "minimum-cost-to-change-the-final-value-of-expression",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Stack"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1897: {
      "title": "Redistribute Characters to Make All Strings Equal",
      "slug": "redistribute-characters-to-make-all-strings-equal",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1898: {
      "title": "Maximum Number of Removable Characters",
      "slug": "maximum-number-of-removable-characters",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map",
          "Binary Search"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  1899: {
      "title": "Merge Triplets to Form Target Triplet",
      "slug": "merge-triplets-to-form-target-triplet",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum.",
      "lists": [
          "neetcode-150"
      ],
      "category": "Greedy",
      "patternExplanations": {
          "Greedy": "A triplet is usable if each element is <= corresponding target element. Check if all target elements are achievable."
      },
      "hints": [
          "merge([a,b,c], [d,e,f]) = [max(a,d), max(b,e), max(c,f)].",
          "We can only use triplets where each element <= corresponding target element.",
          "For each position, check if some valid triplet has that position's target value."
      ],
      "solution": {
          "approach": "Filter triplets: only use if triplet[i] <= target[i] for all i. Check if for each position, some triplet achieves target value.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "keyInsight": "Discard triplets that would exceed target in any position. Then check if target values are achievable."
      }
  },
  1900: {
      "title": "The Earliest and Latest Rounds Where Players Compete",
      "slug": "the-earliest-and-latest-rounds-where-players-compete",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1901: {
      "title": "Find a Peak Element II",
      "slug": "find-a-peak-element-ii",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "DFS"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  1903: {
      "title": "Largest Odd Number in String",
      "slug": "largest-odd-number-in-string",
      "difficulty": "easy",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  1904: {
      "title": "The Number of Full Rounds You Have Played",
      "slug": "the-number-of-full-rounds-you-have-played",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1905: {
      "title": "Count Sub Islands",
      "slug": "count-sub-islands",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map",
          "BFS",
          "Graph"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  1906: {
      "title": "Minimum Absolute Difference Queries",
      "slug": "minimum-absolute-difference-queries",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1907: {
      "title": "Count Salary Categories",
      "slug": "count-salary-categories",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1909: {
      "title": "Remove One Element to Make the Array Strictly Increasing",
      "slug": "remove-one-element-to-make-the-array-strictly-increasing",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1910: {
      "title": "Remove All Occurrences of a Substring",
      "slug": "remove-all-occurrences-of-a-substring",
      "difficulty": "medium",
      "primaryPattern": "Stack",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "LIFO structure for nested patterns, matching pairs, or maintaining monotonic sequences."
  },
  1911: {
      "title": "Maximum Alternating Subsequence Sum",
      "slug": "maximum-alternating-subsequence-sum",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1912: {
      "title": "Design Movie Rental System",
      "slug": "design-movie-rental-system",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Heap/Priority Queue"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1913: {
      "title": "Maximum Product Difference Between Two Pairs",
      "slug": "maximum-product-difference-between-two-pairs",
      "difficulty": "easy",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  1914: {
      "title": "Cyclically Rotating a Grid",
      "slug": "cyclically-rotating-a-grid",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  1915: {
      "title": "Number of Wonderful Substrings",
      "slug": "number-of-wonderful-substrings",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1916: {
      "title": "Count Ways to Build Rooms in an Ant Colony",
      "slug": "count-ways-to-build-rooms-in-an-ant-colony",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Tree Traversal",
          "Graph"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1920: {
      "title": "Build Array from Permutation",
      "slug": "build-array-from-permutation",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1921: {
      "title": "Eliminate Maximum Number of Monsters",
      "slug": "eliminate-maximum-number-of-monsters",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  1922: {
      "title": "Count Good Numbers",
      "slug": "count-good-numbers",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  1923: {
      "title": "Longest Common Subpath",
      "slug": "longest-common-subpath",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  1925: {
      "title": "Count Square Sum Triples",
      "slug": "count-square-sum-triples",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1926: {
      "title": "Nearest Exit from Entrance in Maze",
      "slug": "nearest-exit-from-entrance-in-maze",
      "difficulty": "medium",
      "lists": [
          "leetcode-75"
      ],
      "category": "Graphs - BFS",
      "primaryPattern": "BFS",
      "acceptablePatterns": [],
      "patternExplanations": {
          "BFS": "BFS from entrance. An exit is on border and not the entrance. First exit found is nearest (BFS property)."
      },
      "hints": [
          "Find shortest path to any exit. Exit = empty cell on border (not entrance).",
          "BFS gives shortest path in unweighted graph/grid.",
          "BFS from entrance. When you reach a border cell (not entrance), that's the answer."
      ],
      "solution": {
          "approach": "BFS from entrance. For each cell, check if it's an exit (on border, not entrance). Return distance when found.",
          "timeComplexity": "O(m * n)",
          "spaceComplexity": "O(m * n)",
          "keyInsight": "BFS guarantees shortest path. First exit reached is nearest."
      }
  },
  1927: {
      "title": "Sum Game",
      "slug": "sum-game",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  1928: {
      "title": "Minimum Cost to Reach Destination in Time",
      "slug": "minimum-cost-to-reach-destination-in-time",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Graph"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1929: {
      "title": "Concatenation of Array",
      "slug": "concatenation-of-array",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1930: {
      "title": "Unique Length-3 Palindromic Subsequences",
      "slug": "unique-length-3-palindromic-subsequences",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1931: {
      "title": "Painting a Grid With Three Different Colors",
      "slug": "painting-a-grid-with-three-different-colors",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1932: {
      "title": "Merge BSTs to Create Single BST",
      "slug": "merge-bsts-to-create-single-bst",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Binary Search",
          "Tree Traversal",
          "DFS"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1934: {
      "title": "Confirmation Rate",
      "slug": "confirmation-rate",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1935: {
      "title": "Maximum Number of Words You Can Type",
      "slug": "maximum-number-of-words-you-can-type",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1936: {
      "title": "Add Minimum Number of Rungs",
      "slug": "add-minimum-number-of-rungs",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  1937: {
      "title": "Maximum Number of Points with Cost",
      "slug": "maximum-number-of-points-with-cost",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "DFS"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1938: {
      "title": "Maximum Genetic Difference Query",
      "slug": "maximum-genetic-difference-query",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "DFS",
          "Trie"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1941: {
      "title": "Check if All Characters Have Equal Number of Occurrences",
      "slug": "check-if-all-characters-have-equal-number-of-occurrences",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1942: {
      "title": "The Number of the Smallest Unoccupied Chair",
      "slug": "the-number-of-the-smallest-unoccupied-chair",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Heap/Priority Queue"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1943: {
      "title": "Describe the Painting",
      "slug": "describe-the-painting",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1944: {
      "title": "Number of Visible People in a Queue",
      "slug": "number-of-visible-people-in-a-queue",
      "difficulty": "hard",
      "primaryPattern": "Stack",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "LIFO structure for nested patterns, matching pairs, or maintaining monotonic sequences."
  },
  1945: {
      "title": "Sum of Digits of String After Convert",
      "slug": "sum-of-digits-of-string-after-convert",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1946: {
      "title": "Largest Number After Mutating Substring",
      "slug": "largest-number-after-mutating-substring",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  1947: {
      "title": "Maximum Compatibility Score Sum",
      "slug": "maximum-compatibility-score-sum",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Backtracking"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1948: {
      "title": "Delete Duplicate Folders in System",
      "slug": "delete-duplicate-folders-in-system",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Trie"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1952: {
      "title": "Three Divisors",
      "slug": "three-divisors",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1953: {
      "title": "Maximum Number of Weeks for Which You Can Work",
      "slug": "maximum-number-of-weeks-for-which-you-can-work",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  1954: {
      "title": "Minimum Garden Perimeter to Collect Enough Apples",
      "slug": "minimum-garden-perimeter-to-collect-enough-apples",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  1955: {
      "title": "Count Number of Special Subsequences",
      "slug": "count-number-of-special-subsequences",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1957: {
      "title": "Delete Characters to Make Fancy String",
      "slug": "delete-characters-to-make-fancy-string",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1958: {
      "title": "Check if Move is Legal",
      "slug": "check-if-move-is-legal",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  1959: {
      "title": "Minimum Total Space Wasted With K Resizing Operations",
      "slug": "minimum-total-space-wasted-with-k-resizing-operations",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1960: {
      "title": "Maximum Product of the Length of Two Palindromic Substrings",
      "slug": "maximum-product-of-the-length-of-two-palindromic-substrings",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1961: {
      "title": "Check If String Is a Prefix of Array",
      "slug": "check-if-string-is-a-prefix-of-array",
      "difficulty": "easy",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  1962: {
      "title": "Remove Stones to Minimize the Total",
      "slug": "remove-stones-to-minimize-the-total",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Heap/Priority Queue"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  1963: {
      "title": "Minimum Number of Swaps to Make the String Balanced",
      "slug": "minimum-number-of-swaps-to-make-the-string-balanced",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map",
          "Stack",
          "Greedy"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  1964: {
      "title": "Find the Longest Valid Obstacle Course at Each Position",
      "slug": "find-the-longest-valid-obstacle-course-at-each-position",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  1965: {
      "title": "Employees With Missing Information",
      "slug": "employees-with-missing-information",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1967: {
      "title": "Number of Strings That Appear as Substrings in Word",
      "slug": "number-of-strings-that-appear-as-substrings-in-word",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1968: {
      "title": "Array With Elements Not Equal to Average of Neighbors",
      "slug": "array-with-elements-not-equal-to-average-of-neighbors",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  1969: {
      "title": "Minimum Non-Zero Product of the Array Elements",
      "slug": "minimum-non-zero-product-of-the-array-elements",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "DFS"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  1970: {
      "title": "Last Day Where You Can Still Cross",
      "slug": "last-day-where-you-can-still-cross",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "DFS",
          "BFS",
          "Graph"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  1971: {
      "title": "Find if Path Exists in Graph",
      "slug": "find-if-path-exists-in-graph",
      "difficulty": "easy",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "BFS",
          "Graph"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  1974: {
      "title": "Minimum Time to Type Word Using Special Typewriter",
      "slug": "minimum-time-to-type-word-using-special-typewriter",
      "difficulty": "easy",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  1975: {
      "title": "Maximum Matrix Sum",
      "slug": "maximum-matrix-sum",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "DFS"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  1976: {
      "title": "Number of Ways to Arrive at Destination",
      "slug": "number-of-ways-to-arrive-at-destination",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Graph",
          "BFS"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1977: {
      "title": "Number of Ways to Separate Numbers",
      "slug": "number-of-ways-to-separate-numbers",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1978: {
      "title": "Employees Whose Manager Left the Company",
      "slug": "employees-whose-manager-left-the-company",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1979: {
      "title": "Find Greatest Common Divisor of Array",
      "slug": "find-greatest-common-divisor-of-array",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1980: {
      "title": "Find Unique Binary String",
      "slug": "find-unique-binary-string",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Backtracking"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1981: {
      "title": "Minimize the Difference Between Target and Chosen Elements",
      "slug": "minimize-the-difference-between-target-and-chosen-elements",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "DFS"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1982: {
      "title": "Find Array Given Subset Sums",
      "slug": "find-array-given-subset-sums",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  1984: {
      "title": "Minimum Difference Between Highest and Lowest of K Scores",
      "slug": "minimum-difference-between-highest-and-lowest-of-k-scores",
      "difficulty": "easy",
      "primaryPattern": "Sliding Window",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Maintain a window of elements that slides through the array. Expand when adding elements, contract when removing. Track window state."
  },
  1985: {
      "title": "Find the Kth Largest Integer in the Array",
      "slug": "find-the-kth-largest-integer-in-the-array",
      "difficulty": "medium",
      "primaryPattern": "Heap/Priority Queue",
      "acceptablePatterns": [
          "Hash Map",
          "Binary Search",
          "Two Pointers"
      ],
      "explanation": "Maintain ordered access to min/max elements. Useful for k-largest/smallest, merging, or scheduling problems."
  },
  1986: {
      "title": "Minimum Number of Work Sessions to Finish the Tasks",
      "slug": "minimum-number-of-work-sessions-to-finish-the-tasks",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Backtracking"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1987: {
      "title": "Number of Unique Good Subsequences",
      "slug": "number-of-unique-good-subsequences",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1991: {
      "title": "Find the Middle Index in Array",
      "slug": "find-the-middle-index-in-array",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1992: {
      "title": "Find All Groups of Farmland",
      "slug": "find-all-groups-of-farmland",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map",
          "BFS"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  1993: {
      "title": "Operations on Tree",
      "slug": "operations-on-tree",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Tree Traversal",
          "DFS",
          "BFS"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1994: {
      "title": "The Number of Good Subsets",
      "slug": "the-number-of-good-subsets",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Dynamic Programming"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1995: {
      "title": "Count Special Quadruplets",
      "slug": "count-special-quadruplets",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  1996: {
      "title": "The Number of Weak Characters in the Game",
      "slug": "the-number-of-weak-characters-in-the-game",
      "difficulty": "medium",
      "primaryPattern": "Stack",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy",
          "Two Pointers"
      ],
      "explanation": "LIFO structure for nested patterns, matching pairs, or maintaining monotonic sequences."
  },
  1997: {
      "title": "First Day Where You Have Been in All the Rooms",
      "slug": "first-day-where-you-have-been-in-all-the-rooms",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  1998: {
      "title": "GCD Sort of an Array",
      "slug": "gcd-sort-of-an-array",
      "difficulty": "hard",
      "primaryPattern": "Graph",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Graph algorithms - may involve topological sort, cycle detection, union find, or connectivity checks."
  },
  2000: {
      "title": "Reverse Prefix of Word",
      "slug": "reverse-prefix-of-word",
      "difficulty": "easy",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map",
          "Stack"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  2001: {
      "title": "Number of Pairs of Interchangeable Rectangles",
      "slug": "number-of-pairs-of-interchangeable-rectangles",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2002: {
      "title": "Maximum Product of the Length of Two Palindromic Subsequences",
      "slug": "maximum-product-of-the-length-of-two-palindromic-subsequences",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Backtracking"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2003: {
      "title": "Smallest Missing Genetic Value in Each Subtree",
      "slug": "smallest-missing-genetic-value-in-each-subtree",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Tree Traversal",
          "DFS",
          "Graph"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2006: {
      "title": "Count Number of Pairs With Absolute Difference K",
      "slug": "count-number-of-pairs-with-absolute-difference-k",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2007: {
      "title": "Find Original Array From Doubled Array",
      "slug": "find-original-array-from-doubled-array",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Greedy",
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2008: {
      "title": "Maximum Earnings From Taxi",
      "slug": "maximum-earnings-from-taxi",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Binary Search",
          "Dynamic Programming",
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2009: {
      "title": "Minimum Number of Operations to Make Array Continuous",
      "slug": "minimum-number-of-operations-to-make-array-continuous",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Binary Search",
          "Sliding Window"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2011: {
      "title": "Final Value of Variable After Performing Operations",
      "slug": "final-value-of-variable-after-performing-operations",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2012: {
      "title": "Sum of Beauty in the Array",
      "slug": "sum-of-beauty-in-the-array",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2013: {
      "title": "Detect Squares",
      "slug": "detect-squares",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships.",
      "lists": [
          "neetcode-150"
      ],
      "category": "Hash Map",
      "patternExplanations": {
          "Hash Map": "Store points with count. For query point, check if opposite corners exist to form squares."
      },
      "hints": [
          "Store points and their counts. For detect, find squares with query as corner.",
          "A square has corners (x1,y1), (x1,y2), (x2,y1), (x2,y2) where |x2-x1| = |y2-y1|.",
          "Given query point, iterate over points with same x. Check if the two other corners exist."
      ],
      "solution": {
          "approach": "HashMap of (point -> count). detect: for each point with same x, check if square's other corners exist. Sum products.",
          "timeComplexity": "O(n) per detect, O(1) add",
          "spaceComplexity": "O(n)",
          "keyInsight": "Diagonal of square: given two corners with same x, the other corners are determined."
      }
  },
  2014: {
      "title": "Longest Subsequence Repeated k Times",
      "slug": "longest-subsequence-repeated-k-times",
      "difficulty": "hard",
      "primaryPattern": "Backtracking",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy"
      ],
      "explanation": "Explore all possible solutions recursively. Build candidates incrementally and abandon paths that cannot lead to solution."
  },
  2016: {
      "title": "Maximum Difference Between Increasing Elements",
      "slug": "maximum-difference-between-increasing-elements",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2017: {
      "title": "Grid Game",
      "slug": "grid-game",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "DFS"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2018: {
      "title": "Check if Word Can Be Placed In Crossword",
      "slug": "check-if-word-can-be-placed-in-crossword",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  2019: {
      "title": "The Score of Students Solving Math Expression",
      "slug": "the-score-of-students-solving-math-expression",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Dynamic Programming",
          "Stack"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2022: {
      "title": "Convert 1D Array Into 2D Array",
      "slug": "convert-1d-array-into-2d-array",
      "difficulty": "easy",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  2023: {
      "title": "Number of Pairs of Strings With Concatenation Equal to Target",
      "slug": "number-of-pairs-of-strings-with-concatenation-equal-to-target",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2024: {
      "title": "Maximize the Confusion of an Exam",
      "slug": "maximize-the-confusion-of-an-exam",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Sliding Window"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  2025: {
      "title": "Maximum Number of Ways to Partition an Array",
      "slug": "maximum-number-of-ways-to-partition-an-array",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2027: {
      "title": "Minimum Moves to Convert String",
      "slug": "minimum-moves-to-convert-string",
      "difficulty": "easy",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  2028: {
      "title": "Find Missing Observations",
      "slug": "find-missing-observations",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2029: {
      "title": "Stone Game IX",
      "slug": "stone-game-ix",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  2030: {
      "title": "Smallest K-Length Subsequence With Occurrences of a Letter",
      "slug": "smallest-k-length-subsequence-with-occurrences-of-a-letter",
      "difficulty": "hard",
      "primaryPattern": "Stack",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy"
      ],
      "explanation": "LIFO structure for nested patterns, matching pairs, or maintaining monotonic sequences."
  },
  2032: {
      "title": "Two Out of Three",
      "slug": "two-out-of-three",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2033: {
      "title": "Minimum Operations to Make a Uni-Value Grid",
      "slug": "minimum-operations-to-make-a-uni-value-grid",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map",
          "DFS"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  2034: {
      "title": "Stock Price Fluctuation ",
      "slug": "stock-price-fluctuation",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Heap/Priority Queue"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2035: {
      "title": "Partition Array Into Two Arrays to Minimize Sum Difference",
      "slug": "partition-array-into-two-arrays-to-minimize-sum-difference",
      "difficulty": "hard",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map",
          "Binary Search",
          "Dynamic Programming"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  2037: {
      "title": "Minimum Number of Moves to Seat Everyone",
      "slug": "minimum-number-of-moves-to-seat-everyone",
      "difficulty": "easy",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  2038: {
      "title": "Remove Colored Pieces if Both Neighbors are the Same Color",
      "slug": "remove-colored-pieces-if-both-neighbors-are-the-same-color",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  2039: {
      "title": "The Time When the Network Becomes Idle",
      "slug": "the-time-when-the-network-becomes-idle",
      "difficulty": "medium",
      "primaryPattern": "BFS",
      "acceptablePatterns": [
          "Hash Map",
          "Graph"
      ],
      "explanation": "Breadth-first search - explore level by level using a queue. Ideal for shortest path in unweighted graphs or level-order traversal."
  },
  2040: {
      "title": "Kth Smallest Product of Two Sorted Arrays",
      "slug": "kth-smallest-product-of-two-sorted-arrays",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  2042: {
      "title": "Check if Numbers Are Ascending in a Sentence",
      "slug": "check-if-numbers-are-ascending-in-a-sentence",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2043: {
      "title": "Simple Bank System",
      "slug": "simple-bank-system",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2044: {
      "title": "Count Number of Maximum Bitwise-OR Subsets",
      "slug": "count-number-of-maximum-bitwise-or-subsets",
      "difficulty": "medium",
      "primaryPattern": "Backtracking",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Explore all possible solutions recursively. Build candidates incrementally and abandon paths that cannot lead to solution."
  },
  2045: {
      "title": "Second Minimum Time to Reach Destination",
      "slug": "second-minimum-time-to-reach-destination",
      "difficulty": "hard",
      "primaryPattern": "BFS",
      "acceptablePatterns": [
          "Graph"
      ],
      "explanation": "Breadth-first search - explore level by level using a queue. Ideal for shortest path in unweighted graphs or level-order traversal."
  },
  2047: {
      "title": "Number of Valid Words in a Sentence",
      "slug": "number-of-valid-words-in-a-sentence",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2048: {
      "title": "Next Greater Numerically Balanced Number",
      "slug": "next-greater-numerically-balanced-number",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Backtracking"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2049: {
      "title": "Count Nodes With the Highest Score",
      "slug": "count-nodes-with-the-highest-score",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map",
          "Tree Traversal"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  2050: {
      "title": "Parallel Courses III",
      "slug": "parallel-courses-iii",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Graph"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2053: {
      "title": "Kth Distinct String in an Array",
      "slug": "kth-distinct-string-in-an-array",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2054: {
      "title": "Two Best Non-Overlapping Events",
      "slug": "two-best-non-overlapping-events",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Dynamic Programming",
          "Two Pointers",
          "Heap/Priority Queue"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  2055: {
      "title": "Plates Between Candles",
      "slug": "plates-between-candles",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  2056: {
      "title": "Number of Valid Move Combinations On Chessboard",
      "slug": "number-of-valid-move-combinations-on-chessboard",
      "difficulty": "hard",
      "primaryPattern": "Backtracking",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Explore all possible solutions recursively. Build candidates incrementally and abandon paths that cannot lead to solution."
  },
  2057: {
      "title": "Smallest Index With Equal Value",
      "slug": "smallest-index-with-equal-value",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2058: {
      "title": "Find the Minimum and Maximum Number of Nodes Between Critical Points",
      "slug": "find-the-minimum-and-maximum-number-of-nodes-between-critical-points",
      "difficulty": "medium",
      "primaryPattern": "Linked List",
      "acceptablePatterns": [],
      "explanation": "Pointer manipulation for reversing, merging, detecting cycles, or finding intersections in linked structures."
  },
  2059: {
      "title": "Minimum Operations to Convert Number",
      "slug": "minimum-operations-to-convert-number",
      "difficulty": "medium",
      "primaryPattern": "BFS",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Breadth-first search - explore level by level using a queue. Ideal for shortest path in unweighted graphs or level-order traversal."
  },
  2060: {
      "title": "Check if an Original String Exists Given Two Encoded Strings",
      "slug": "check-if-an-original-string-exists-given-two-encoded-strings",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2062: {
      "title": "Count Vowel Substrings of a String",
      "slug": "count-vowel-substrings-of-a-string",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2063: {
      "title": "Vowels of All Substrings",
      "slug": "vowels-of-all-substrings",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2064: {
      "title": "Minimized Maximum of Products Distributed to Any Store",
      "slug": "minimized-maximum-of-products-distributed-to-any-store",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  2065: {
      "title": "Maximum Path Quality of a Graph",
      "slug": "maximum-path-quality-of-a-graph",
      "difficulty": "hard",
      "primaryPattern": "Backtracking",
      "acceptablePatterns": [
          "Hash Map",
          "Graph"
      ],
      "explanation": "Explore all possible solutions recursively. Build candidates incrementally and abandon paths that cannot lead to solution."
  },
  2068: {
      "title": "Check Whether Two Strings are Almost Equivalent",
      "slug": "check-whether-two-strings-are-almost-equivalent",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2069: {
      "title": "Walking Robot Simulation II",
      "slug": "walking-robot-simulation-ii",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2070: {
      "title": "Most Beautiful Item for Each Query",
      "slug": "most-beautiful-item-for-each-query",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  2071: {
      "title": "Maximum Number of Tasks You Can Assign",
      "slug": "maximum-number-of-tasks-you-can-assign",
      "difficulty": "hard",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map",
          "Binary Search",
          "Greedy",
          "BFS",
          "Sliding Window"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  2073: {
      "title": "Time Needed to Buy Tickets",
      "slug": "time-needed-to-buy-tickets",
      "difficulty": "easy",
      "primaryPattern": "BFS",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Breadth-first search - explore level by level using a queue. Ideal for shortest path in unweighted graphs or level-order traversal."
  },
  2074: {
      "title": "Reverse Nodes in Even Length Groups",
      "slug": "reverse-nodes-in-even-length-groups",
      "difficulty": "medium",
      "primaryPattern": "Linked List",
      "acceptablePatterns": [],
      "explanation": "Pointer manipulation for reversing, merging, detecting cycles, or finding intersections in linked structures."
  },
  2075: {
      "title": "Decode the Slanted Ciphertext",
      "slug": "decode-the-slanted-ciphertext",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2076: {
      "title": "Process Restricted Friend Requests",
      "slug": "process-restricted-friend-requests",
      "difficulty": "hard",
      "primaryPattern": "Graph",
      "acceptablePatterns": [],
      "explanation": "Graph algorithms - may involve topological sort, cycle detection, union find, or connectivity checks."
  },
  2078: {
      "title": "Two Furthest Houses With Different Colors",
      "slug": "two-furthest-houses-with-different-colors",
      "difficulty": "easy",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  2079: {
      "title": "Watering Plants",
      "slug": "watering-plants",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2080: {
      "title": "Range Frequency Queries",
      "slug": "range-frequency-queries",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Binary Search"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2081: {
      "title": "Sum of k-Mirror Numbers",
      "slug": "sum-of-k-mirror-numbers",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2085: {
      "title": "Count Common Words With One Occurrence",
      "slug": "count-common-words-with-one-occurrence",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2086: {
      "title": "Minimum Number of Food Buckets to Feed the Hamsters",
      "slug": "minimum-number-of-food-buckets-to-feed-the-hamsters",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2087: {
      "title": "Minimum Cost Homecoming of a Robot in a Grid",
      "slug": "minimum-cost-homecoming-of-a-robot-in-a-grid",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  2088: {
      "title": "Count Fertile Pyramids in a Land",
      "slug": "count-fertile-pyramids-in-a-land",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "DFS"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2089: {
      "title": "Find Target Indices After Sorting Array",
      "slug": "find-target-indices-after-sorting-array",
      "difficulty": "easy",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  2090: {
      "title": "K Radius Subarray Averages",
      "slug": "k-radius-subarray-averages",
      "difficulty": "medium",
      "primaryPattern": "Sliding Window",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Maintain a window of elements that slides through the array. Expand when adding elements, contract when removing. Track window state."
  },
  2091: {
      "title": "Removing Minimum and Maximum From Array",
      "slug": "removing-minimum-and-maximum-from-array",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  2092: {
      "title": "Find All People With Secret",
      "slug": "find-all-people-with-secret",
      "difficulty": "hard",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "BFS",
          "Graph",
          "Two Pointers"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  2094: {
      "title": "Finding 3-Digit Even Numbers",
      "slug": "finding-3-digit-even-numbers",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "DFS",
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2095: {
      "title": "Delete the Middle Node of a Linked List",
      "slug": "delete-the-middle-node-of-a-linked-list",
      "difficulty": "medium",
      "lists": [
          "leetcode-75"
      ],
      "category": "Linked List",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Linked List"
      ],
      "patternExplanations": {
          "Two Pointers": "Slow and fast pointers. When fast reaches end, slow is at middle. Need previous pointer to delete.",
          "Linked List": "Fast-slow technique finds middle in one pass without counting."
      },
      "hints": [
          "Middle node: for odd length it's center, for even it's floor(n/2)th.",
          "Fast moves 2x speed of slow. When fast reaches end, slow is at middle.",
          "Need to track node before slow to actually delete. Or use prev pointer."
      ],
      "solution": {
          "approach": "Slow, fast pointers. Track prev of slow. When fast done, prev.next = slow.next.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "keyInsight": "Fast/slow finds middle. Tracking prev allows deletion."
      }
  },
  2096: {
      "title": "Step-By-Step Directions From a Binary Tree Node to Another",
      "slug": "step-by-step-directions-from-a-binary-tree-node-to-another",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map",
          "Tree Traversal"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  2097: {
      "title": "Valid Arrangement of Pairs",
      "slug": "valid-arrangement-of-pairs",
      "difficulty": "hard",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Graph"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  2099: {
      "title": "Find Subsequence of Length K With the Largest Sum",
      "slug": "find-subsequence-of-length-k-with-the-largest-sum",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Two Pointers",
          "Heap/Priority Queue"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2100: {
      "title": "Find Good Days to Rob the Bank",
      "slug": "find-good-days-to-rob-the-bank",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2101: {
      "title": "Detonate the Maximum Bombs",
      "slug": "detonate-the-maximum-bombs",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map",
          "BFS",
          "Graph"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  2102: {
      "title": "Sequentially Ordinal Rank Tracker",
      "slug": "sequentially-ordinal-rank-tracker",
      "difficulty": "hard",
      "primaryPattern": "Heap/Priority Queue",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Maintain ordered access to min/max elements. Useful for k-largest/smallest, merging, or scheduling problems."
  },
  2103: {
      "title": "Rings and Rods",
      "slug": "rings-and-rods",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2104: {
      "title": "Sum of Subarray Ranges",
      "slug": "sum-of-subarray-ranges",
      "difficulty": "medium",
      "primaryPattern": "Stack",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "LIFO structure for nested patterns, matching pairs, or maintaining monotonic sequences."
  },
  2105: {
      "title": "Watering Plants II",
      "slug": "watering-plants-ii",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  2106: {
      "title": "Maximum Fruits Harvested After at Most K Steps",
      "slug": "maximum-fruits-harvested-after-at-most-k-steps",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Sliding Window"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  2108: {
      "title": "Find First Palindromic String in the Array",
      "slug": "find-first-palindromic-string-in-the-array",
      "difficulty": "easy",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  2109: {
      "title": "Adding Spaces to a String",
      "slug": "adding-spaces-to-a-string",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  2110: {
      "title": "Number of Smooth Descent Periods of a Stock",
      "slug": "number-of-smooth-descent-periods-of-a-stock",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map",
          "Dynamic Programming",
          "Sliding Window"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  2111: {
      "title": "Minimum Operations to Make the Array K-Increasing",
      "slug": "minimum-operations-to-make-the-array-k-increasing",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  2114: {
      "title": "Maximum Number of Words Found in Sentences",
      "slug": "maximum-number-of-words-found-in-sentences",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2115: {
      "title": "Find All Possible Recipes from Given Supplies",
      "slug": "find-all-possible-recipes-from-given-supplies",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Graph"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2116: {
      "title": "Check if a Parentheses String Can Be Valid",
      "slug": "check-if-a-parentheses-string-can-be-valid",
      "difficulty": "medium",
      "primaryPattern": "Stack",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy"
      ],
      "explanation": "LIFO structure for nested patterns, matching pairs, or maintaining monotonic sequences."
  },
  2117: {
      "title": "Abbreviating the Product of a Range",
      "slug": "abbreviating-the-product-of-a-range",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2119: {
      "title": "A Number After a Double Reversal",
      "slug": "a-number-after-a-double-reversal",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2120: {
      "title": "Execution of All Suffix Instructions Staying in a Grid",
      "slug": "execution-of-all-suffix-instructions-staying-in-a-grid",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2121: {
      "title": "Intervals Between Identical Elements",
      "slug": "intervals-between-identical-elements",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2122: {
      "title": "Recover the Original Array",
      "slug": "recover-the-original-array",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2124: {
      "title": "Check if All A's Appears Before All B's",
      "slug": "check-if-all-as-appears-before-all-bs",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2125: {
      "title": "Number of Laser Beams in a Bank",
      "slug": "number-of-laser-beams-in-a-bank",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  2126: {
      "title": "Destroying Asteroids",
      "slug": "destroying-asteroids",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  2127: {
      "title": "Maximum Employees to Be Invited to a Meeting",
      "slug": "maximum-employees-to-be-invited-to-a-meeting",
      "difficulty": "hard",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Graph"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  2129: {
      "title": "Capitalize the Title",
      "slug": "capitalize-the-title",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2130: {
      "title": "Maximum Twin Sum of a Linked List",
      "slug": "maximum-twin-sum-of-a-linked-list",
      "difficulty": "medium",
      "lists": [
          "leetcode-75"
      ],
      "category": "Linked List",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Linked List",
          "Stack"
      ],
      "patternExplanations": {
          "Two Pointers": "Find middle, reverse second half, then iterate both halves comparing sums.",
          "Linked List": "Classic technique: find middle, reverse, process.",
          "Stack": "Push first half values. Pop while iterating second half, calculate sums."
      },
      "hints": [
          "Twin: node i and node n-1-i. Sum of twins at opposite ends.",
          "Need to pair first node with last, second with second-to-last, etc.",
          "Reverse second half, then iterate both halves together calculating sums."
      ],
      "solution": {
          "approach": "Find middle (slow/fast). Reverse second half. Iterate both halves, track max sum.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "keyInsight": "Reversing second half enables O(1) space twin pairing."
      }
  },
  2131: {
      "title": "Longest Palindrome by Concatenating Two Letter Words",
      "slug": "longest-palindrome-by-concatenating-two-letter-words",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Greedy"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2132: {
      "title": "Stamping the Grid",
      "slug": "stamping-the-grid",
      "difficulty": "hard",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "DFS"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  2133: {
      "title": "Check if Every Row and Column Contains All Numbers",
      "slug": "check-if-every-row-and-column-contains-all-numbers",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "DFS"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2134: {
      "title": "Minimum Swaps to Group All 1's Together II",
      "slug": "minimum-swaps-to-group-all-1s-together-ii",
      "difficulty": "medium",
      "primaryPattern": "Sliding Window",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Maintain a window of elements that slides through the array. Expand when adding elements, contract when removing. Track window state."
  },
  2135: {
      "title": "Count Words Obtained After Adding a Letter",
      "slug": "count-words-obtained-after-adding-a-letter",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2136: {
      "title": "Earliest Possible Day of Full Bloom",
      "slug": "earliest-possible-day-of-full-bloom",
      "difficulty": "hard",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  2138: {
      "title": "Divide a String Into Groups of Size k",
      "slug": "divide-a-string-into-groups-of-size-k",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2139: {
      "title": "Minimum Moves to Reach Target Score",
      "slug": "minimum-moves-to-reach-target-score",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  2140: {
      "title": "Solving Questions With Brainpower",
      "slug": "solving-questions-with-brainpower",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2141: {
      "title": "Maximum Running Time of N Computers",
      "slug": "maximum-running-time-of-n-computers",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy",
          "Two Pointers"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  2144: {
      "title": "Minimum Cost of Buying Candies With Discount",
      "slug": "minimum-cost-of-buying-candies-with-discount",
      "difficulty": "easy",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  2145: {
      "title": "Count the Hidden Sequences",
      "slug": "count-the-hidden-sequences",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2146: {
      "title": "K Highest Ranked Items Within a Price Range",
      "slug": "k-highest-ranked-items-within-a-price-range",
      "difficulty": "medium",
      "primaryPattern": "BFS",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers",
          "Heap/Priority Queue",
          "DFS"
      ],
      "explanation": "Breadth-first search - explore level by level using a queue. Ideal for shortest path in unweighted graphs or level-order traversal."
  },
  2147: {
      "title": "Number of Ways to Divide a Long Corridor",
      "slug": "number-of-ways-to-divide-a-long-corridor",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2148: {
      "title": "Count Elements With Strictly Smaller and Greater Elements ",
      "slug": "count-elements-with-strictly-smaller-and-greater-elements",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2149: {
      "title": "Rearrange Array Elements by Sign",
      "slug": "rearrange-array-elements-by-sign",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  2150: {
      "title": "Find All Lonely Numbers in the Array",
      "slug": "find-all-lonely-numbers-in-the-array",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2151: {
      "title": "Maximum Good People Based on Statements",
      "slug": "maximum-good-people-based-on-statements",
      "difficulty": "hard",
      "primaryPattern": "Backtracking",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Explore all possible solutions recursively. Build candidates incrementally and abandon paths that cannot lead to solution."
  },
  2154: {
      "title": "Keep Multiplying Found Values by Two",
      "slug": "keep-multiplying-found-values-by-two",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2155: {
      "title": "All Divisions With the Highest Score of a Binary Array",
      "slug": "all-divisions-with-the-highest-score-of-a-binary-array",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2156: {
      "title": "Find Substring With Given Hash Value",
      "slug": "find-substring-with-given-hash-value",
      "difficulty": "hard",
      "primaryPattern": "Sliding Window",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Maintain a window of elements that slides through the array. Expand when adding elements, contract when removing. Track window state."
  },
  2157: {
      "title": "Groups of Strings",
      "slug": "groups-of-strings",
      "difficulty": "hard",
      "primaryPattern": "Graph",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Graph algorithms - may involve topological sort, cycle detection, union find, or connectivity checks."
  },
  2160: {
      "title": "Minimum Sum of Four Digit Number After Splitting Digits",
      "slug": "minimum-sum-of-four-digit-number-after-splitting-digits",
      "difficulty": "easy",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  2161: {
      "title": "Partition Array According to Given Pivot",
      "slug": "partition-array-according-to-given-pivot",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  2162: {
      "title": "Minimum Cost to Set Cooking Time",
      "slug": "minimum-cost-to-set-cooking-time",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2163: {
      "title": "Minimum Difference in Sums After Removal of Elements",
      "slug": "minimum-difference-in-sums-after-removal-of-elements",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Heap/Priority Queue"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2164: {
      "title": "Sort Even and Odd Indices Independently",
      "slug": "sort-even-and-odd-indices-independently",
      "difficulty": "easy",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  2165: {
      "title": "Smallest Value of the Rearranged Number",
      "slug": "smallest-value-of-the-rearranged-number",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  2166: {
      "title": "Design Bitset",
      "slug": "design-bitset",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2167: {
      "title": "Minimum Time to Remove All Cars Containing Illegal Goods",
      "slug": "minimum-time-to-remove-all-cars-containing-illegal-goods",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2169: {
      "title": "Count Operations to Obtain Zero",
      "slug": "count-operations-to-obtain-zero",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2170: {
      "title": "Minimum Operations to Make the Array Alternating",
      "slug": "minimum-operations-to-make-the-array-alternating",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Greedy"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2171: {
      "title": "Removing Minimum Number of Magic Beans",
      "slug": "removing-minimum-number-of-magic-beans",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  2172: {
      "title": "Maximum AND Sum of Array",
      "slug": "maximum-and-sum-of-array",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2176: {
      "title": "Count Equal and Divisible Pairs in an Array",
      "slug": "count-equal-and-divisible-pairs-in-an-array",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2177: {
      "title": "Find Three Consecutive Integers That Sum to a Given Number",
      "slug": "find-three-consecutive-integers-that-sum-to-a-given-number",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2178: {
      "title": "Maximum Split of Positive Even Integers",
      "slug": "maximum-split-of-positive-even-integers",
      "difficulty": "medium",
      "primaryPattern": "Backtracking",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy"
      ],
      "explanation": "Explore all possible solutions recursively. Build candidates incrementally and abandon paths that cannot lead to solution."
  },
  2179: {
      "title": "Count Good Triplets in an Array",
      "slug": "count-good-triplets-in-an-array",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  2180: {
      "title": "Count Integers With Even Digit Sum",
      "slug": "count-integers-with-even-digit-sum",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2181: {
      "title": "Merge Nodes in Between Zeros",
      "slug": "merge-nodes-in-between-zeros",
      "difficulty": "medium",
      "primaryPattern": "Linked List",
      "acceptablePatterns": [],
      "explanation": "Pointer manipulation for reversing, merging, detecting cycles, or finding intersections in linked structures."
  },
  2182: {
      "title": "Construct String With Repeat Limit",
      "slug": "construct-string-with-repeat-limit",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Greedy",
          "Heap/Priority Queue"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2183: {
      "title": "Count Array Pairs Divisible by K",
      "slug": "count-array-pairs-divisible-by-k",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2185: {
      "title": "Counting Words With a Given Prefix",
      "slug": "counting-words-with-a-given-prefix",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2186: {
      "title": "Minimum Number of Steps to Make Two Strings Anagram II",
      "slug": "minimum-number-of-steps-to-make-two-strings-anagram-ii",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2187: {
      "title": "Minimum Time to Complete Trips",
      "slug": "minimum-time-to-complete-trips",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  2188: {
      "title": "Minimum Time to Finish the Race",
      "slug": "minimum-time-to-finish-the-race",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2190: {
      "title": "Most Frequent Number Following Key In an Array",
      "slug": "most-frequent-number-following-key-in-an-array",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2191: {
      "title": "Sort the Jumbled Numbers",
      "slug": "sort-the-jumbled-numbers",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  2192: {
      "title": "All Ancestors of a Node in a Directed Acyclic Graph",
      "slug": "all-ancestors-of-a-node-in-a-directed-acyclic-graph",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "BFS",
          "Graph"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  2193: {
      "title": "Minimum Number of Moves to Make Palindrome",
      "slug": "minimum-number-of-moves-to-make-palindrome",
      "difficulty": "hard",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  2194: {
      "title": "Cells in a Range on an Excel Sheet",
      "slug": "cells-in-a-range-on-an-excel-sheet",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2195: {
      "title": "Append K Integers With Minimal Sum",
      "slug": "append-k-integers-with-minimal-sum",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  2196: {
      "title": "Create Binary Tree From Descriptions",
      "slug": "create-binary-tree-from-descriptions",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Tree Traversal"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2197: {
      "title": "Replace Non-Coprime Numbers in Array",
      "slug": "replace-non-coprime-numbers-in-array",
      "difficulty": "hard",
      "primaryPattern": "Stack",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "LIFO structure for nested patterns, matching pairs, or maintaining monotonic sequences."
  },
  2200: {
      "title": "Find All K-Distant Indices in an Array",
      "slug": "find-all-k-distant-indices-in-an-array",
      "difficulty": "easy",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  2201: {
      "title": "Count Artifacts That Can Be Extracted",
      "slug": "count-artifacts-that-can-be-extracted",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2202: {
      "title": "Maximize the Topmost Element After K Moves",
      "slug": "maximize-the-topmost-element-after-k-moves",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  2203: {
      "title": "Minimum Weighted Subgraph With the Required Paths",
      "slug": "minimum-weighted-subgraph-with-the-required-paths",
      "difficulty": "hard",
      "primaryPattern": "Graph",
      "acceptablePatterns": [
          "BFS"
      ],
      "explanation": "Graph algorithms - may involve topological sort, cycle detection, union find, or connectivity checks."
  },
  2206: {
      "title": "Divide Array Into Equal Pairs",
      "slug": "divide-array-into-equal-pairs",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2207: {
      "title": "Maximize Number of Subsequences in a String",
      "slug": "maximize-number-of-subsequences-in-a-string",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  2208: {
      "title": "Minimum Operations to Halve Array Sum",
      "slug": "minimum-operations-to-halve-array-sum",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Heap/Priority Queue"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  2209: {
      "title": "Minimum White Tiles After Covering With Carpets",
      "slug": "minimum-white-tiles-after-covering-with-carpets",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2210: {
      "title": "Count Hills and Valleys in an Array",
      "slug": "count-hills-and-valleys-in-an-array",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2211: {
      "title": "Count Collisions on a Road",
      "slug": "count-collisions-on-a-road",
      "difficulty": "medium",
      "primaryPattern": "Stack",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "LIFO structure for nested patterns, matching pairs, or maintaining monotonic sequences."
  },
  2212: {
      "title": "Maximum Points in an Archery Competition",
      "slug": "maximum-points-in-an-archery-competition",
      "difficulty": "medium",
      "primaryPattern": "Backtracking",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Explore all possible solutions recursively. Build candidates incrementally and abandon paths that cannot lead to solution."
  },
  2213: {
      "title": "Longest Substring of One Repeating Character",
      "slug": "longest-substring-of-one-repeating-character",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2215: {
      "title": "Find the Difference of Two Arrays",
      "slug": "find-the-difference-of-two-arrays",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships.",
      "lists": [
          "leetcode-75"
      ],
      "category": "Hash Map",
      "patternExplanations": {
          "Hash Map": "Use sets for each array. Find set differences: nums1 - nums2 and nums2 - nums1."
      },
      "hints": [
          "Find elements in nums1 not in nums2, and vice versa.",
          "Convert arrays to sets. Use set difference.",
          "result[0] = set(nums1) - set(nums2), result[1] = set(nums2) - set(nums1)."
      ],
      "solution": {
          "approach": "Convert to sets. Return [elements in set1 but not set2, elements in set2 but not set1].",
          "timeComplexity": "O(n + m)",
          "spaceComplexity": "O(n + m)",
          "keyInsight": "Set difference is the key operation. Sets handle duplicates automatically."
      }
  },
  2216: {
      "title": "Minimum Deletions to Make Array Beautiful",
      "slug": "minimum-deletions-to-make-array-beautiful",
      "difficulty": "medium",
      "primaryPattern": "Stack",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy"
      ],
      "explanation": "LIFO structure for nested patterns, matching pairs, or maintaining monotonic sequences."
  },
  2217: {
      "title": "Find Palindrome With Fixed Length",
      "slug": "find-palindrome-with-fixed-length",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2218: {
      "title": "Maximum Value of K Coins From Piles",
      "slug": "maximum-value-of-k-coins-from-piles",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2220: {
      "title": "Minimum Bit Flips to Convert Number",
      "slug": "minimum-bit-flips-to-convert-number",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2221: {
      "title": "Find Triangular Sum of an Array",
      "slug": "find-triangular-sum-of-an-array",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2222: {
      "title": "Number of Ways to Select Buildings",
      "slug": "number-of-ways-to-select-buildings",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2223: {
      "title": "Sum of Scores of Built Strings",
      "slug": "sum-of-scores-of-built-strings",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  2224: {
      "title": "Minimum Number of Operations to Convert Time",
      "slug": "minimum-number-of-operations-to-convert-time",
      "difficulty": "easy",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  2225: {
      "title": "Find Players With Zero or One Losses",
      "slug": "find-players-with-zero-or-one-losses",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2226: {
      "title": "Maximum Candies Allocated to K Children",
      "slug": "maximum-candies-allocated-to-k-children",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  2227: {
      "title": "Encrypt and Decrypt Strings",
      "slug": "encrypt-and-decrypt-strings",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Trie"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2231: {
      "title": "Largest Number After Digit Swaps by Parity",
      "slug": "largest-number-after-digit-swaps-by-parity",
      "difficulty": "easy",
      "primaryPattern": "Heap/Priority Queue",
      "acceptablePatterns": [
          "Two Pointers"
      ],
      "explanation": "Maintain ordered access to min/max elements. Useful for k-largest/smallest, merging, or scheduling problems."
  },
  2232: {
      "title": "Minimize Result by Adding Parentheses to Expression",
      "slug": "minimize-result-by-adding-parentheses-to-expression",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2233: {
      "title": "Maximum Product After K Increments",
      "slug": "maximum-product-after-k-increments",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Heap/Priority Queue"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  2234: {
      "title": "Maximum Total Beauty of the Gardens",
      "slug": "maximum-total-beauty-of-the-gardens",
      "difficulty": "hard",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map",
          "Binary Search",
          "Greedy"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  2235: {
      "title": "Add Two Integers",
      "slug": "add-two-integers",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2236: {
      "title": "Root Equals Sum of Children",
      "slug": "root-equals-sum-of-children",
      "difficulty": "easy",
      "primaryPattern": "Tree Traversal",
      "acceptablePatterns": [],
      "explanation": "Navigate tree structures using inorder, preorder, or postorder traversal. Consider recursive or iterative approaches."
  },
  2239: {
      "title": "Find Closest Number to Zero",
      "slug": "find-closest-number-to-zero",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2240: {
      "title": "Number of Ways to Buy Pens and Pencils",
      "slug": "number-of-ways-to-buy-pens-and-pencils",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2241: {
      "title": "Design an ATM Machine",
      "slug": "design-an-atm-machine",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  2242: {
      "title": "Maximum Score of a Node Sequence",
      "slug": "maximum-score-of-a-node-sequence",
      "difficulty": "hard",
      "primaryPattern": "Graph",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Graph algorithms - may involve topological sort, cycle detection, union find, or connectivity checks."
  },
  2243: {
      "title": "Calculate Digit Sum of a String",
      "slug": "calculate-digit-sum-of-a-string",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2244: {
      "title": "Minimum Rounds to Complete All Tasks",
      "slug": "minimum-rounds-to-complete-all-tasks",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Greedy"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2245: {
      "title": "Maximum Trailing Zeros in a Cornered Path",
      "slug": "maximum-trailing-zeros-in-a-cornered-path",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "DFS"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2246: {
      "title": "Longest Path With Different Adjacent Characters",
      "slug": "longest-path-with-different-adjacent-characters",
      "difficulty": "hard",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map",
          "Tree Traversal",
          "Graph"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  2248: {
      "title": "Intersection of Multiple Arrays",
      "slug": "intersection-of-multiple-arrays",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2249: {
      "title": "Count Lattice Points Inside a Circle",
      "slug": "count-lattice-points-inside-a-circle",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2250: {
      "title": "Count Number of Rectangles Containing Each Point",
      "slug": "count-number-of-rectangles-containing-each-point",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Binary Search",
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2251: {
      "title": "Number of Flowers in Full Bloom",
      "slug": "number-of-flowers-in-full-bloom",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Binary Search",
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2255: {
      "title": "Count Prefixes of a Given String",
      "slug": "count-prefixes-of-a-given-string",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2256: {
      "title": "Minimum Average Difference",
      "slug": "minimum-average-difference",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2257: {
      "title": "Count Unguarded Cells in the Grid",
      "slug": "count-unguarded-cells-in-the-grid",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  2258: {
      "title": "Escape the Spreading Fire",
      "slug": "escape-the-spreading-fire",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "BFS",
          "DFS"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  2259: {
      "title": "Remove Digit From Number to Maximize Result",
      "slug": "remove-digit-from-number-to-maximize-result",
      "difficulty": "easy",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  2260: {
      "title": "Minimum Consecutive Cards to Pick Up",
      "slug": "minimum-consecutive-cards-to-pick-up",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Sliding Window"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2261: {
      "title": "K Divisible Elements Subarrays",
      "slug": "k-divisible-elements-subarrays",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Trie"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2262: {
      "title": "Total Appeal of A String",
      "slug": "total-appeal-of-a-string",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Dynamic Programming"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2264: {
      "title": "Largest 3-Same-Digit Number in String",
      "slug": "largest-3-same-digit-number-in-string",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2265: {
      "title": "Count Nodes Equal to Average of Subtree",
      "slug": "count-nodes-equal-to-average-of-subtree",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Tree Traversal"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  2266: {
      "title": "Count Number of Texts",
      "slug": "count-number-of-texts",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Dynamic Programming"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2267: {
      "title": " Check if There Is a Valid Parentheses String Path",
      "slug": "check-if-there-is-a-valid-parentheses-string-path",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "DFS"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2269: {
      "title": "Find the K-Beauty of a Number",
      "slug": "find-the-k-beauty-of-a-number",
      "difficulty": "easy",
      "primaryPattern": "Sliding Window",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Maintain a window of elements that slides through the array. Expand when adding elements, contract when removing. Track window state."
  },
  2270: {
      "title": "Number of Ways to Split Array",
      "slug": "number-of-ways-to-split-array",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2271: {
      "title": "Maximum White Tiles Covered by a Carpet",
      "slug": "maximum-white-tiles-covered-by-a-carpet",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy",
          "Sliding Window",
          "Two Pointers"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  2272: {
      "title": "Substring With Largest Variance",
      "slug": "substring-with-largest-variance",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2273: {
      "title": "Find Resultant Array After Removing Anagrams",
      "slug": "find-resultant-array-after-removing-anagrams",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2274: {
      "title": "Maximum Consecutive Floors Without Special Floors",
      "slug": "maximum-consecutive-floors-without-special-floors",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  2275: {
      "title": "Largest Combination With Bitwise AND Greater Than Zero",
      "slug": "largest-combination-with-bitwise-and-greater-than-zero",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2276: {
      "title": "Count Integers in Intervals",
      "slug": "count-integers-in-intervals",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2278: {
      "title": "Percentage of Letter in String",
      "slug": "percentage-of-letter-in-string",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2279: {
      "title": "Maximum Bags With Full Capacity of Rocks",
      "slug": "maximum-bags-with-full-capacity-of-rocks",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  2280: {
      "title": "Minimum Lines to Represent a Line Chart",
      "slug": "minimum-lines-to-represent-a-line-chart",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2281: {
      "title": "Sum of Total Strength of Wizards",
      "slug": "sum-of-total-strength-of-wizards",
      "difficulty": "hard",
      "primaryPattern": "Stack",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "LIFO structure for nested patterns, matching pairs, or maintaining monotonic sequences."
  },
  2283: {
      "title": "Check if Number Has Equal Digit Count and Digit Value",
      "slug": "check-if-number-has-equal-digit-count-and-digit-value",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2284: {
      "title": "Sender With Largest Word Count",
      "slug": "sender-with-largest-word-count",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2285: {
      "title": "Maximum Total Importance of Roads",
      "slug": "maximum-total-importance-of-roads",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Graph",
          "Two Pointers",
          "Heap/Priority Queue"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  2286: {
      "title": "Booking Concert Tickets in Groups",
      "slug": "booking-concert-tickets-in-groups",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  2287: {
      "title": "Rearrange Characters to Make Target String",
      "slug": "rearrange-characters-to-make-target-string",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2288: {
      "title": "Apply Discount to Prices",
      "slug": "apply-discount-to-prices",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2289: {
      "title": "Steps to Make Array Non-decreasing",
      "slug": "steps-to-make-array-non-decreasing",
      "difficulty": "medium",
      "primaryPattern": "Linked List",
      "acceptablePatterns": [
          "Hash Map",
          "Stack"
      ],
      "explanation": "Pointer manipulation for reversing, merging, detecting cycles, or finding intersections in linked structures."
  },
  2290: {
      "title": "Minimum Obstacle Removal to Reach Corner",
      "slug": "minimum-obstacle-removal-to-reach-corner",
      "difficulty": "hard",
      "primaryPattern": "BFS",
      "acceptablePatterns": [
          "Hash Map",
          "Graph",
          "Heap/Priority Queue",
          "DFS"
      ],
      "explanation": "Breadth-first search - explore level by level using a queue. Ideal for shortest path in unweighted graphs or level-order traversal."
  },
  2293: {
      "title": "Min Max Game",
      "slug": "min-max-game",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2294: {
      "title": "Partition Array Such That Maximum Difference Is K",
      "slug": "partition-array-such-that-maximum-difference-is-k",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  2295: {
      "title": "Replace Elements in an Array",
      "slug": "replace-elements-in-an-array",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2296: {
      "title": "Design a Text Editor",
      "slug": "design-a-text-editor",
      "difficulty": "hard",
      "primaryPattern": "Linked List",
      "acceptablePatterns": [
          "Hash Map",
          "Stack"
      ],
      "explanation": "Pointer manipulation for reversing, merging, detecting cycles, or finding intersections in linked structures."
  },
  2299: {
      "title": "Strong Password Checker II",
      "slug": "strong-password-checker-ii",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2300: {
      "title": "Successful Pairs of Spells and Potions",
      "slug": "successful-pairs-of-spells-and-potions",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds.",
      "lists": [
          "leetcode-75"
      ],
      "category": "Binary Search",
      "patternExplanations": {
          "Binary Search": "Sort potions. For each spell, binary search for min potion where spell*potion >= success."
      },
      "hints": [
          "For each spell, count potions where spell * potion >= success.",
          "Potion threshold: success / spell (rounded up). Count potions >= threshold.",
          "Sort potions. Binary search for first potion >= threshold. All after it are successful."
      ],
      "solution": {
          "approach": "Sort potions. For each spell, binary search for min potion s.t. spell*potion >= success. Count = n - index.",
          "timeComplexity": "O((n + m) log n)",
          "spaceComplexity": "O(n) for sorting",
          "keyInsight": "Sorting allows binary search. Threshold = ceil(success / spell)."
      }
  },
  2301: {
      "title": "Match Substring After Replacement",
      "slug": "match-substring-after-replacement",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2302: {
      "title": "Count Subarrays With Score Less Than K",
      "slug": "count-subarrays-with-score-less-than-k",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Sliding Window"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  2303: {
      "title": "Calculate Amount Paid in Taxes",
      "slug": "calculate-amount-paid-in-taxes",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2304: {
      "title": "Minimum Path Cost in a Grid",
      "slug": "minimum-path-cost-in-a-grid",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "DFS"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2305: {
      "title": "Fair Distribution of Cookies",
      "slug": "fair-distribution-of-cookies",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Backtracking"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2306: {
      "title": "Naming a Company",
      "slug": "naming-a-company",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2309: {
      "title": "Greatest English Letter in Upper and Lower Case",
      "slug": "greatest-english-letter-in-upper-and-lower-case",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2310: {
      "title": "Sum of Numbers With Units Digit K",
      "slug": "sum-of-numbers-with-units-digit-k",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2311: {
      "title": "Longest Binary Subsequence Less Than or Equal to K",
      "slug": "longest-binary-subsequence-less-than-or-equal-to-k",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2312: {
      "title": "Selling Pieces of Wood",
      "slug": "selling-pieces-of-wood",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2315: {
      "title": "Count Asterisks",
      "slug": "count-asterisks",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2316: {
      "title": "Count Unreachable Pairs of Nodes in an Undirected Graph",
      "slug": "count-unreachable-pairs-of-nodes-in-an-undirected-graph",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "BFS",
          "Graph"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  2317: {
      "title": "Maximum XOR After Operations ",
      "slug": "maximum-xor-after-operations",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2318: {
      "title": "Number of Distinct Roll Sequences",
      "slug": "number-of-distinct-roll-sequences",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2319: {
      "title": "Check if Matrix Is X-Matrix",
      "slug": "check-if-matrix-is-x-matrix",
      "difficulty": "easy",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  2320: {
      "title": "Count Number of Ways to Place Houses",
      "slug": "count-number-of-ways-to-place-houses",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2321: {
      "title": "Maximum Score Of Spliced Array",
      "slug": "maximum-score-of-spliced-array",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2322: {
      "title": "Minimum Score After Removals on a Tree",
      "slug": "minimum-score-after-removals-on-a-tree",
      "difficulty": "hard",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map",
          "Tree Traversal"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  2325: {
      "title": "Decode the Message",
      "slug": "decode-the-message",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2326: {
      "title": "Spiral Matrix IV",
      "slug": "spiral-matrix-iv",
      "difficulty": "medium",
      "primaryPattern": "Linked List",
      "acceptablePatterns": [
          "Hash Map",
          "DFS"
      ],
      "explanation": "Pointer manipulation for reversing, merging, detecting cycles, or finding intersections in linked structures."
  },
  2327: {
      "title": "Number of People Aware of a Secret",
      "slug": "number-of-people-aware-of-a-secret",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "BFS"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2328: {
      "title": "Number of Increasing Paths in a Grid",
      "slug": "number-of-increasing-paths-in-a-grid",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "DFS",
          "BFS",
          "Graph"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2331: {
      "title": "Evaluate Boolean Binary Tree",
      "slug": "evaluate-boolean-binary-tree",
      "difficulty": "easy",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Tree Traversal"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  2332: {
      "title": "The Latest Time to Catch a Bus",
      "slug": "the-latest-time-to-catch-a-bus",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map",
          "Binary Search"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  2333: {
      "title": "Minimum Sum of Squared Difference",
      "slug": "minimum-sum-of-squared-difference",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy",
          "Two Pointers",
          "Heap/Priority Queue"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  2334: {
      "title": "Subarray With Elements Greater Than Varying Threshold",
      "slug": "subarray-with-elements-greater-than-varying-threshold",
      "difficulty": "hard",
      "primaryPattern": "Stack",
      "acceptablePatterns": [
          "Hash Map",
          "Graph"
      ],
      "explanation": "LIFO structure for nested patterns, matching pairs, or maintaining monotonic sequences."
  },
  2335: {
      "title": "Minimum Amount of Time to Fill Cups",
      "slug": "minimum-amount-of-time-to-fill-cups",
      "difficulty": "easy",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers",
          "Heap/Priority Queue"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  2336: {
      "title": "Smallest Number in Infinite Set",
      "slug": "smallest-number-in-infinite-set",
      "difficulty": "medium",
      "primaryPattern": "Heap",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships.",
      "lists": [
          "leetcode-75"
      ],
      "category": "Heap / Priority Queue",
      "patternExplanations": {
          "Heap": "Min-heap tracks next available numbers. Set tracks removed numbers added back.",
          "Hash Map": "Track removed numbers. Smallest not removed is answer unless all small ones removed."
      },
      "hints": [
          "Initially, smallest is 1. popSmallest returns smallest and removes it.",
          "addBack puts a number back (if it was removed).",
          "Use heap for efficiency. Track what's been removed to handle addBack."
      ],
      "solution": {
          "approach": "Min-heap starts with 1. addBack: push to heap if was removed (track in set). popSmallest: pop from heap.",
          "timeComplexity": "O(log n) per operation",
          "spaceComplexity": "O(n)",
          "keyInsight": "Heap gives smallest available. Set tracks what was removed (for addBack validation)."
      }
  },
  2337: {
      "title": "Move Pieces to Obtain a String",
      "slug": "move-pieces-to-obtain-a-string",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  2338: {
      "title": "Count the Number of Ideal Arrays",
      "slug": "count-the-number-of-ideal-arrays",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2341: {
      "title": "Maximum Number of Pairs in Array",
      "slug": "maximum-number-of-pairs-in-array",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2342: {
      "title": "Max Sum of a Pair With Equal Sum of Digits",
      "slug": "max-sum-of-a-pair-with-equal-sum-of-digits",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Two Pointers",
          "Heap/Priority Queue"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2343: {
      "title": "Query Kth Smallest Trimmed Number",
      "slug": "query-kth-smallest-trimmed-number",
      "difficulty": "medium",
      "primaryPattern": "Heap/Priority Queue",
      "acceptablePatterns": [
          "Hash Map",
          "Binary Search",
          "Two Pointers"
      ],
      "explanation": "Maintain ordered access to min/max elements. Useful for k-largest/smallest, merging, or scheduling problems."
  },
  2344: {
      "title": "Minimum Deletions to Make Array Divisible",
      "slug": "minimum-deletions-to-make-array-divisible",
      "difficulty": "hard",
      "primaryPattern": "Heap/Priority Queue",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Maintain ordered access to min/max elements. Useful for k-largest/smallest, merging, or scheduling problems."
  },
  2347: {
      "title": "Best Poker Hand",
      "slug": "best-poker-hand",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2348: {
      "title": "Number of Zero-Filled Subarrays",
      "slug": "number-of-zero-filled-subarrays",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2349: {
      "title": "Design a Number Container System",
      "slug": "design-a-number-container-system",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Heap/Priority Queue"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2350: {
      "title": "Shortest Impossible Sequence of Rolls",
      "slug": "shortest-impossible-sequence-of-rolls",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Greedy"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2351: {
      "title": "First Letter to Appear Twice",
      "slug": "first-letter-to-appear-twice",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2352: {
      "title": "Equal Row and Column Pairs",
      "slug": "equal-row-and-column-pairs",
      "difficulty": "medium",
      "lists": [
          "leetcode-75"
      ],
      "category": "Hash Map / Set",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "patternExplanations": {
          "Hash Map": "Convert each row to a string/tuple key. Count row occurrences. For each column, check if it matches any row key."
      },
      "hints": [
          "Count pairs (r, c) where row r equals column c.",
          "Convert rows to a hashable form (tuple or string). Count occurrences.",
          "For each column, convert to same form, add count of matching rows."
      ],
      "solution": {
          "approach": "Map row -> count. For each column, look up in map and add to result.",
          "timeComplexity": "O(n^2)",
          "spaceComplexity": "O(n^2)",
          "keyInsight": "Hash rows for O(1) lookup when checking columns."
      }
  },
  2353: {
      "title": "Design a Food Rating System",
      "slug": "design-a-food-rating-system",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Heap/Priority Queue"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2354: {
      "title": "Number of Excellent Pairs",
      "slug": "number-of-excellent-pairs",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Binary Search"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2356: {
      "title": "Number of Unique Subjects Taught by Each Teacher",
      "slug": "number-of-unique-subjects-taught-by-each-teacher",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2357: {
      "title": "Make Array Zero by Subtracting Equal Amounts",
      "slug": "make-array-zero-by-subtracting-equal-amounts",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Greedy",
          "Two Pointers",
          "Heap/Priority Queue"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2358: {
      "title": "Maximum Number of Groups Entering a Competition",
      "slug": "maximum-number-of-groups-entering-a-competition",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  2359: {
      "title": "Find Closest Node to Given Two Nodes",
      "slug": "find-closest-node-to-given-two-nodes",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Graph"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  2360: {
      "title": "Longest Cycle in a Graph",
      "slug": "longest-cycle-in-a-graph",
      "difficulty": "hard",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "BFS",
          "Graph"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  2363: {
      "title": "Merge Similar Items",
      "slug": "merge-similar-items",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2364: {
      "title": "Count Number of Bad Pairs",
      "slug": "count-number-of-bad-pairs",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2365: {
      "title": "Task Scheduler II",
      "slug": "task-scheduler-ii",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2366: {
      "title": "Minimum Replacements to Sort the Array",
      "slug": "minimum-replacements-to-sort-the-array",
      "difficulty": "hard",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  2367: {
      "title": "Number of Arithmetic Triplets",
      "slug": "number-of-arithmetic-triplets",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2368: {
      "title": "Reachable Nodes With Restrictions",
      "slug": "reachable-nodes-with-restrictions",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Tree Traversal",
          "DFS",
          "BFS",
          "Graph"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2369: {
      "title": "Check if There is a Valid Partition For The Array",
      "slug": "check-if-there-is-a-valid-partition-for-the-array",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2370: {
      "title": "Longest Ideal Subsequence",
      "slug": "longest-ideal-subsequence",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Dynamic Programming"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2373: {
      "title": "Largest Local Values in a Matrix",
      "slug": "largest-local-values-in-a-matrix",
      "difficulty": "easy",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  2374: {
      "title": "Node With Highest Edge Score",
      "slug": "node-with-highest-edge-score",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Graph"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2375: {
      "title": "Construct Smallest Number From DI String",
      "slug": "construct-smallest-number-from-di-string",
      "difficulty": "medium",
      "primaryPattern": "Backtracking",
      "acceptablePatterns": [
          "Hash Map",
          "Stack",
          "Greedy"
      ],
      "explanation": "Explore all possible solutions recursively. Build candidates incrementally and abandon paths that cannot lead to solution."
  },
  2376: {
      "title": "Count Special Integers",
      "slug": "count-special-integers",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2379: {
      "title": "Minimum Recolors to Get K Consecutive Black Blocks",
      "slug": "minimum-recolors-to-get-k-consecutive-black-blocks",
      "difficulty": "easy",
      "primaryPattern": "Sliding Window",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Maintain a window of elements that slides through the array. Expand when adding elements, contract when removing. Track window state."
  },
  2380: {
      "title": "Time Needed to Rearrange a Binary String",
      "slug": "time-needed-to-rearrange-a-binary-string",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2381: {
      "title": "Shifting Letters II",
      "slug": "shifting-letters-ii",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2382: {
      "title": "Maximum Segment Sum After Removals",
      "slug": "maximum-segment-sum-after-removals",
      "difficulty": "hard",
      "primaryPattern": "Graph",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Graph algorithms - may involve topological sort, cycle detection, union find, or connectivity checks."
  },
  2383: {
      "title": "Minimum Hours of Training to Win a Competition",
      "slug": "minimum-hours-of-training-to-win-a-competition",
      "difficulty": "easy",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  2384: {
      "title": "Largest Palindromic Number",
      "slug": "largest-palindromic-number",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Greedy"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2385: {
      "title": "Amount of Time for Binary Tree to Be Infected",
      "slug": "amount-of-time-for-binary-tree-to-be-infected",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Tree Traversal",
          "DFS",
          "BFS"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2386: {
      "title": "Find the K-Sum of an Array",
      "slug": "find-the-k-sum-of-an-array",
      "difficulty": "hard",
      "primaryPattern": "Heap/Priority Queue",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Maintain ordered access to min/max elements. Useful for k-largest/smallest, merging, or scheduling problems."
  },
  2389: {
      "title": "Longest Subsequence With Limited Sum",
      "slug": "longest-subsequence-with-limited-sum",
      "difficulty": "easy",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy",
          "Two Pointers"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  2390: {
      "title": "Removing Stars From a String",
      "slug": "removing-stars-from-a-string",
      "difficulty": "medium",
      "lists": [
          "leetcode-75"
      ],
      "category": "Stack",
      "primaryPattern": "Stack",
      "acceptablePatterns": [],
      "patternExplanations": {
          "Stack": "Push non-star characters. On star, pop the last character. Result is remaining stack contents."
      },
      "hints": [
          "Star removes the closest non-star character to its left.",
          "'Closest to left' = most recently added. What data structure gives that?",
          "Stack: push letters, pop on star. Final stack is the result."
      ],
      "solution": {
          "approach": "Stack of chars. For each char: if star, pop. Else push. Join remaining stack.",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)",
          "keyInsight": "Star acts like backspace - stack naturally handles this."
      }
  },
  2391: {
      "title": "Minimum Amount of Time to Collect Garbage",
      "slug": "minimum-amount-of-time-to-collect-garbage",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2392: {
      "title": "Build a Matrix With Conditions",
      "slug": "build-a-matrix-with-conditions",
      "difficulty": "hard",
      "primaryPattern": "Graph",
      "acceptablePatterns": [
          "Hash Map",
          "DFS"
      ],
      "explanation": "Graph algorithms - may involve topological sort, cycle detection, union find, or connectivity checks."
  },
  2395: {
      "title": "Find Subarrays With Equal Sum",
      "slug": "find-subarrays-with-equal-sum",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2396: {
      "title": "Strictly Palindromic Number",
      "slug": "strictly-palindromic-number",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  2397: {
      "title": "Maximum Rows Covered by Columns",
      "slug": "maximum-rows-covered-by-columns",
      "difficulty": "medium",
      "primaryPattern": "Backtracking",
      "acceptablePatterns": [
          "Hash Map",
          "DFS"
      ],
      "explanation": "Explore all possible solutions recursively. Build candidates incrementally and abandon paths that cannot lead to solution."
  },
  2398: {
      "title": "Maximum Number of Robots Within Budget",
      "slug": "maximum-number-of-robots-within-budget",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "BFS",
          "Sliding Window",
          "Heap/Priority Queue"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  2399: {
      "title": "Check Distances Between Same Letters",
      "slug": "check-distances-between-same-letters",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2400: {
      "title": "Number of Ways to Reach a Position After Exactly k Steps",
      "slug": "number-of-ways-to-reach-a-position-after-exactly-k-steps",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2401: {
      "title": "Longest Nice Subarray",
      "slug": "longest-nice-subarray",
      "difficulty": "medium",
      "primaryPattern": "Sliding Window",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Maintain a window of elements that slides through the array. Expand when adding elements, contract when removing. Track window state."
  },
  2402: {
      "title": "Meeting Rooms III",
      "slug": "meeting-rooms-iii",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Two Pointers",
          "Heap/Priority Queue"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2404: {
      "title": "Most Frequent Even Element",
      "slug": "most-frequent-even-element",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2405: {
      "title": "Optimal Partition of String",
      "slug": "optimal-partition-of-string",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Greedy"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2406: {
      "title": "Divide Intervals Into Minimum Number of Groups",
      "slug": "divide-intervals-into-minimum-number-of-groups",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy",
          "Heap/Priority Queue"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  2407: {
      "title": "Longest Increasing Subsequence II",
      "slug": "longest-increasing-subsequence-ii",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Binary Search",
          "BFS",
          "Sliding Window"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2409: {
      "title": "Count Days Spent Together",
      "slug": "count-days-spent-together",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2410: {
      "title": "Maximum Matching of Players With Trainers",
      "slug": "maximum-matching-of-players-with-trainers",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  2411: {
      "title": "Smallest Subarrays With Maximum Bitwise OR",
      "slug": "smallest-subarrays-with-maximum-bitwise-or",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Sliding Window"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  2412: {
      "title": "Minimum Money Required Before Transactions",
      "slug": "minimum-money-required-before-transactions",
      "difficulty": "hard",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  2413: {
      "title": "Smallest Even Multiple",
      "slug": "smallest-even-multiple",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2414: {
      "title": "Length of the Longest Alphabetical Continuous Substring",
      "slug": "length-of-the-longest-alphabetical-continuous-substring",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2415: {
      "title": "Reverse Odd Levels of Binary Tree",
      "slug": "reverse-odd-levels-of-binary-tree",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Tree Traversal",
          "BFS"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  2416: {
      "title": "Sum of Prefix Scores of Strings",
      "slug": "sum-of-prefix-scores-of-strings",
      "difficulty": "hard",
      "primaryPattern": "Trie",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Prefix tree for efficient string operations. Each node represents a character, paths represent strings."
  },
  2418: {
      "title": "Sort the People",
      "slug": "sort-the-people",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2419: {
      "title": "Longest Subarray With Maximum Bitwise AND",
      "slug": "longest-subarray-with-maximum-bitwise-and",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2420: {
      "title": "Find All Good Indices",
      "slug": "find-all-good-indices",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2421: {
      "title": "Number of Good Paths",
      "slug": "number-of-good-paths",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Tree Traversal",
          "Graph",
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2423: {
      "title": "Remove Letter To Equalize Frequency",
      "slug": "remove-letter-to-equalize-frequency",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2424: {
      "title": "Longest Uploaded Prefix",
      "slug": "longest-uploaded-prefix",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Binary Search",
          "Graph",
          "Heap/Priority Queue"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2425: {
      "title": "Bitwise XOR of All Pairings",
      "slug": "bitwise-xor-of-all-pairings",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2426: {
      "title": "Number of Pairs Satisfying Inequality",
      "slug": "number-of-pairs-satisfying-inequality",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  2427: {
      "title": "Number of Common Factors",
      "slug": "number-of-common-factors",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2428: {
      "title": "Maximum Sum of an Hourglass",
      "slug": "maximum-sum-of-an-hourglass",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "DFS"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2429: {
      "title": "Minimize XOR",
      "slug": "minimize-xor",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  2430: {
      "title": "Maximum Deletions on a String",
      "slug": "maximum-deletions-on-a-string",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2432: {
      "title": "The Employee That Worked on the Longest Task",
      "slug": "the-employee-that-worked-on-the-longest-task",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2433: {
      "title": "Find The Original Array of Prefix Xor",
      "slug": "find-the-original-array-of-prefix-xor",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2434: {
      "title": "Using a Robot to Print the Lexicographically Smallest String",
      "slug": "using-a-robot-to-print-the-lexicographically-smallest-string",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Stack",
          "Greedy"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2435: {
      "title": "Paths in Matrix Whose Sum Is Divisible by K",
      "slug": "paths-in-matrix-whose-sum-is-divisible-by-k",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "DFS"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2437: {
      "title": "Number of Valid Clock Times",
      "slug": "number-of-valid-clock-times",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2438: {
      "title": "Range Product Queries of Powers",
      "slug": "range-product-queries-of-powers",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2439: {
      "title": "Minimize Maximum of Array",
      "slug": "minimize-maximum-of-array",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Dynamic Programming",
          "Greedy"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  2440: {
      "title": "Create Components With Same Value",
      "slug": "create-components-with-same-value",
      "difficulty": "hard",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map",
          "Tree Traversal"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  2441: {
      "title": "Largest Positive Integer That Exists With Its Negative",
      "slug": "largest-positive-integer-that-exists-with-its-negative",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2442: {
      "title": "Count Number of Distinct Integers After Reverse Operations",
      "slug": "count-number-of-distinct-integers-after-reverse-operations",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2443: {
      "title": "Sum of Number and Its Reverse",
      "slug": "sum-of-number-and-its-reverse",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2444: {
      "title": "Count Subarrays With Fixed Bounds",
      "slug": "count-subarrays-with-fixed-bounds",
      "difficulty": "hard",
      "primaryPattern": "Sliding Window",
      "acceptablePatterns": [
          "Hash Map",
          "BFS"
      ],
      "explanation": "Maintain a window of elements that slides through the array. Expand when adding elements, contract when removing. Track window state."
  },
  2446: {
      "title": "Determine if Two Events Have Conflict",
      "slug": "determine-if-two-events-have-conflict",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2447: {
      "title": "Number of Subarrays With GCD Equal to K",
      "slug": "number-of-subarrays-with-gcd-equal-to-k",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2448: {
      "title": "Minimum Cost to Make Array Equal",
      "slug": "minimum-cost-to-make-array-equal",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy",
          "Two Pointers"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  2449: {
      "title": "Minimum Number of Operations to Make Arrays Similar",
      "slug": "minimum-number-of-operations-to-make-arrays-similar",
      "difficulty": "hard",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  2451: {
      "title": "Odd String Difference",
      "slug": "odd-string-difference",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2452: {
      "title": "Words Within Two Edits of Dictionary",
      "slug": "words-within-two-edits-of-dictionary",
      "difficulty": "medium",
      "primaryPattern": "Trie",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Prefix tree for efficient string operations. Each node represents a character, paths represent strings."
  },
  2453: {
      "title": "Destroy Sequential Targets",
      "slug": "destroy-sequential-targets",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2454: {
      "title": "Next Greater Element IV",
      "slug": "next-greater-element-iv",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Stack",
          "Two Pointers",
          "Heap/Priority Queue"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  2455: {
      "title": "Average Value of Even Numbers That Are Divisible by Three",
      "slug": "average-value-of-even-numbers-that-are-divisible-by-three",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2456: {
      "title": "Most Popular Video Creator",
      "slug": "most-popular-video-creator",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Two Pointers",
          "Heap/Priority Queue"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2457: {
      "title": "Minimum Addition to Make Integer Beautiful",
      "slug": "minimum-addition-to-make-integer-beautiful",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  2458: {
      "title": "Height of Binary Tree After Subtree Removal Queries",
      "slug": "height-of-binary-tree-after-subtree-removal-queries",
      "difficulty": "hard",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map",
          "Tree Traversal",
          "BFS"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  2460: {
      "title": "Apply Operations to an Array",
      "slug": "apply-operations-to-an-array",
      "difficulty": "easy",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  2461: {
      "title": "Maximum Sum of Distinct Subarrays With Length K",
      "slug": "maximum-sum-of-distinct-subarrays-with-length-k",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Sliding Window"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2462: {
      "title": "Total Cost to Hire K Workers",
      "slug": "total-cost-to-hire-k-workers",
      "difficulty": "medium",
      "primaryPattern": "Heap",
      "acceptablePatterns": [],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds.",
      "lists": [
          "leetcode-75"
      ],
      "category": "Heap / Priority Queue",
      "patternExplanations": {
          "Heap": "Two heaps for front and back candidates. Hire k workers by always picking smallest cost."
      },
      "hints": [
          "Hire k workers. Each time, pick from first 'candidates' or last 'candidates' workers.",
          "Use two min-heaps: one for front candidates, one for back candidates.",
          "Pick smallest from either heap. Refill that heap from remaining workers."
      ],
      "solution": {
          "approach": "Two min-heaps for front and back 'candidates' workers. Pick min k times, refilling heaps from middle.",
          "timeComplexity": "O((candidates + k) log candidates)",
          "spaceComplexity": "O(candidates)",
          "keyInsight": "Two heaps maintain the candidates pool from each end. Pick globally smallest."
      }
  },
  2463: {
      "title": "Minimum Total Distance Traveled",
      "slug": "minimum-total-distance-traveled",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2465: {
      "title": "Number of Distinct Averages",
      "slug": "number-of-distinct-averages",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2466: {
      "title": "Count Ways To Build Good Strings",
      "slug": "count-ways-to-build-good-strings",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2467: {
      "title": "Most Profitable Path in a Tree",
      "slug": "most-profitable-path-in-a-tree",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map",
          "Tree Traversal",
          "BFS",
          "Graph"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  2468: {
      "title": "Split Message Based on Limit",
      "slug": "split-message-based-on-limit",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  2469: {
      "title": "Convert the Temperature",
      "slug": "convert-the-temperature",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2470: {
      "title": "Number of Subarrays With LCM Equal to K",
      "slug": "number-of-subarrays-with-lcm-equal-to-k",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2471: {
      "title": "Minimum Number of Operations to Sort a Binary Tree by Level",
      "slug": "minimum-number-of-operations-to-sort-a-binary-tree-by-level",
      "difficulty": "medium",
      "primaryPattern": "BFS",
      "acceptablePatterns": [
          "Tree Traversal"
      ],
      "explanation": "Breadth-first search - explore level by level using a queue. Ideal for shortest path in unweighted graphs or level-order traversal."
  },
  2472: {
      "title": "Maximum Number of Non-overlapping Palindrome Substrings",
      "slug": "maximum-number-of-non-overlapping-palindrome-substrings",
      "difficulty": "hard",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map",
          "Dynamic Programming",
          "Greedy"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  2475: {
      "title": "Number of Unequal Triplets in Array",
      "slug": "number-of-unequal-triplets-in-array",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2476: {
      "title": "Closest Nodes Queries in a Binary Search Tree",
      "slug": "closest-nodes-queries-in-a-binary-search-tree",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Tree Traversal",
          "DFS"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  2477: {
      "title": "Minimum Fuel Cost to Report to the Capital",
      "slug": "minimum-fuel-cost-to-report-to-the-capital",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Tree Traversal",
          "BFS",
          "Graph"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  2478: {
      "title": "Number of Beautiful Partitions",
      "slug": "number-of-beautiful-partitions",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2481: {
      "title": "Minimum Cuts to Divide a Circle",
      "slug": "minimum-cuts-to-divide-a-circle",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2482: {
      "title": "Difference Between Ones and Zeros in Row and Column",
      "slug": "difference-between-ones-and-zeros-in-row-and-column",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  2483: {
      "title": "Minimum Penalty for a Shop",
      "slug": "minimum-penalty-for-a-shop",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2484: {
      "title": "Count Palindromic Subsequences",
      "slug": "count-palindromic-subsequences",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2485: {
      "title": "Find the Pivot Integer",
      "slug": "find-the-pivot-integer",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2486: {
      "title": "Append Characters to String to Make Subsequence",
      "slug": "append-characters-to-string-to-make-subsequence",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  2487: {
      "title": "Remove Nodes From Linked List",
      "slug": "remove-nodes-from-linked-list",
      "difficulty": "medium",
      "primaryPattern": "Linked List",
      "acceptablePatterns": [
          "Stack",
          "DFS"
      ],
      "explanation": "Pointer manipulation for reversing, merging, detecting cycles, or finding intersections in linked structures."
  },
  2488: {
      "title": "Count Subarrays With Median K",
      "slug": "count-subarrays-with-median-k",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2490: {
      "title": "Circular Sentence",
      "slug": "circular-sentence",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2491: {
      "title": "Divide Players Into Teams of Equal Skill",
      "slug": "divide-players-into-teams-of-equal-skill",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2492: {
      "title": "Minimum Score of a Path Between Two Cities",
      "slug": "minimum-score-of-a-path-between-two-cities",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "BFS",
          "Graph"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  2493: {
      "title": "Divide Nodes Into the Maximum Number of Groups",
      "slug": "divide-nodes-into-the-maximum-number-of-groups",
      "difficulty": "hard",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "BFS",
          "Graph"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  2496: {
      "title": "Maximum Value of a String in an Array",
      "slug": "maximum-value-of-a-string-in-an-array",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2497: {
      "title": "Maximum Star Sum of a Graph",
      "slug": "maximum-star-sum-of-a-graph",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Graph",
          "Two Pointers",
          "Heap/Priority Queue"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  2498: {
      "title": "Frog Jump II",
      "slug": "frog-jump-ii",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  2499: {
      "title": "Minimum Total Cost to Make Arrays Unequal",
      "slug": "minimum-total-cost-to-make-arrays-unequal",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Greedy"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2500: {
      "title": "Delete Greatest Value in Each Row",
      "slug": "delete-greatest-value-in-each-row",
      "difficulty": "easy",
      "primaryPattern": "Heap/Priority Queue",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers",
          "DFS"
      ],
      "explanation": "Maintain ordered access to min/max elements. Useful for k-largest/smallest, merging, or scheduling problems."
  },
  2501: {
      "title": "Longest Square Streak in an Array",
      "slug": "longest-square-streak-in-an-array",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Binary Search",
          "Dynamic Programming",
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2502: {
      "title": "Design Memory Allocator",
      "slug": "design-memory-allocator",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2503: {
      "title": "Maximum Number of Points From Grid Queries",
      "slug": "maximum-number-of-points-from-grid-queries",
      "difficulty": "hard",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map",
          "BFS",
          "Graph",
          "Heap/Priority Queue",
          "DFS"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  2506: {
      "title": "Count Pairs Of Similar Strings",
      "slug": "count-pairs-of-similar-strings",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2507: {
      "title": "Smallest Value After Replacing With Sum of Prime Factors",
      "slug": "smallest-value-after-replacing-with-sum-of-prime-factors",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2508: {
      "title": "Add Edges to Make Degrees of All Nodes Even",
      "slug": "add-edges-to-make-degrees-of-all-nodes-even",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Graph"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2509: {
      "title": "Cycle Length Queries in a Tree",
      "slug": "cycle-length-queries-in-a-tree",
      "difficulty": "hard",
      "primaryPattern": "Tree Traversal",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Navigate tree structures using inorder, preorder, or postorder traversal. Consider recursive or iterative approaches."
  },
  2511: {
      "title": "Maximum Enemy Forts That Can Be Captured",
      "slug": "maximum-enemy-forts-that-can-be-captured",
      "difficulty": "easy",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  2512: {
      "title": "Reward Top K Students",
      "slug": "reward-top-k-students",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Two Pointers",
          "Heap/Priority Queue"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2513: {
      "title": "Minimize the Maximum of Two Arrays",
      "slug": "minimize-the-maximum-of-two-arrays",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  2514: {
      "title": "Count Anagrams",
      "slug": "count-anagrams",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2515: {
      "title": "Shortest Distance to Target String in a Circular Array",
      "slug": "shortest-distance-to-target-string-in-a-circular-array",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2516: {
      "title": "Take K of Each Character From Left and Right",
      "slug": "take-k-of-each-character-from-left-and-right",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Sliding Window"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2517: {
      "title": "Maximum Tastiness of Candy Basket",
      "slug": "maximum-tastiness-of-candy-basket",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy",
          "Two Pointers"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  2518: {
      "title": "Number of Great Partitions",
      "slug": "number-of-great-partitions",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2520: {
      "title": "Count the Digits That Divide a Number",
      "slug": "count-the-digits-that-divide-a-number",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2521: {
      "title": "Distinct Prime Factors of Product of Array",
      "slug": "distinct-prime-factors-of-product-of-array",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2522: {
      "title": "Partition String Into Substrings With Values at Most K",
      "slug": "partition-string-into-substrings-with-values-at-most-k",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2523: {
      "title": "Closest Prime Numbers in Range",
      "slug": "closest-prime-numbers-in-range",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2525: {
      "title": "Categorize Box According to Criteria",
      "slug": "categorize-box-according-to-criteria",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2526: {
      "title": "Find Consecutive Integers from a Data Stream",
      "slug": "find-consecutive-integers-from-a-data-stream",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "BFS"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2527: {
      "title": "Find Xor-Beauty of Array",
      "slug": "find-xor-beauty-of-array",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2528: {
      "title": "Maximize the Minimum Powered City",
      "slug": "maximize-the-minimum-powered-city",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy",
          "BFS",
          "Sliding Window"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  2529: {
      "title": "Maximum Count of Positive Integer and Negative Integer",
      "slug": "maximum-count-of-positive-integer-and-negative-integer",
      "difficulty": "easy",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  2530: {
      "title": "Maximal Score After Applying K Operations",
      "slug": "maximal-score-after-applying-k-operations",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Heap/Priority Queue"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  2531: {
      "title": "Make Number of Distinct Characters Equal",
      "slug": "make-number-of-distinct-characters-equal",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2532: {
      "title": "Time to Cross a Bridge",
      "slug": "time-to-cross-a-bridge",
      "difficulty": "hard",
      "primaryPattern": "Heap/Priority Queue",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Maintain ordered access to min/max elements. Useful for k-largest/smallest, merging, or scheduling problems."
  },
  2535: {
      "title": "Difference Between Element Sum and Digit Sum of an Array",
      "slug": "difference-between-element-sum-and-digit-sum-of-an-array",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2536: {
      "title": "Increment Submatrices by One",
      "slug": "increment-submatrices-by-one",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "DFS"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2537: {
      "title": "Count the Number of Good Subarrays",
      "slug": "count-the-number-of-good-subarrays",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Sliding Window"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2538: {
      "title": "Difference Between Maximum and Minimum Price Sum",
      "slug": "difference-between-maximum-and-minimum-price-sum",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Tree Traversal",
          "DFS"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2540: {
      "title": "Minimum Common Value",
      "slug": "minimum-common-value",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Two Pointers",
          "Binary Search"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2541: {
      "title": "Minimum Operations to Make Array Equal II",
      "slug": "minimum-operations-to-make-array-equal-ii",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  2542: {
      "title": "Maximum Subsequence Score",
      "slug": "maximum-subsequence-score",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Heap"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum.",
      "lists": [
          "leetcode-75"
      ],
      "category": "Heap / Priority Queue",
      "patternExplanations": {
          "Greedy": "Sort by nums descending. Greedily pick k largest nums, but sum their corresponding (sorted) multipliers.",
          "Heap": "Max-heap by nums. Pick k elements. Use sorted multipliers to maximize score."
      },
      "hints": [
          "Score = min(nums[picked]) * sum(multipliers[picked]). Balance these two.",
          "If you fix which elements are picked, score = min(nums) * sum(multipliers).",
          "Sort by nums descending. Consider prefixes. For each min, compute best sum using heap for largest multipliers."
      ],
      "solution": {
          "approach": "Pair (nums[i], multipliers[i]). Sort by nums descending. Use min-heap of size k for largest multipliers. Track max score.",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(n)",
          "keyInsight": "Fix min (iterate sorted nums). Greedily pick k largest multipliers seen so far. Track best score."
      }
  },
  2543: {
      "title": "Check if Point Is Reachable",
      "slug": "check-if-point-is-reachable",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2544: {
      "title": "Alternating Digit Sum",
      "slug": "alternating-digit-sum",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2545: {
      "title": "Sort the Students by Their Kth Score",
      "slug": "sort-the-students-by-their-kth-score",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map",
          "DFS"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  2546: {
      "title": "Apply Bitwise Operations to Make Strings Equal",
      "slug": "apply-bitwise-operations-to-make-strings-equal",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2547: {
      "title": "Minimum Cost to Split an Array",
      "slug": "minimum-cost-to-split-an-array",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Dynamic Programming"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2549: {
      "title": "Count Distinct Numbers on Board",
      "slug": "count-distinct-numbers-on-board",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2550: {
      "title": "Count Collisions of Monkeys on a Polygon",
      "slug": "count-collisions-of-monkeys-on-a-polygon",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  2551: {
      "title": "Put Marbles in Bags",
      "slug": "put-marbles-in-bags",
      "difficulty": "hard",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers",
          "Heap/Priority Queue"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  2552: {
      "title": "Count Increasing Quadruplets",
      "slug": "count-increasing-quadruplets",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2553: {
      "title": "Separate the Digits in an Array",
      "slug": "separate-the-digits-in-an-array",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2554: {
      "title": "Maximum Number of Integers to Choose From a Range I",
      "slug": "maximum-number-of-integers-to-choose-from-a-range-i",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Binary Search",
          "Greedy",
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2555: {
      "title": "Maximize Win From Two Segments",
      "slug": "maximize-win-from-two-segments",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Sliding Window"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  2556: {
      "title": "Disconnect Path in a Binary Matrix by at Most One Flip",
      "slug": "disconnect-path-in-a-binary-matrix-by-at-most-one-flip",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "DFS",
          "BFS"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2558: {
      "title": "Take Gifts From the Richest Pile",
      "slug": "take-gifts-from-the-richest-pile",
      "difficulty": "easy",
      "primaryPattern": "Heap/Priority Queue",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Maintain ordered access to min/max elements. Useful for k-largest/smallest, merging, or scheduling problems."
  },
  2559: {
      "title": "Count Vowel Strings in Ranges",
      "slug": "count-vowel-strings-in-ranges",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2560: {
      "title": "House Robber IV",
      "slug": "house-robber-iv",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Dynamic Programming",
          "Greedy"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  2561: {
      "title": "Rearranging Fruits",
      "slug": "rearranging-fruits",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Greedy"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2562: {
      "title": "Find the Array Concatenation Value",
      "slug": "find-the-array-concatenation-value",
      "difficulty": "easy",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  2563: {
      "title": "Count the Number of Fair Pairs",
      "slug": "count-the-number-of-fair-pairs",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map",
          "Binary Search"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  2564: {
      "title": "Substring XOR Queries",
      "slug": "substring-xor-queries",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2565: {
      "title": "Subsequence With the Minimum Score",
      "slug": "subsequence-with-the-minimum-score",
      "difficulty": "hard",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map",
          "Binary Search"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  2566: {
      "title": "Maximum Difference by Remapping a Digit",
      "slug": "maximum-difference-by-remapping-a-digit",
      "difficulty": "easy",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  2567: {
      "title": "Minimum Score by Changing Two Elements",
      "slug": "minimum-score-by-changing-two-elements",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  2568: {
      "title": "Minimum Impossible OR",
      "slug": "minimum-impossible-or",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2569: {
      "title": "Handling Sum Queries After Update",
      "slug": "handling-sum-queries-after-update",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2570: {
      "title": "Merge Two 2D Arrays by Summing Values",
      "slug": "merge-two-2d-arrays-by-summing-values",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2571: {
      "title": "Minimum Operations to Reduce an Integer to 0",
      "slug": "minimum-operations-to-reduce-an-integer-to-0",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Greedy",
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2572: {
      "title": "Count the Number of Square-Free Subsets",
      "slug": "count-the-number-of-square-free-subsets",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2573: {
      "title": "Find the String with LCP",
      "slug": "find-the-string-with-lcp",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy",
          "Graph",
          "DFS"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2574: {
      "title": "Left and Right Sum Differences",
      "slug": "left-and-right-sum-differences",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2575: {
      "title": "Find the Divisibility Array of a String",
      "slug": "find-the-divisibility-array-of-a-string",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2576: {
      "title": "Find the Maximum Number of Marked Indices",
      "slug": "find-the-maximum-number-of-marked-indices",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map",
          "Binary Search",
          "Greedy"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  2577: {
      "title": "Minimum Time to Visit a Cell In a Grid",
      "slug": "minimum-time-to-visit-a-cell-in-a-grid",
      "difficulty": "hard",
      "primaryPattern": "BFS",
      "acceptablePatterns": [
          "Hash Map",
          "Graph",
          "Heap/Priority Queue",
          "DFS"
      ],
      "explanation": "Breadth-first search - explore level by level using a queue. Ideal for shortest path in unweighted graphs or level-order traversal."
  },
  2578: {
      "title": "Split With Minimum Sum",
      "slug": "split-with-minimum-sum",
      "difficulty": "easy",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  2579: {
      "title": "Count Total Number of Colored Cells",
      "slug": "count-total-number-of-colored-cells",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2580: {
      "title": "Count Ways to Group Overlapping Ranges",
      "slug": "count-ways-to-group-overlapping-ranges",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  2581: {
      "title": "Count Number of Possible Root Nodes",
      "slug": "count-number-of-possible-root-nodes",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Dynamic Programming",
          "Tree Traversal",
          "DFS"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2582: {
      "title": "Pass the Pillow",
      "slug": "pass-the-pillow",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2583: {
      "title": "Kth Largest Sum in a Binary Tree",
      "slug": "kth-largest-sum-in-a-binary-tree",
      "difficulty": "medium",
      "primaryPattern": "BFS",
      "acceptablePatterns": [
          "Tree Traversal",
          "Two Pointers"
      ],
      "explanation": "Breadth-first search - explore level by level using a queue. Ideal for shortest path in unweighted graphs or level-order traversal."
  },
  2584: {
      "title": "Split the Array to Make Coprime Products",
      "slug": "split-the-array-to-make-coprime-products",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2585: {
      "title": "Number of Ways to Earn Points",
      "slug": "number-of-ways-to-earn-points",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2586: {
      "title": "Count the Number of Vowel Strings in Range",
      "slug": "count-the-number-of-vowel-strings-in-range",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2587: {
      "title": "Rearrange Array to Maximize Prefix Score",
      "slug": "rearrange-array-to-maximize-prefix-score",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  2588: {
      "title": "Count the Number of Beautiful Subarrays",
      "slug": "count-the-number-of-beautiful-subarrays",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2589: {
      "title": "Minimum Time to Complete All Tasks",
      "slug": "minimum-time-to-complete-all-tasks",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Stack",
          "Greedy",
          "Two Pointers"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  2591: {
      "title": "Distribute Money to Maximum Children",
      "slug": "distribute-money-to-maximum-children",
      "difficulty": "easy",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  2592: {
      "title": "Maximize Greatness of an Array",
      "slug": "maximize-greatness-of-an-array",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  2593: {
      "title": "Find Score of an Array After Marking All Elements",
      "slug": "find-score-of-an-array-after-marking-all-elements",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Two Pointers",
          "Heap/Priority Queue"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2594: {
      "title": "Minimum Time to Repair Cars",
      "slug": "minimum-time-to-repair-cars",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  2595: {
      "title": "Number of Even and Odd Bits",
      "slug": "number-of-even-and-odd-bits",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2596: {
      "title": "Check Knight Tour Configuration",
      "slug": "check-knight-tour-configuration",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map",
          "BFS"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  2597: {
      "title": "The Number of Beautiful Subsets",
      "slug": "the-number-of-beautiful-subsets",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Dynamic Programming",
          "Backtracking",
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2598: {
      "title": "Smallest Missing Non-negative Integer After Operations",
      "slug": "smallest-missing-non-negative-integer-after-operations",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Greedy"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2600: {
      "title": "K Items With the Maximum Sum",
      "slug": "k-items-with-the-maximum-sum",
      "difficulty": "easy",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  2601: {
      "title": "Prime Subtraction Operation",
      "slug": "prime-subtraction-operation",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  2602: {
      "title": "Minimum Operations to Make All Array Elements Equal",
      "slug": "minimum-operations-to-make-all-array-elements-equal",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  2603: {
      "title": "Collect Coins in a Tree",
      "slug": "collect-coins-in-a-tree",
      "difficulty": "hard",
      "primaryPattern": "Graph",
      "acceptablePatterns": [
          "Hash Map",
          "Tree Traversal"
      ],
      "explanation": "Graph algorithms - may involve topological sort, cycle detection, union find, or connectivity checks."
  },
  2605: {
      "title": "Form Smallest Number From Two Digit Arrays",
      "slug": "form-smallest-number-from-two-digit-arrays",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2606: {
      "title": "Find the Substring With Maximum Cost",
      "slug": "find-the-substring-with-maximum-cost",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Dynamic Programming"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2607: {
      "title": "Make K-Subarray Sums Equal",
      "slug": "make-k-subarray-sums-equal",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  2608: {
      "title": "Shortest Cycle in a Graph",
      "slug": "shortest-cycle-in-a-graph",
      "difficulty": "hard",
      "primaryPattern": "BFS",
      "acceptablePatterns": [
          "Graph"
      ],
      "explanation": "Breadth-first search - explore level by level using a queue. Ideal for shortest path in unweighted graphs or level-order traversal."
  },
  2609: {
      "title": "Find the Longest Balanced Substring of a Binary String",
      "slug": "find-the-longest-balanced-substring-of-a-binary-string",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2610: {
      "title": "Convert an Array Into a 2D Array With Conditions",
      "slug": "convert-an-array-into-a-2d-array-with-conditions",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2611: {
      "title": "Mice and Cheese",
      "slug": "mice-and-cheese",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers",
          "Heap/Priority Queue"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  2612: {
      "title": "Minimum Reverse Operations",
      "slug": "minimum-reverse-operations",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "BFS",
          "Graph"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2614: {
      "title": "Prime In Diagonal",
      "slug": "prime-in-diagonal",
      "difficulty": "easy",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  2615: {
      "title": "Sum of Distances",
      "slug": "sum-of-distances",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2616: {
      "title": "Minimize the Maximum Difference of Pairs",
      "slug": "minimize-the-maximum-difference-of-pairs",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Dynamic Programming",
          "Greedy",
          "Two Pointers"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  2617: {
      "title": "Minimum Number of Visited Cells in a Grid",
      "slug": "minimum-number-of-visited-cells-in-a-grid",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Stack",
          "BFS",
          "Graph",
          "Heap/Priority Queue",
          "DFS"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2618: {
      "title": "Check if Object Instance of Class",
      "slug": "check-if-object-instance-of-class",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2619: {
      "title": "Array Prototype Last",
      "slug": "array-prototype-last",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2620: {
      "title": "Counter",
      "slug": "counter",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2621: {
      "title": "Sleep",
      "slug": "sleep",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2622: {
      "title": "Cache With Time Limit",
      "slug": "cache-with-time-limit",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2623: {
      "title": "Memoize",
      "slug": "memoize",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2624: {
      "title": "Snail Traversal",
      "slug": "snail-traversal",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2625: {
      "title": "Flatten Deeply Nested Array",
      "slug": "flatten-deeply-nested-array",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2626: {
      "title": "Array Reduce Transformation",
      "slug": "array-reduce-transformation",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2627: {
      "title": "Debounce",
      "slug": "debounce",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2629: {
      "title": "Function Composition",
      "slug": "function-composition",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2630: {
      "title": "Memoize II",
      "slug": "memoize-ii",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2631: {
      "title": "Group By",
      "slug": "group-by",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2634: {
      "title": "Filter Elements from Array",
      "slug": "filter-elements-from-array",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2635: {
      "title": "Apply Transform Over Each Element in Array",
      "slug": "apply-transform-over-each-element-in-array",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2637: {
      "title": "Promise Time Limit",
      "slug": "promise-time-limit",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2639: {
      "title": "Find the Width of Columns of a Grid",
      "slug": "find-the-width-of-columns-of-a-grid",
      "difficulty": "easy",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  2640: {
      "title": "Find the Score of All Prefixes of an Array",
      "slug": "find-the-score-of-all-prefixes-of-an-array",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2641: {
      "title": "Cousins in Binary Tree II",
      "slug": "cousins-in-binary-tree-ii",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Tree Traversal",
          "DFS",
          "BFS"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2642: {
      "title": "Design Graph With Shortest Path Calculator",
      "slug": "design-graph-with-shortest-path-calculator",
      "difficulty": "hard",
      "primaryPattern": "Heap/Priority Queue",
      "acceptablePatterns": [
          "Graph",
          "Hash Map",
          "BFS"
      ],
      "explanation": "Maintain ordered access to min/max elements. Useful for k-largest/smallest, merging, or scheduling problems."
  },
  2643: {
      "title": "Row With Maximum Ones",
      "slug": "row-with-maximum-ones",
      "difficulty": "easy",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  2644: {
      "title": "Find the Maximum Divisibility Score",
      "slug": "find-the-maximum-divisibility-score",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2645: {
      "title": "Minimum Additions to Make Valid String",
      "slug": "minimum-additions-to-make-valid-string",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Stack",
          "Greedy"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2646: {
      "title": "Minimize the Total Price of the Trips",
      "slug": "minimize-the-total-price-of-the-trips",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Tree Traversal",
          "DFS",
          "Graph"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2648: {
      "title": "Generate Fibonacci Sequence",
      "slug": "generate-fibonacci-sequence",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2649: {
      "title": "Nested Array Generator",
      "slug": "nested-array-generator",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2650: {
      "title": "Design Cancellable Function",
      "slug": "design-cancellable-function",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2651: {
      "title": "Calculate Delayed Arrival Time",
      "slug": "calculate-delayed-arrival-time",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2652: {
      "title": "Sum Multiples",
      "slug": "sum-multiples",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2653: {
      "title": "Sliding Subarray Beauty",
      "slug": "sliding-subarray-beauty",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Sliding Window"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2654: {
      "title": "Minimum Number of Operations to Make All Array Elements Equal to 1",
      "slug": "minimum-number-of-operations-to-make-all-array-elements-equal-to-1",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2656: {
      "title": "Maximum Sum With Exactly K Elements ",
      "slug": "maximum-sum-with-exactly-k-elements",
      "difficulty": "easy",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  2657: {
      "title": "Find the Prefix Common Array of Two Arrays",
      "slug": "find-the-prefix-common-array-of-two-arrays",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2658: {
      "title": "Maximum Number of Fish in a Grid",
      "slug": "maximum-number-of-fish-in-a-grid",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map",
          "BFS",
          "Graph"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  2659: {
      "title": "Make Array Empty",
      "slug": "make-array-empty",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy",
          "Two Pointers"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  2660: {
      "title": "Determine the Winner of a Bowling Game",
      "slug": "determine-the-winner-of-a-bowling-game",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2661: {
      "title": "First Completely Painted Row or Column",
      "slug": "first-completely-painted-row-or-column",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "DFS"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2662: {
      "title": "Minimum Cost of a Path With Special Roads",
      "slug": "minimum-cost-of-a-path-with-special-roads",
      "difficulty": "medium",
      "primaryPattern": "Heap/Priority Queue",
      "acceptablePatterns": [
          "Hash Map",
          "Graph",
          "BFS"
      ],
      "explanation": "Maintain ordered access to min/max elements. Useful for k-largest/smallest, merging, or scheduling problems."
  },
  2663: {
      "title": "Lexicographically Smallest Beautiful String",
      "slug": "lexicographically-smallest-beautiful-string",
      "difficulty": "hard",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  2665: {
      "title": "Counter II",
      "slug": "counter-ii",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2666: {
      "title": "Allow One Function Call",
      "slug": "allow-one-function-call",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2667: {
      "title": "Create Hello World Function",
      "slug": "create-hello-world-function",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2670: {
      "title": "Find the Distinct Difference Array",
      "slug": "find-the-distinct-difference-array",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2671: {
      "title": "Frequency Tracker",
      "slug": "frequency-tracker",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2672: {
      "title": "Number of Adjacent Elements With the Same Color",
      "slug": "number-of-adjacent-elements-with-the-same-color",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2673: {
      "title": "Make Costs of Paths Equal in a Binary Tree",
      "slug": "make-costs-of-paths-equal-in-a-binary-tree",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy",
          "Tree Traversal"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2677: {
      "title": "Chunk Array",
      "slug": "chunk-array",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2678: {
      "title": "Number of Senior Citizens",
      "slug": "number-of-senior-citizens",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2679: {
      "title": "Sum in a Matrix",
      "slug": "sum-in-a-matrix",
      "difficulty": "medium",
      "primaryPattern": "Heap/Priority Queue",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers",
          "DFS"
      ],
      "explanation": "Maintain ordered access to min/max elements. Useful for k-largest/smallest, merging, or scheduling problems."
  },
  2680: {
      "title": "Maximum OR",
      "slug": "maximum-or",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  2681: {
      "title": "Power of Heroes",
      "slug": "power-of-heroes",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2682: {
      "title": "Find the Losers of the Circular Game",
      "slug": "find-the-losers-of-the-circular-game",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2683: {
      "title": "Neighboring Bitwise XOR",
      "slug": "neighboring-bitwise-xor",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2684: {
      "title": "Maximum Number of Moves in a Grid",
      "slug": "maximum-number-of-moves-in-a-grid",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "DFS"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2685: {
      "title": "Count the Number of Complete Components",
      "slug": "count-the-number-of-complete-components",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "BFS",
          "Graph"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  2693: {
      "title": "Call Function with Custom Context",
      "slug": "call-function-with-custom-context",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2694: {
      "title": "Event Emitter",
      "slug": "event-emitter",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2695: {
      "title": "Array Wrapper",
      "slug": "array-wrapper",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2696: {
      "title": "Minimum String Length After Removing Substrings",
      "slug": "minimum-string-length-after-removing-substrings",
      "difficulty": "easy",
      "primaryPattern": "Stack",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "LIFO structure for nested patterns, matching pairs, or maintaining monotonic sequences."
  },
  2697: {
      "title": "Lexicographically Smallest Palindrome",
      "slug": "lexicographically-smallest-palindrome",
      "difficulty": "easy",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  2698: {
      "title": "Find the Punishment Number of an Integer",
      "slug": "find-the-punishment-number-of-an-integer",
      "difficulty": "medium",
      "primaryPattern": "Backtracking",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Explore all possible solutions recursively. Build candidates incrementally and abandon paths that cannot lead to solution."
  },
  2699: {
      "title": "Modify Graph Edge Weights",
      "slug": "modify-graph-edge-weights",
      "difficulty": "hard",
      "primaryPattern": "Heap/Priority Queue",
      "acceptablePatterns": [
          "Graph",
          "BFS"
      ],
      "explanation": "Maintain ordered access to min/max elements. Useful for k-largest/smallest, merging, or scheduling problems."
  },
  2703: {
      "title": "Return Length of Arguments Passed",
      "slug": "return-length-of-arguments-passed",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2704: {
      "title": "To Be Or Not To Be",
      "slug": "to-be-or-not-to-be",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2705: {
      "title": "Compact Object",
      "slug": "compact-object",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2706: {
      "title": "Buy Two Chocolates",
      "slug": "buy-two-chocolates",
      "difficulty": "easy",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  2707: {
      "title": "Extra Characters in a String",
      "slug": "extra-characters-in-a-string",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Dynamic Programming",
          "Trie"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2708: {
      "title": "Maximum Strength of a Group",
      "slug": "maximum-strength-of-a-group",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Backtracking",
          "Greedy",
          "Two Pointers"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2709: {
      "title": "Greatest Common Divisor Traversal",
      "slug": "greatest-common-divisor-traversal",
      "difficulty": "hard",
      "primaryPattern": "Graph",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Graph algorithms - may involve topological sort, cycle detection, union find, or connectivity checks."
  },
  2710: {
      "title": "Remove Trailing Zeros From a String",
      "slug": "remove-trailing-zeros-from-a-string",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2711: {
      "title": "Difference of Number of Distinct Values on Diagonals",
      "slug": "difference-of-number-of-distinct-values-on-diagonals",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "DFS"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2712: {
      "title": "Minimum Cost to Make All Characters Equal",
      "slug": "minimum-cost-to-make-all-characters-equal",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2713: {
      "title": "Maximum Strictly Increasing Cells in a Matrix",
      "slug": "maximum-strictly-increasing-cells-in-a-matrix",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Binary Search",
          "Dynamic Programming",
          "Two Pointers",
          "DFS"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2715: {
      "title": "Timeout Cancellation",
      "slug": "timeout-cancellation",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2716: {
      "title": "Minimize String Length",
      "slug": "minimize-string-length",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2717: {
      "title": "Semi-Ordered Permutation",
      "slug": "semi-ordered-permutation",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2718: {
      "title": "Sum of Matrix After Queries",
      "slug": "sum-of-matrix-after-queries",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2719: {
      "title": "Count of Integers",
      "slug": "count-of-integers",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2721: {
      "title": "Execute Asynchronous Functions in Parallel",
      "slug": "execute-asynchronous-functions-in-parallel",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2722: {
      "title": "Join Two Arrays by ID",
      "slug": "join-two-arrays-by-id",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2723: {
      "title": "Add Two Promises",
      "slug": "add-two-promises",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2724: {
      "title": "Sort By",
      "slug": "sort-by",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2725: {
      "title": "Interval Cancellation",
      "slug": "interval-cancellation",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2726: {
      "title": "Calculator with Method Chaining",
      "slug": "calculator-with-method-chaining",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2727: {
      "title": "Is Object Empty",
      "slug": "is-object-empty",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2729: {
      "title": "Check if The Number is Fascinating",
      "slug": "check-if-the-number-is-fascinating",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2730: {
      "title": "Find the Longest Semi-Repetitive Substring",
      "slug": "find-the-longest-semi-repetitive-substring",
      "difficulty": "medium",
      "primaryPattern": "Sliding Window",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Maintain a window of elements that slides through the array. Expand when adding elements, contract when removing. Track window state."
  },
  2731: {
      "title": "Movement of Robots",
      "slug": "movement-of-robots",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2732: {
      "title": "Find a Good Subset of the Matrix",
      "slug": "find-a-good-subset-of-the-matrix",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "DFS"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2733: {
      "title": "Neither Minimum nor Maximum",
      "slug": "neither-minimum-nor-maximum",
      "difficulty": "easy",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  2734: {
      "title": "Lexicographically Smallest String After Substring Operation",
      "slug": "lexicographically-smallest-string-after-substring-operation",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  2735: {
      "title": "Collecting Chocolates",
      "slug": "collecting-chocolates",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2736: {
      "title": "Maximum Sum Queries",
      "slug": "maximum-sum-queries",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Stack",
          "Two Pointers"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  2739: {
      "title": "Total Distance Traveled",
      "slug": "total-distance-traveled",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2740: {
      "title": "Find the Value of the Partition",
      "slug": "find-the-value-of-the-partition",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  2741: {
      "title": "Special Permutations",
      "slug": "special-permutations",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2742: {
      "title": "Painting the Walls",
      "slug": "painting-the-walls",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2744: {
      "title": "Find Maximum Number of String Pairs",
      "slug": "find-maximum-number-of-string-pairs",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2745: {
      "title": "Construct the Longest New String",
      "slug": "construct-the-longest-new-string",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2746: {
      "title": "Decremental String Concatenation",
      "slug": "decremental-string-concatenation",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2747: {
      "title": "Count Zero Request Servers",
      "slug": "count-zero-request-servers",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Sliding Window",
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2748: {
      "title": "Number of Beautiful Pairs",
      "slug": "number-of-beautiful-pairs",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2749: {
      "title": "Minimum Operations to Make the Integer Zero",
      "slug": "minimum-operations-to-make-the-integer-zero",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2750: {
      "title": "Ways to Split Array Into Good Subarrays",
      "slug": "ways-to-split-array-into-good-subarrays",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2751: {
      "title": "Robot Collisions",
      "slug": "robot-collisions",
      "difficulty": "hard",
      "primaryPattern": "Stack",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "LIFO structure for nested patterns, matching pairs, or maintaining monotonic sequences."
  },
  2760: {
      "title": "Longest Even Odd Subarray With Threshold",
      "slug": "longest-even-odd-subarray-with-threshold",
      "difficulty": "easy",
      "primaryPattern": "Sliding Window",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Maintain a window of elements that slides through the array. Expand when adding elements, contract when removing. Track window state."
  },
  2761: {
      "title": "Prime Pairs With Target Sum",
      "slug": "prime-pairs-with-target-sum",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2762: {
      "title": "Continuous Subarrays",
      "slug": "continuous-subarrays",
      "difficulty": "medium",
      "primaryPattern": "Sliding Window",
      "acceptablePatterns": [
          "Hash Map",
          "BFS",
          "Heap/Priority Queue"
      ],
      "explanation": "Maintain a window of elements that slides through the array. Expand when adding elements, contract when removing. Track window state."
  },
  2763: {
      "title": "Sum of Imbalance Numbers of All Subarrays",
      "slug": "sum-of-imbalance-numbers-of-all-subarrays",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2765: {
      "title": "Longest Alternating Subarray",
      "slug": "longest-alternating-subarray",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2766: {
      "title": "Relocate Marbles",
      "slug": "relocate-marbles",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2767: {
      "title": "Partition String Into Minimum Beautiful Substrings",
      "slug": "partition-string-into-minimum-beautiful-substrings",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Dynamic Programming",
          "Backtracking"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2768: {
      "title": "Number of Black Blocks",
      "slug": "number-of-black-blocks",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2769: {
      "title": "Find the Maximum Achievable Number",
      "slug": "find-the-maximum-achievable-number",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2770: {
      "title": "Maximum Number of Jumps to Reach the Last Index",
      "slug": "maximum-number-of-jumps-to-reach-the-last-index",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2771: {
      "title": "Longest Non-decreasing Subarray From Two Arrays",
      "slug": "longest-non-decreasing-subarray-from-two-arrays",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2772: {
      "title": "Apply Operations to Make All Array Elements Equal to Zero",
      "slug": "apply-operations-to-make-all-array-elements-equal-to-zero",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2778: {
      "title": "Sum of Squares of Special Elements ",
      "slug": "sum-of-squares-of-special-elements",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2779: {
      "title": "Maximum Beauty of an Array After Applying Operation",
      "slug": "maximum-beauty-of-an-array-after-applying-operation",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Sliding Window",
          "Two Pointers"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  2780: {
      "title": "Minimum Index of a Valid Split",
      "slug": "minimum-index-of-a-valid-split",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2781: {
      "title": "Length of the Longest Valid Substring",
      "slug": "length-of-the-longest-valid-substring",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Sliding Window"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2784: {
      "title": "Check if Array is Good",
      "slug": "check-if-array-is-good",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2785: {
      "title": "Sort Vowels in a String",
      "slug": "sort-vowels-in-a-string",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  2786: {
      "title": "Visit Array Positions to Maximize Score",
      "slug": "visit-array-positions-to-maximize-score",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2787: {
      "title": "Ways to Express an Integer as Sum of Powers",
      "slug": "ways-to-express-an-integer-as-sum-of-powers",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2788: {
      "title": "Split Strings by Separator",
      "slug": "split-strings-by-separator",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2789: {
      "title": "Largest Element in an Array after Merge Operations",
      "slug": "largest-element-in-an-array-after-merge-operations",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  2790: {
      "title": "Maximum Number of Groups With Increasing Length",
      "slug": "maximum-number-of-groups-with-increasing-length",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy",
          "Two Pointers"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  2791: {
      "title": "Count Paths That Can Form a Palindrome in a Tree",
      "slug": "count-paths-that-can-form-a-palindrome-in-a-tree",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Tree Traversal",
          "DFS"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2798: {
      "title": "Number of Employees Who Met the Target",
      "slug": "number-of-employees-who-met-the-target",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2799: {
      "title": "Count Complete Subarrays in an Array",
      "slug": "count-complete-subarrays-in-an-array",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Sliding Window"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2800: {
      "title": "Shortest String That Contains Three Strings",
      "slug": "shortest-string-that-contains-three-strings",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  2801: {
      "title": "Count Stepping Numbers in Range",
      "slug": "count-stepping-numbers-in-range",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2806: {
      "title": "Account Balance After Rounded Purchase",
      "slug": "account-balance-after-rounded-purchase",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2807: {
      "title": "Insert Greatest Common Divisors in Linked List",
      "slug": "insert-greatest-common-divisors-in-linked-list",
      "difficulty": "medium",
      "primaryPattern": "Linked List",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Pointer manipulation for reversing, merging, detecting cycles, or finding intersections in linked structures."
  },
  2808: {
      "title": "Minimum Seconds to Equalize a Circular Array",
      "slug": "minimum-seconds-to-equalize-a-circular-array",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2809: {
      "title": "Minimum Time to Make Array Sum At Most x",
      "slug": "minimum-time-to-make-array-sum-at-most-x",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2810: {
      "title": "Faulty Keyboard",
      "slug": "faulty-keyboard",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2811: {
      "title": "Check if it is Possible to Split Array",
      "slug": "check-if-it-is-possible-to-split-array",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2812: {
      "title": "Find the Safest Path in a Grid",
      "slug": "find-the-safest-path-in-a-grid",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "BFS",
          "Graph",
          "Heap/Priority Queue",
          "DFS"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  2813: {
      "title": "Maximum Elegance of a K-Length Subsequence",
      "slug": "maximum-elegance-of-a-k-length-subsequence",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Stack",
          "Greedy",
          "Two Pointers",
          "Heap/Priority Queue"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2815: {
      "title": "Max Pair Sum in an Array",
      "slug": "max-pair-sum-in-an-array",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2816: {
      "title": "Double a Number Represented as a Linked List",
      "slug": "double-a-number-represented-as-a-linked-list",
      "difficulty": "medium",
      "primaryPattern": "Linked List",
      "acceptablePatterns": [
          "Hash Map",
          "Stack"
      ],
      "explanation": "Pointer manipulation for reversing, merging, detecting cycles, or finding intersections in linked structures."
  },
  2817: {
      "title": "Minimum Absolute Difference Between Elements With Constraint",
      "slug": "minimum-absolute-difference-between-elements-with-constraint",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  2818: {
      "title": "Apply Operations to Maximize Score",
      "slug": "apply-operations-to-maximize-score",
      "difficulty": "hard",
      "primaryPattern": "Stack",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy",
          "Two Pointers"
      ],
      "explanation": "LIFO structure for nested patterns, matching pairs, or maintaining monotonic sequences."
  },
  2824: {
      "title": "Count Pairs Whose Sum is Less than Target",
      "slug": "count-pairs-whose-sum-is-less-than-target",
      "difficulty": "easy",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map",
          "Binary Search"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  2825: {
      "title": "Make String a Subsequence Using Cyclic Increments",
      "slug": "make-string-a-subsequence-using-cyclic-increments",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  2826: {
      "title": "Sorting Three Groups",
      "slug": "sorting-three-groups",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Dynamic Programming"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  2827: {
      "title": "Number of Beautiful Integers in the Range",
      "slug": "number-of-beautiful-integers-in-the-range",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2828: {
      "title": "Check if a String Is an Acronym of Words",
      "slug": "check-if-a-string-is-an-acronym-of-words",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2829: {
      "title": "Determine the Minimum Sum of a k-avoiding Array",
      "slug": "determine-the-minimum-sum-of-a-k-avoiding-array",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  2830: {
      "title": "Maximize the Profit as the Salesman",
      "slug": "maximize-the-profit-as-the-salesman",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Binary Search",
          "Dynamic Programming",
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2831: {
      "title": "Find the Longest Equal Subarray",
      "slug": "find-the-longest-equal-subarray",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Binary Search",
          "Sliding Window"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2833: {
      "title": "Furthest Point From Origin",
      "slug": "furthest-point-from-origin",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2834: {
      "title": "Find the Minimum Possible Sum of a Beautiful Array",
      "slug": "find-the-minimum-possible-sum-of-a-beautiful-array",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  2835: {
      "title": "Minimum Operations to Form Subsequence With Target Sum",
      "slug": "minimum-operations-to-form-subsequence-with-target-sum",
      "difficulty": "hard",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  2836: {
      "title": "Maximize Value of Function in a Ball Passing Game",
      "slug": "maximize-value-of-function-in-a-ball-passing-game",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2839: {
      "title": "Check if Strings Can be Made Equal With Operations I",
      "slug": "check-if-strings-can-be-made-equal-with-operations-i",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2840: {
      "title": "Check if Strings Can be Made Equal With Operations II",
      "slug": "check-if-strings-can-be-made-equal-with-operations-ii",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2841: {
      "title": "Maximum Sum of Almost Unique Subarray",
      "slug": "maximum-sum-of-almost-unique-subarray",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Sliding Window"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2842: {
      "title": "Count K-Subsequences of a String With Maximum Beauty",
      "slug": "count-k-subsequences-of-a-string-with-maximum-beauty",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Greedy"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2843: {
      "title": "  Count Symmetric Integers",
      "slug": "count-symmetric-integers",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2844: {
      "title": "Minimum Operations to Make a Special Number",
      "slug": "minimum-operations-to-make-a-special-number",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  2845: {
      "title": "Count of Interesting Subarrays",
      "slug": "count-of-interesting-subarrays",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2846: {
      "title": "Minimum Edge Weight Equilibrium Queries in a Tree",
      "slug": "minimum-edge-weight-equilibrium-queries-in-a-tree",
      "difficulty": "hard",
      "primaryPattern": "Tree Traversal",
      "acceptablePatterns": [
          "Hash Map",
          "Graph"
      ],
      "explanation": "Navigate tree structures using inorder, preorder, or postorder traversal. Consider recursive or iterative approaches."
  },
  2848: {
      "title": "Points That Intersect With Cars",
      "slug": "points-that-intersect-with-cars",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2849: {
      "title": "Determine if a Cell Is Reachable at a Given Time",
      "slug": "determine-if-a-cell-is-reachable-at-a-given-time",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2850: {
      "title": "Minimum Moves to Spread Stones Over Grid",
      "slug": "minimum-moves-to-spread-stones-over-grid",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "BFS",
          "DFS"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2851: {
      "title": "String Transformation",
      "slug": "string-transformation",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2855: {
      "title": "Minimum Right Shifts to Sort the Array",
      "slug": "minimum-right-shifts-to-sort-the-array",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2856: {
      "title": "Minimum Array Length After Pair Removals",
      "slug": "minimum-array-length-after-pair-removals",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Two Pointers",
          "Binary Search",
          "Greedy"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2857: {
      "title": "Count Pairs of Points With Distance k",
      "slug": "count-pairs-of-points-with-distance-k",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2858: {
      "title": "Minimum Edge Reversals So Every Node Is Reachable",
      "slug": "minimum-edge-reversals-so-every-node-is-reachable",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "DFS",
          "BFS",
          "Graph"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2859: {
      "title": "Sum of Values at Indices With K Set Bits",
      "slug": "sum-of-values-at-indices-with-k-set-bits",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2860: {
      "title": "Happy Students",
      "slug": "happy-students",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  2861: {
      "title": "Maximum Number of Alloys",
      "slug": "maximum-number-of-alloys",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  2862: {
      "title": "Maximum Element-Sum of a Complete Subset of Indices",
      "slug": "maximum-element-sum-of-a-complete-subset-of-indices",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2864: {
      "title": "Maximum Odd Binary Number",
      "slug": "maximum-odd-binary-number",
      "difficulty": "easy",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  2865: {
      "title": "Beautiful Towers I",
      "slug": "beautiful-towers-i",
      "difficulty": "medium",
      "primaryPattern": "Stack",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "LIFO structure for nested patterns, matching pairs, or maintaining monotonic sequences."
  },
  2866: {
      "title": "Beautiful Towers II",
      "slug": "beautiful-towers-ii",
      "difficulty": "medium",
      "primaryPattern": "Stack",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "LIFO structure for nested patterns, matching pairs, or maintaining monotonic sequences."
  },
  2867: {
      "title": "Count Valid Paths in a Tree",
      "slug": "count-valid-paths-in-a-tree",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Tree Traversal",
          "DFS"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2869: {
      "title": "Minimum Operations to Collect Elements",
      "slug": "minimum-operations-to-collect-elements",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2870: {
      "title": "Minimum Number of Operations to Make Array Empty",
      "slug": "minimum-number-of-operations-to-make-array-empty",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Greedy"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2871: {
      "title": "Split Array Into Maximum Number of Subarrays",
      "slug": "split-array-into-maximum-number-of-subarrays",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  2872: {
      "title": "Maximum Number of K-Divisible Components",
      "slug": "maximum-number-of-k-divisible-components",
      "difficulty": "hard",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Tree Traversal"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  2873: {
      "title": "Maximum Value of an Ordered Triplet I",
      "slug": "maximum-value-of-an-ordered-triplet-i",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2874: {
      "title": "Maximum Value of an Ordered Triplet II",
      "slug": "maximum-value-of-an-ordered-triplet-ii",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2875: {
      "title": "Minimum Size Subarray in Infinite Array",
      "slug": "minimum-size-subarray-in-infinite-array",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Sliding Window"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2876: {
      "title": "Count Visited Nodes in a Directed Graph",
      "slug": "count-visited-nodes-in-a-directed-graph",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Graph"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2877: {
      "title": "Create a DataFrame from List",
      "slug": "create-a-dataframe-from-list",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2878: {
      "title": "Get the Size of a DataFrame",
      "slug": "get-the-size-of-a-dataframe",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2879: {
      "title": "Display the First Three Rows",
      "slug": "display-the-first-three-rows",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2880: {
      "title": "Select Data",
      "slug": "select-data",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2881: {
      "title": "Create a New Column",
      "slug": "create-a-new-column",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2882: {
      "title": "Drop Duplicate Rows",
      "slug": "drop-duplicate-rows",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2883: {
      "title": "Drop Missing Data",
      "slug": "drop-missing-data",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2884: {
      "title": "Modify Columns",
      "slug": "modify-columns",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2885: {
      "title": "Rename Columns",
      "slug": "rename-columns",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2886: {
      "title": "Change Data Type",
      "slug": "change-data-type",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2887: {
      "title": "Fill Missing Data",
      "slug": "fill-missing-data",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2888: {
      "title": "Reshape Data: Concatenate",
      "slug": "reshape-data-concatenate",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2889: {
      "title": "Reshape Data: Pivot",
      "slug": "reshape-data-pivot",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2890: {
      "title": "Reshape Data: Melt",
      "slug": "reshape-data-melt",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2891: {
      "title": "Method Chaining",
      "slug": "method-chaining",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2894: {
      "title": "Divisible and Non-divisible Sums Difference",
      "slug": "divisible-and-non-divisible-sums-difference",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2895: {
      "title": "Minimum Processing Time",
      "slug": "minimum-processing-time",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  2896: {
      "title": "Apply Operations to Make Two Strings Equal",
      "slug": "apply-operations-to-make-two-strings-equal",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2897: {
      "title": "Apply Operations on Array to Maximize Sum of Squares",
      "slug": "apply-operations-on-array-to-maximize-sum-of-squares",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Greedy"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2899: {
      "title": "Last Visited Integers",
      "slug": "last-visited-integers",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2900: {
      "title": "Longest Unequal Adjacent Groups Subsequence I",
      "slug": "longest-unequal-adjacent-groups-subsequence-i",
      "difficulty": "easy",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2901: {
      "title": "Longest Unequal Adjacent Groups Subsequence II",
      "slug": "longest-unequal-adjacent-groups-subsequence-ii",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2902: {
      "title": "Count of Sub-Multisets With Bounded Sum",
      "slug": "count-of-sub-multisets-with-bounded-sum",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Dynamic Programming",
          "Sliding Window"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2903: {
      "title": "Find Indices With Index and Value Difference I",
      "slug": "find-indices-with-index-and-value-difference-i",
      "difficulty": "easy",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  2904: {
      "title": "Shortest and Lexicographically Smallest Beautiful String",
      "slug": "shortest-and-lexicographically-smallest-beautiful-string",
      "difficulty": "medium",
      "primaryPattern": "Sliding Window",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Maintain a window of elements that slides through the array. Expand when adding elements, contract when removing. Track window state."
  },
  2905: {
      "title": "Find Indices With Index and Value Difference II",
      "slug": "find-indices-with-index-and-value-difference-ii",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  2906: {
      "title": "Construct Product Matrix",
      "slug": "construct-product-matrix",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "DFS"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2908: {
      "title": "Minimum Sum of Mountain Triplets I",
      "slug": "minimum-sum-of-mountain-triplets-i",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2909: {
      "title": "Minimum Sum of Mountain Triplets II",
      "slug": "minimum-sum-of-mountain-triplets-ii",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2910: {
      "title": "Minimum Number of Groups to Create a Valid Assignment",
      "slug": "minimum-number-of-groups-to-create-a-valid-assignment",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Greedy"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2911: {
      "title": "Minimum Changes to Make K Semi-palindromes",
      "slug": "minimum-changes-to-make-k-semi-palindromes",
      "difficulty": "hard",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map",
          "Dynamic Programming"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  2913: {
      "title": "Subarrays Distinct Element Sum of Squares I",
      "slug": "subarrays-distinct-element-sum-of-squares-i",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2914: {
      "title": "Minimum Number of Changes to Make Binary String Beautiful",
      "slug": "minimum-number-of-changes-to-make-binary-string-beautiful",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2915: {
      "title": "Length of the Longest Subsequence That Sums to Target",
      "slug": "length-of-the-longest-subsequence-that-sums-to-target",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2916: {
      "title": "Subarrays Distinct Element Sum of Squares II",
      "slug": "subarrays-distinct-element-sum-of-squares-ii",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2917: {
      "title": "Find the K-or of an Array",
      "slug": "find-the-k-or-of-an-array",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2918: {
      "title": "Minimum Equal Sum of Two Arrays After Replacing Zeros",
      "slug": "minimum-equal-sum-of-two-arrays-after-replacing-zeros",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  2919: {
      "title": "Minimum Increment Operations to Make Array Beautiful",
      "slug": "minimum-increment-operations-to-make-array-beautiful",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2920: {
      "title": "Maximum Points After Collecting Coins From All Nodes",
      "slug": "maximum-points-after-collecting-coins-from-all-nodes",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Tree Traversal",
          "DFS"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2923: {
      "title": "Find Champion I",
      "slug": "find-champion-i",
      "difficulty": "easy",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  2924: {
      "title": "Find Champion II",
      "slug": "find-champion-ii",
      "difficulty": "medium",
      "primaryPattern": "Graph",
      "acceptablePatterns": [],
      "explanation": "Graph algorithms - may involve topological sort, cycle detection, union find, or connectivity checks."
  },
  2925: {
      "title": "Maximum Score After Applying Operations on a Tree",
      "slug": "maximum-score-after-applying-operations-on-a-tree",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Tree Traversal",
          "DFS"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2926: {
      "title": "Maximum Balanced Subsequence Sum",
      "slug": "maximum-balanced-subsequence-sum",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Dynamic Programming"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  2928: {
      "title": "Distribute Candies Among Children I",
      "slug": "distribute-candies-among-children-i",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2929: {
      "title": "Distribute Candies Among Children II",
      "slug": "distribute-candies-among-children-ii",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2930: {
      "title": "Number of Strings Which Can Be Rearranged to Contain Substring",
      "slug": "number-of-strings-which-can-be-rearranged-to-contain-substring",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2931: {
      "title": "Maximum Spending After Buying Items",
      "slug": "maximum-spending-after-buying-items",
      "difficulty": "hard",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers",
          "Heap/Priority Queue",
          "DFS"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  2932: {
      "title": "Maximum Strong Pair XOR I",
      "slug": "maximum-strong-pair-xor-i",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Trie",
          "Sliding Window"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2933: {
      "title": "High-Access Employees",
      "slug": "high-access-employees",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2934: {
      "title": "Minimum Operations to Maximize Last Elements in Arrays",
      "slug": "minimum-operations-to-maximize-last-elements-in-arrays",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2935: {
      "title": "Maximum Strong Pair XOR II",
      "slug": "maximum-strong-pair-xor-ii",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Trie",
          "Sliding Window"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2937: {
      "title": "Make Three Strings Equal",
      "slug": "make-three-strings-equal",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2938: {
      "title": "Separate Black and White Balls",
      "slug": "separate-black-and-white-balls",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  2939: {
      "title": "Maximum Xor Product",
      "slug": "maximum-xor-product",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  2940: {
      "title": "Find Building Where Alice and Bob Can Meet",
      "slug": "find-building-where-alice-and-bob-can-meet",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Stack",
          "Heap/Priority Queue"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  2942: {
      "title": "Find Words Containing Character",
      "slug": "find-words-containing-character",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2943: {
      "title": "Maximize Area of Square Hole in Grid",
      "slug": "maximize-area-of-square-hole-in-grid",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  2944: {
      "title": "Minimum Number of Coins for Fruits",
      "slug": "minimum-number-of-coins-for-fruits",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "BFS",
          "Heap/Priority Queue",
          "Sliding Window"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2945: {
      "title": "Find Maximum Non-decreasing Array Length",
      "slug": "find-maximum-non-decreasing-array-length",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Dynamic Programming",
          "Stack",
          "BFS",
          "Sliding Window"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  2946: {
      "title": "Matrix Similarity After Cyclic Shifts",
      "slug": "matrix-similarity-after-cyclic-shifts",
      "difficulty": "easy",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  2947: {
      "title": "Count Beautiful Substrings I",
      "slug": "count-beautiful-substrings-i",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2948: {
      "title": "Make Lexicographically Smallest Array by Swapping Elements",
      "slug": "make-lexicographically-smallest-array-by-swapping-elements",
      "difficulty": "medium",
      "primaryPattern": "Graph",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Graph algorithms - may involve topological sort, cycle detection, union find, or connectivity checks."
  },
  2949: {
      "title": "Count Beautiful Substrings II",
      "slug": "count-beautiful-substrings-ii",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2951: {
      "title": "Find the Peaks",
      "slug": "find-the-peaks",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2952: {
      "title": "Minimum Number of Coins to be Added",
      "slug": "minimum-number-of-coins-to-be-added",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  2953: {
      "title": "Count Complete Substrings",
      "slug": "count-complete-substrings",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Sliding Window"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2954: {
      "title": "Count the Number of Infection Sequences",
      "slug": "count-the-number-of-infection-sequences",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2956: {
      "title": "Find Common Elements Between Two Arrays",
      "slug": "find-common-elements-between-two-arrays",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2957: {
      "title": "Remove Adjacent Almost-Equal Characters",
      "slug": "remove-adjacent-almost-equal-characters",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2958: {
      "title": "Length of Longest Subarray With at Most K Frequency",
      "slug": "length-of-longest-subarray-with-at-most-k-frequency",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Sliding Window"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2959: {
      "title": "Number of Possible Sets of Closing Branches",
      "slug": "number-of-possible-sets-of-closing-branches",
      "difficulty": "hard",
      "primaryPattern": "Heap/Priority Queue",
      "acceptablePatterns": [
          "Hash Map",
          "Graph",
          "BFS"
      ],
      "explanation": "Maintain ordered access to min/max elements. Useful for k-largest/smallest, merging, or scheduling problems."
  },
  2960: {
      "title": "Count Tested Devices After Test Operations",
      "slug": "count-tested-devices-after-test-operations",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2961: {
      "title": "Double Modular Exponentiation",
      "slug": "double-modular-exponentiation",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2962: {
      "title": "Count Subarrays Where Max Element Appears at Least K Times",
      "slug": "count-subarrays-where-max-element-appears-at-least-k-times",
      "difficulty": "medium",
      "primaryPattern": "Sliding Window",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Maintain a window of elements that slides through the array. Expand when adding elements, contract when removing. Track window state."
  },
  2963: {
      "title": "Count the Number of Good Partitions",
      "slug": "count-the-number-of-good-partitions",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2965: {
      "title": "Find Missing and Repeated Values",
      "slug": "find-missing-and-repeated-values",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "DFS"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2966: {
      "title": "Divide Array Into Arrays With Max Difference",
      "slug": "divide-array-into-arrays-with-max-difference",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  2967: {
      "title": "Minimum Cost to Make Array Equalindromic",
      "slug": "minimum-cost-to-make-array-equalindromic",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy",
          "Two Pointers"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  2968: {
      "title": "Apply Operations to Maximize Frequency Score",
      "slug": "apply-operations-to-maximize-frequency-score",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Sliding Window",
          "Two Pointers"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  2970: {
      "title": "Count the Number of Incremovable Subarrays I",
      "slug": "count-the-number-of-incremovable-subarrays-i",
      "difficulty": "easy",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map",
          "Binary Search"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  2971: {
      "title": "Find Polygon With the Largest Perimeter",
      "slug": "find-polygon-with-the-largest-perimeter",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  2972: {
      "title": "Count the Number of Incremovable Subarrays II",
      "slug": "count-the-number-of-incremovable-subarrays-ii",
      "difficulty": "hard",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map",
          "Binary Search"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  2973: {
      "title": "Find Number of Coins to Place in Tree Nodes",
      "slug": "find-number-of-coins-to-place-in-tree-nodes",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Tree Traversal",
          "DFS",
          "Two Pointers",
          "Heap/Priority Queue"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2974: {
      "title": "Minimum Number Game",
      "slug": "minimum-number-game",
      "difficulty": "easy",
      "primaryPattern": "Heap/Priority Queue",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Maintain ordered access to min/max elements. Useful for k-largest/smallest, merging, or scheduling problems."
  },
  2975: {
      "title": "Maximum Square Area by Removing Fences From a Field",
      "slug": "maximum-square-area-by-removing-fences-from-a-field",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2976: {
      "title": "Minimum Cost to Convert String I",
      "slug": "minimum-cost-to-convert-string-i",
      "difficulty": "medium",
      "primaryPattern": "Graph",
      "acceptablePatterns": [
          "Hash Map",
          "BFS"
      ],
      "explanation": "Graph algorithms - may involve topological sort, cycle detection, union find, or connectivity checks."
  },
  2977: {
      "title": "Minimum Cost to Convert String II",
      "slug": "minimum-cost-to-convert-string-ii",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Graph",
          "Trie",
          "BFS"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2980: {
      "title": "Check if Bitwise OR Has Trailing Zeros",
      "slug": "check-if-bitwise-or-has-trailing-zeros",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2981: {
      "title": "Find Longest Special Substring That Occurs Thrice I",
      "slug": "find-longest-special-substring-that-occurs-thrice-i",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Binary Search",
          "Sliding Window"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2982: {
      "title": "Find Longest Special Substring That Occurs Thrice II",
      "slug": "find-longest-special-substring-that-occurs-thrice-ii",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Binary Search",
          "Sliding Window"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2983: {
      "title": "Palindrome Rearrangement Queries",
      "slug": "palindrome-rearrangement-queries",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2996: {
      "title": "Smallest Missing Integer Greater Than Sequential Prefix Sum",
      "slug": "smallest-missing-integer-greater-than-sequential-prefix-sum",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2997: {
      "title": "Minimum Number of Operations to Make Array XOR Equal to K",
      "slug": "minimum-number-of-operations-to-make-array-xor-equal-to-k",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  2998: {
      "title": "Minimum Number of Operations to Make X and Y Equal",
      "slug": "minimum-number-of-operations-to-make-x-and-y-equal",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "BFS"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  2999: {
      "title": "Count the Number of Powerful Integers",
      "slug": "count-the-number-of-powerful-integers",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3000: {
      "title": "Maximum Area of Longest Diagonal Rectangle",
      "slug": "maximum-area-of-longest-diagonal-rectangle",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3001: {
      "title": "Minimum Moves to Capture The Queen",
      "slug": "minimum-moves-to-capture-the-queen",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3002: {
      "title": "Maximum Size of a Set After Removals",
      "slug": "maximum-size-of-a-set-after-removals",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Greedy"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3003: {
      "title": "Maximize the Number of Partitions After Operations",
      "slug": "maximize-the-number-of-partitions-after-operations",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3005: {
      "title": "Count Elements With Maximum Frequency",
      "slug": "count-elements-with-maximum-frequency",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3006: {
      "title": "Find Beautiful Indices in the Given Array I",
      "slug": "find-beautiful-indices-in-the-given-array-i",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map",
          "Binary Search"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  3007: {
      "title": "Maximum Number That Sum of the Prices Is Less Than or Equal to K",
      "slug": "maximum-number-that-sum-of-the-prices-is-less-than-or-equal-to-k",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Dynamic Programming"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  3008: {
      "title": "Find Beautiful Indices in the Given Array II",
      "slug": "find-beautiful-indices-in-the-given-array-ii",
      "difficulty": "hard",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map",
          "Binary Search"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  3010: {
      "title": "Divide an Array Into Subarrays With Minimum Cost I",
      "slug": "divide-an-array-into-subarrays-with-minimum-cost-i",
      "difficulty": "easy",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  3011: {
      "title": "Find if Array Can Be Sorted",
      "slug": "find-if-array-can-be-sorted",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3012: {
      "title": "Minimize Length of Array Using Operations",
      "slug": "minimize-length-of-array-using-operations",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  3013: {
      "title": "Divide an Array Into Subarrays With Minimum Cost II",
      "slug": "divide-an-array-into-subarrays-with-minimum-cost-ii",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Sliding Window",
          "Heap/Priority Queue"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3014: {
      "title": "Minimum Number of Pushes to Type Word I",
      "slug": "minimum-number-of-pushes-to-type-word-i",
      "difficulty": "easy",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  3015: {
      "title": "Count the Number of Houses at a Certain Distance I",
      "slug": "count-the-number-of-houses-at-a-certain-distance-i",
      "difficulty": "medium",
      "primaryPattern": "BFS",
      "acceptablePatterns": [
          "Graph",
          "Hash Map"
      ],
      "explanation": "Breadth-first search - explore level by level using a queue. Ideal for shortest path in unweighted graphs or level-order traversal."
  },
  3016: {
      "title": "Minimum Number of Pushes to Type Word II",
      "slug": "minimum-number-of-pushes-to-type-word-ii",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Greedy",
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3017: {
      "title": "Count the Number of Houses at a Certain Distance II",
      "slug": "count-the-number-of-houses-at-a-certain-distance-ii",
      "difficulty": "hard",
      "primaryPattern": "Graph",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Graph algorithms - may involve topological sort, cycle detection, union find, or connectivity checks."
  },
  3019: {
      "title": "Number of Changing Keys",
      "slug": "number-of-changing-keys",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3020: {
      "title": "Find the Maximum Number of Elements in Subset",
      "slug": "find-the-maximum-number-of-elements-in-subset",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3021: {
      "title": "Alice and Bob Playing Flower Game",
      "slug": "alice-and-bob-playing-flower-game",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3022: {
      "title": "Minimize OR of Remaining Elements Using Operations",
      "slug": "minimize-or-of-remaining-elements-using-operations",
      "difficulty": "hard",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  3024: {
      "title": "Type of Triangle",
      "slug": "type-of-triangle",
      "difficulty": "easy",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  3025: {
      "title": "Find the Number of Ways to Place People I",
      "slug": "find-the-number-of-ways-to-place-people-i",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3026: {
      "title": "Maximum Good Subarray Sum",
      "slug": "maximum-good-subarray-sum",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3027: {
      "title": "Find the Number of Ways to Place People II",
      "slug": "find-the-number-of-ways-to-place-people-ii",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3028: {
      "title": "Ant on the Boundary",
      "slug": "ant-on-the-boundary",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3029: {
      "title": "Minimum Time to Revert Word to Initial State I",
      "slug": "minimum-time-to-revert-word-to-initial-state-i",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3030: {
      "title": "Find the Grid of Region Average",
      "slug": "find-the-grid-of-region-average",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  3031: {
      "title": "Minimum Time to Revert Word to Initial State II",
      "slug": "minimum-time-to-revert-word-to-initial-state-ii",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3033: {
      "title": "Modify the Matrix",
      "slug": "modify-the-matrix",
      "difficulty": "easy",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  3034: {
      "title": "Number of Subarrays That Match a Pattern I",
      "slug": "number-of-subarrays-that-match-a-pattern-i",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3035: {
      "title": "Maximum Palindromes After Operations",
      "slug": "maximum-palindromes-after-operations",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Greedy",
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3036: {
      "title": "Number of Subarrays That Match a Pattern II",
      "slug": "number-of-subarrays-that-match-a-pattern-ii",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3038: {
      "title": "Maximum Number of Operations With the Same Score I",
      "slug": "maximum-number-of-operations-with-the-same-score-i",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3039: {
      "title": "Apply Operations to Make String Empty",
      "slug": "apply-operations-to-make-string-empty",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3040: {
      "title": "Maximum Number of Operations With the Same Score II",
      "slug": "maximum-number-of-operations-with-the-same-score-ii",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3041: {
      "title": "Maximize Consecutive Elements in an Array After Modification",
      "slug": "maximize-consecutive-elements-in-an-array-after-modification",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3042: {
      "title": "Count Prefix and Suffix Pairs I",
      "slug": "count-prefix-and-suffix-pairs-i",
      "difficulty": "easy",
      "primaryPattern": "Trie",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Prefix tree for efficient string operations. Each node represents a character, paths represent strings."
  },
  3043: {
      "title": "Find the Length of the Longest Common Prefix",
      "slug": "find-the-length-of-the-longest-common-prefix",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Trie"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3044: {
      "title": "Most Frequent Prime",
      "slug": "most-frequent-prime",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "DFS"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3045: {
      "title": "Count Prefix and Suffix Pairs II",
      "slug": "count-prefix-and-suffix-pairs-ii",
      "difficulty": "hard",
      "primaryPattern": "Trie",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Prefix tree for efficient string operations. Each node represents a character, paths represent strings."
  },
  3046: {
      "title": "Split the Array",
      "slug": "split-the-array",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3047: {
      "title": "Find the Largest Area of Square Inside Two Rectangles",
      "slug": "find-the-largest-area-of-square-inside-two-rectangles",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3048: {
      "title": "Earliest Second to Mark Indices I",
      "slug": "earliest-second-to-mark-indices-i",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  3049: {
      "title": "Earliest Second to Mark Indices II",
      "slug": "earliest-second-to-mark-indices-ii",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy",
          "Heap/Priority Queue"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  3065: {
      "title": "Minimum Operations to Exceed Threshold Value I",
      "slug": "minimum-operations-to-exceed-threshold-value-i",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3066: {
      "title": "Minimum Operations to Exceed Threshold Value II",
      "slug": "minimum-operations-to-exceed-threshold-value-ii",
      "difficulty": "medium",
      "primaryPattern": "Heap/Priority Queue",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Maintain ordered access to min/max elements. Useful for k-largest/smallest, merging, or scheduling problems."
  },
  3067: {
      "title": "Count Pairs of Connectable Servers in a Weighted Tree Network",
      "slug": "count-pairs-of-connectable-servers-in-a-weighted-tree-network",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map",
          "Tree Traversal"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  3068: {
      "title": "Find the Maximum Sum of Node Values",
      "slug": "find-the-maximum-sum-of-node-values",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy",
          "Tree Traversal",
          "Two Pointers"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3069: {
      "title": "Distribute Elements Into Two Arrays I",
      "slug": "distribute-elements-into-two-arrays-i",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3070: {
      "title": "Count Submatrices with Top-Left Element and Sum Less Than k",
      "slug": "count-submatrices-with-top-left-element-and-sum-less-than-k",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "DFS"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3071: {
      "title": "Minimum Operations to Write the Letter Y on a Grid",
      "slug": "minimum-operations-to-write-the-letter-y-on-a-grid",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "DFS"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3072: {
      "title": "Distribute Elements Into Two Arrays II",
      "slug": "distribute-elements-into-two-arrays-ii",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3074: {
      "title": "Apple Redistribution into Boxes",
      "slug": "apple-redistribution-into-boxes",
      "difficulty": "easy",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  3075: {
      "title": "Maximize Happiness of Selected Children",
      "slug": "maximize-happiness-of-selected-children",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  3076: {
      "title": "Shortest Uncommon Substring in an Array",
      "slug": "shortest-uncommon-substring-in-an-array",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Trie"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3077: {
      "title": "Maximum Strength of K Disjoint Subarrays",
      "slug": "maximum-strength-of-k-disjoint-subarrays",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3079: {
      "title": "Find the Sum of Encrypted Integers",
      "slug": "find-the-sum-of-encrypted-integers",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3080: {
      "title": "Mark Elements on Array by Performing Queries",
      "slug": "mark-elements-on-array-by-performing-queries",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Two Pointers",
          "Heap/Priority Queue"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3081: {
      "title": "Replace Question Marks in String to Minimize Its Value",
      "slug": "replace-question-marks-in-string-to-minimize-its-value",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Greedy",
          "Two Pointers",
          "Heap/Priority Queue"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3082: {
      "title": "Find the Sum of the Power of All Subsequences",
      "slug": "find-the-sum-of-the-power-of-all-subsequences",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3083: {
      "title": "Existence of a Substring in a String and Its Reverse",
      "slug": "existence-of-a-substring-in-a-string-and-its-reverse",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3084: {
      "title": "Count Substrings Starting and Ending with Given Character",
      "slug": "count-substrings-starting-and-ending-with-given-character",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3085: {
      "title": "Minimum Deletions to Make String K-Special",
      "slug": "minimum-deletions-to-make-string-k-special",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Greedy",
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3086: {
      "title": "Minimum Moves to Pick K Ones",
      "slug": "minimum-moves-to-pick-k-ones",
      "difficulty": "hard",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Sliding Window"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  3090: {
      "title": "Maximum Length Substring With Two Occurrences",
      "slug": "maximum-length-substring-with-two-occurrences",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Sliding Window"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3091: {
      "title": "Apply Operations to Make Sum of Array Greater Than or Equal to k",
      "slug": "apply-operations-to-make-sum-of-array-greater-than-or-equal-to-k",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  3092: {
      "title": "Most Frequent IDs",
      "slug": "most-frequent-ids",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Heap/Priority Queue"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3093: {
      "title": "Longest Common Suffix Queries",
      "slug": "longest-common-suffix-queries",
      "difficulty": "hard",
      "primaryPattern": "Trie",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Prefix tree for efficient string operations. Each node represents a character, paths represent strings."
  },
  3095: {
      "title": "Shortest Subarray With OR at Least K I",
      "slug": "shortest-subarray-with-or-at-least-k-i",
      "difficulty": "easy",
      "primaryPattern": "Sliding Window",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Maintain a window of elements that slides through the array. Expand when adding elements, contract when removing. Track window state."
  },
  3096: {
      "title": "Minimum Levels to Gain More Points",
      "slug": "minimum-levels-to-gain-more-points",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3097: {
      "title": "Shortest Subarray With OR at Least K II",
      "slug": "shortest-subarray-with-or-at-least-k-ii",
      "difficulty": "medium",
      "primaryPattern": "Sliding Window",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Maintain a window of elements that slides through the array. Expand when adding elements, contract when removing. Track window state."
  },
  3098: {
      "title": "Find the Sum of Subsequence Powers",
      "slug": "find-the-sum-of-subsequence-powers",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3099: {
      "title": "Harshad Number",
      "slug": "harshad-number",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3100: {
      "title": "Water Bottles II",
      "slug": "water-bottles-ii",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3101: {
      "title": "Count Alternating Subarrays",
      "slug": "count-alternating-subarrays",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3102: {
      "title": "Minimize Manhattan Distances",
      "slug": "minimize-manhattan-distances",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3105: {
      "title": "Longest Strictly Increasing or Strictly Decreasing Subarray",
      "slug": "longest-strictly-increasing-or-strictly-decreasing-subarray",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3106: {
      "title": "Lexicographically Smallest String After Operations With Constraint",
      "slug": "lexicographically-smallest-string-after-operations-with-constraint",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  3107: {
      "title": "Minimum Operations to Make Median of Array Equal to K",
      "slug": "minimum-operations-to-make-median-of-array-equal-to-k",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  3108: {
      "title": "Minimum Cost Walk in Weighted Graph",
      "slug": "minimum-cost-walk-in-weighted-graph",
      "difficulty": "hard",
      "primaryPattern": "Graph",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Graph algorithms - may involve topological sort, cycle detection, union find, or connectivity checks."
  },
  3110: {
      "title": "Score of a String",
      "slug": "score-of-a-string",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3111: {
      "title": "Minimum Rectangles to Cover Points",
      "slug": "minimum-rectangles-to-cover-points",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  3112: {
      "title": "Minimum Time to Visit Disappearing Nodes",
      "slug": "minimum-time-to-visit-disappearing-nodes",
      "difficulty": "medium",
      "primaryPattern": "Heap/Priority Queue",
      "acceptablePatterns": [
          "Hash Map",
          "Graph",
          "BFS"
      ],
      "explanation": "Maintain ordered access to min/max elements. Useful for k-largest/smallest, merging, or scheduling problems."
  },
  3113: {
      "title": "Find the Number of Subarrays Where Boundary Elements Are Maximum",
      "slug": "find-the-number-of-subarrays-where-boundary-elements-are-maximum",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Stack"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  3114: {
      "title": "Latest Time You Can Obtain After Replacing Characters",
      "slug": "latest-time-you-can-obtain-after-replacing-characters",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3115: {
      "title": "Maximum Prime Difference",
      "slug": "maximum-prime-difference",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3116: {
      "title": "Kth Smallest Amount With Single Denomination Combination",
      "slug": "kth-smallest-amount-with-single-denomination-combination",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  3117: {
      "title": "Minimum Sum of Values by Dividing Array",
      "slug": "minimum-sum-of-values-by-dividing-array",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Dynamic Programming",
          "BFS"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  3120: {
      "title": "Count the Number of Special Characters I",
      "slug": "count-the-number-of-special-characters-i",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3121: {
      "title": "Count the Number of Special Characters II",
      "slug": "count-the-number-of-special-characters-ii",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3122: {
      "title": "Minimum Number of Operations to Satisfy Conditions",
      "slug": "minimum-number-of-operations-to-satisfy-conditions",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "DFS"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3123: {
      "title": "Find Edges in Shortest Paths",
      "slug": "find-edges-in-shortest-paths",
      "difficulty": "hard",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "BFS",
          "Graph",
          "Heap/Priority Queue"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  3127: {
      "title": "Make a Square with the Same Color",
      "slug": "make-a-square-with-the-same-color",
      "difficulty": "easy",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  3128: {
      "title": "Right Triangles",
      "slug": "right-triangles",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3129: {
      "title": "Find All Possible Stable Binary Arrays I",
      "slug": "find-all-possible-stable-binary-arrays-i",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3130: {
      "title": "Find All Possible Stable Binary Arrays II",
      "slug": "find-all-possible-stable-binary-arrays-ii",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3131: {
      "title": "Find the Integer Added to Array I",
      "slug": "find-the-integer-added-to-array-i",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3132: {
      "title": "Find the Integer Added to Array II",
      "slug": "find-the-integer-added-to-array-ii",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  3133: {
      "title": "Minimum Array End",
      "slug": "minimum-array-end",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3134: {
      "title": "Find the Median of the Uniqueness Array",
      "slug": "find-the-median-of-the-uniqueness-array",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Binary Search",
          "Sliding Window"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3136: {
      "title": "Valid Word",
      "slug": "valid-word",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3137: {
      "title": "Minimum Number of Operations to Make Word K-Periodic",
      "slug": "minimum-number-of-operations-to-make-word-k-periodic",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3138: {
      "title": "Minimum Length of Anagram Concatenation",
      "slug": "minimum-length-of-anagram-concatenation",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3139: {
      "title": "Minimum Cost to Equalize Array",
      "slug": "minimum-cost-to-equalize-array",
      "difficulty": "hard",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  3142: {
      "title": "Check if Grid Satisfies Conditions",
      "slug": "check-if-grid-satisfies-conditions",
      "difficulty": "easy",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  3143: {
      "title": "Maximum Points Inside the Square",
      "slug": "maximum-points-inside-the-square",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Binary Search",
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3144: {
      "title": "Minimum Substring Partition of Equal Character Frequency",
      "slug": "minimum-substring-partition-of-equal-character-frequency",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Dynamic Programming"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3145: {
      "title": "Find Products of Elements of Big Array",
      "slug": "find-products-of-elements-of-big-array",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  3146: {
      "title": "Permutation Difference between Two Strings",
      "slug": "permutation-difference-between-two-strings",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3147: {
      "title": "Taking Maximum Energy From the Mystic Dungeon",
      "slug": "taking-maximum-energy-from-the-mystic-dungeon",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3148: {
      "title": "Maximum Difference Score in a Grid",
      "slug": "maximum-difference-score-in-a-grid",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "DFS"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3149: {
      "title": "Find the Minimum Cost Array Permutation",
      "slug": "find-the-minimum-cost-array-permutation",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3151: {
      "title": "Special Array I",
      "slug": "special-array-i",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3152: {
      "title": "Special Array II",
      "slug": "special-array-ii",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  3153: {
      "title": "Sum of Digit Differences of All Pairs",
      "slug": "sum-of-digit-differences-of-all-pairs",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3154: {
      "title": "Find Number of Ways to Reach the K-th Stair",
      "slug": "find-number-of-ways-to-reach-the-k-th-stair",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3158: {
      "title": "Find the XOR of Numbers Which Appear Twice",
      "slug": "find-the-xor-of-numbers-which-appear-twice",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3159: {
      "title": "Find Occurrences of an Element in an Array",
      "slug": "find-occurrences-of-an-element-in-an-array",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3160: {
      "title": "Find the Number of Distinct Colors Among the Balls",
      "slug": "find-the-number-of-distinct-colors-among-the-balls",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3161: {
      "title": "Block Placement Queries",
      "slug": "block-placement-queries",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  3162: {
      "title": "Find the Number of Good Pairs I",
      "slug": "find-the-number-of-good-pairs-i",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3163: {
      "title": "String Compression III",
      "slug": "string-compression-iii",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3164: {
      "title": "Find the Number of Good Pairs II",
      "slug": "find-the-number-of-good-pairs-ii",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3165: {
      "title": "Maximum Sum of Subsequence With Non-adjacent Elements",
      "slug": "maximum-sum-of-subsequence-with-non-adjacent-elements",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Binary Search"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3168: {
      "title": "Minimum Number of Chairs in a Waiting Room",
      "slug": "minimum-number-of-chairs-in-a-waiting-room",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3169: {
      "title": "Count Days Without Meetings",
      "slug": "count-days-without-meetings",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  3170: {
      "title": "Lexicographically Minimum String After Removing Stars",
      "slug": "lexicographically-minimum-string-after-removing-stars",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Stack",
          "Greedy",
          "Heap/Priority Queue"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3171: {
      "title": "Find Subarray With Bitwise OR Closest to K",
      "slug": "find-subarray-with-bitwise-or-closest-to-k",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  3174: {
      "title": "Clear Digits",
      "slug": "clear-digits",
      "difficulty": "easy",
      "primaryPattern": "Stack",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "LIFO structure for nested patterns, matching pairs, or maintaining monotonic sequences."
  },
  3175: {
      "title": "Find The First Player to win K Games in a Row",
      "slug": "find-the-first-player-to-win-k-games-in-a-row",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3176: {
      "title": "Find the Maximum Length of a Good Subsequence I",
      "slug": "find-the-maximum-length-of-a-good-subsequence-i",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Dynamic Programming"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3177: {
      "title": "Find the Maximum Length of a Good Subsequence II",
      "slug": "find-the-maximum-length-of-a-good-subsequence-ii",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Dynamic Programming"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3178: {
      "title": "Find the Child Who Has the Ball After K Seconds",
      "slug": "find-the-child-who-has-the-ball-after-k-seconds",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3179: {
      "title": "Find the N-th Value After K Seconds",
      "slug": "find-the-n-th-value-after-k-seconds",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3180: {
      "title": "Maximum Total Reward Using Operations I",
      "slug": "maximum-total-reward-using-operations-i",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3181: {
      "title": "Maximum Total Reward Using Operations II",
      "slug": "maximum-total-reward-using-operations-ii",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3184: {
      "title": "Count Pairs That Form a Complete Day I",
      "slug": "count-pairs-that-form-a-complete-day-i",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3185: {
      "title": "Count Pairs That Form a Complete Day II",
      "slug": "count-pairs-that-form-a-complete-day-ii",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3186: {
      "title": "Maximum Total Damage With Spell Casting",
      "slug": "maximum-total-damage-with-spell-casting",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Two Pointers",
          "Binary Search",
          "Dynamic Programming"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3187: {
      "title": "Peaks in Array",
      "slug": "peaks-in-array",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3190: {
      "title": "Find Minimum Operations to Make All Elements Divisible by Three",
      "slug": "find-minimum-operations-to-make-all-elements-divisible-by-three",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3191: {
      "title": "Minimum Operations to Make Binary Array Elements Equal to One I",
      "slug": "minimum-operations-to-make-binary-array-elements-equal-to-one-i",
      "difficulty": "medium",
      "primaryPattern": "Sliding Window",
      "acceptablePatterns": [
          "Hash Map",
          "BFS"
      ],
      "explanation": "Maintain a window of elements that slides through the array. Expand when adding elements, contract when removing. Track window state."
  },
  3192: {
      "title": "Minimum Operations to Make Binary Array Elements Equal to One II",
      "slug": "minimum-operations-to-make-binary-array-elements-equal-to-one-ii",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3193: {
      "title": "Count the Number of Inversions",
      "slug": "count-the-number-of-inversions",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3194: {
      "title": "Minimum Average of Smallest and Largest Elements",
      "slug": "minimum-average-of-smallest-and-largest-elements",
      "difficulty": "easy",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  3195: {
      "title": "Find the Minimum Area to Cover All Ones I",
      "slug": "find-the-minimum-area-to-cover-all-ones-i",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  3196: {
      "title": "Maximize Total Cost of Alternating Subarrays",
      "slug": "maximize-total-cost-of-alternating-subarrays",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3197: {
      "title": "Find the Minimum Area to Cover All Ones II",
      "slug": "find-the-minimum-area-to-cover-all-ones-ii",
      "difficulty": "hard",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  3200: {
      "title": "Maximum Height of a Triangle",
      "slug": "maximum-height-of-a-triangle",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3201: {
      "title": "Find the Maximum Length of Valid Subsequence I",
      "slug": "find-the-maximum-length-of-valid-subsequence-i",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3202: {
      "title": "Find the Maximum Length of Valid Subsequence II",
      "slug": "find-the-maximum-length-of-valid-subsequence-ii",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3203: {
      "title": "Find Minimum Diameter After Merging Two Trees",
      "slug": "find-minimum-diameter-after-merging-two-trees",
      "difficulty": "hard",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Tree Traversal",
          "BFS",
          "Graph"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  3206: {
      "title": "Alternating Groups I",
      "slug": "alternating-groups-i",
      "difficulty": "easy",
      "primaryPattern": "Sliding Window",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Maintain a window of elements that slides through the array. Expand when adding elements, contract when removing. Track window state."
  },
  3207: {
      "title": "Maximum Points After Enemy Battles",
      "slug": "maximum-points-after-enemy-battles",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  3208: {
      "title": "Alternating Groups II",
      "slug": "alternating-groups-ii",
      "difficulty": "medium",
      "primaryPattern": "Sliding Window",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Maintain a window of elements that slides through the array. Expand when adding elements, contract when removing. Track window state."
  },
  3209: {
      "title": "Number of Subarrays With AND Value of K",
      "slug": "number-of-subarrays-with-and-value-of-k",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  3210: {
      "title": "Find the Encrypted String",
      "slug": "find-the-encrypted-string",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3211: {
      "title": "Generate Binary Strings Without Adjacent Zeros",
      "slug": "generate-binary-strings-without-adjacent-zeros",
      "difficulty": "medium",
      "primaryPattern": "Backtracking",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Explore all possible solutions recursively. Build candidates incrementally and abandon paths that cannot lead to solution."
  },
  3212: {
      "title": "Count Submatrices With Equal Frequency of X and Y",
      "slug": "count-submatrices-with-equal-frequency-of-x-and-y",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "DFS"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3213: {
      "title": "Construct String with Minimum Cost",
      "slug": "construct-string-with-minimum-cost",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3216: {
      "title": "Lexicographically Smallest String After a Swap",
      "slug": "lexicographically-smallest-string-after-a-swap",
      "difficulty": "easy",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  3217: {
      "title": "Delete Nodes From Linked List Present in Array",
      "slug": "delete-nodes-from-linked-list-present-in-array",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Linked List"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3218: {
      "title": "Minimum Cost for Cutting Cake I",
      "slug": "minimum-cost-for-cutting-cake-i",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map",
          "Dynamic Programming",
          "Greedy"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  3219: {
      "title": "Minimum Cost for Cutting Cake II",
      "slug": "minimum-cost-for-cutting-cake-ii",
      "difficulty": "hard",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  3220: {
      "title": "Odd and Even Transactions",
      "slug": "odd-and-even-transactions",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3222: {
      "title": "Find the Winning Player in Coin Game",
      "slug": "find-the-winning-player-in-coin-game",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3223: {
      "title": "Minimum Length of String After Operations",
      "slug": "minimum-length-of-string-after-operations",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3224: {
      "title": "Minimum Array Changes to Make Differences Equal",
      "slug": "minimum-array-changes-to-make-differences-equal",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3225: {
      "title": "Maximum Score From Grid Operations",
      "slug": "maximum-score-from-grid-operations",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "DFS"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3226: {
      "title": "Number of Bit Changes to Make Two Integers Equal",
      "slug": "number-of-bit-changes-to-make-two-integers-equal",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3227: {
      "title": "Vowels Game in a String",
      "slug": "vowels-game-in-a-string",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3228: {
      "title": "Maximum Number of Operations to Move Ones to the End",
      "slug": "maximum-number-of-operations-to-move-ones-to-the-end",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  3229: {
      "title": "Minimum Operations to Make Array Equal to Target",
      "slug": "minimum-operations-to-make-array-equal-to-target",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Stack",
          "Greedy"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3232: {
      "title": "Find if Digit Game Can Be Won",
      "slug": "find-if-digit-game-can-be-won",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3233: {
      "title": "Find the Count of Numbers Which Are Not Special",
      "slug": "find-the-count-of-numbers-which-are-not-special",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3234: {
      "title": "Count the Number of Substrings With Dominant Ones",
      "slug": "count-the-number-of-substrings-with-dominant-ones",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3235: {
      "title": "Check if the Rectangle Corner Is Reachable",
      "slug": "check-if-the-rectangle-corner-is-reachable",
      "difficulty": "hard",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map",
          "BFS",
          "Graph"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  3238: {
      "title": "Find the Number of Winning Players",
      "slug": "find-the-number-of-winning-players",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3239: {
      "title": "Minimum Number of Flips to Make Binary Grid Palindromic I",
      "slug": "minimum-number-of-flips-to-make-binary-grid-palindromic-i",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map",
          "DFS"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  3240: {
      "title": "Minimum Number of Flips to Make Binary Grid Palindromic II",
      "slug": "minimum-number-of-flips-to-make-binary-grid-palindromic-ii",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map",
          "DFS"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  3241: {
      "title": "Time Taken to Mark All Nodes",
      "slug": "time-taken-to-mark-all-nodes",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Tree Traversal",
          "DFS",
          "Graph"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3242: {
      "title": "Design Neighbor Sum Service",
      "slug": "design-neighbor-sum-service",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "DFS"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3243: {
      "title": "Shortest Distance After Road Addition Queries I",
      "slug": "shortest-distance-after-road-addition-queries-i",
      "difficulty": "medium",
      "primaryPattern": "BFS",
      "acceptablePatterns": [
          "Hash Map",
          "Graph"
      ],
      "explanation": "Breadth-first search - explore level by level using a queue. Ideal for shortest path in unweighted graphs or level-order traversal."
  },
  3244: {
      "title": "Shortest Distance After Road Addition Queries II",
      "slug": "shortest-distance-after-road-addition-queries-ii",
      "difficulty": "hard",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Graph"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  3245: {
      "title": "Alternating Groups III",
      "slug": "alternating-groups-iii",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3248: {
      "title": "Snake in Matrix",
      "slug": "snake-in-matrix",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3249: {
      "title": "Count the Number of Good Nodes",
      "slug": "count-the-number-of-good-nodes",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Tree Traversal"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  3250: {
      "title": "Find the Count of Monotonic Pairs I",
      "slug": "find-the-count-of-monotonic-pairs-i",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3251: {
      "title": "Find the Count of Monotonic Pairs II",
      "slug": "find-the-count-of-monotonic-pairs-ii",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3254: {
      "title": "Find the Power of K-Size Subarrays I",
      "slug": "find-the-power-of-k-size-subarrays-i",
      "difficulty": "medium",
      "primaryPattern": "Sliding Window",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Maintain a window of elements that slides through the array. Expand when adding elements, contract when removing. Track window state."
  },
  3255: {
      "title": "Find the Power of K-Size Subarrays II",
      "slug": "find-the-power-of-k-size-subarrays-ii",
      "difficulty": "medium",
      "primaryPattern": "Sliding Window",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Maintain a window of elements that slides through the array. Expand when adding elements, contract when removing. Track window state."
  },
  3256: {
      "title": "Maximum Value Sum by Placing Three Rooks I",
      "slug": "maximum-value-sum-by-placing-three-rooks-i",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "DFS"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3257: {
      "title": "Maximum Value Sum by Placing Three Rooks II",
      "slug": "maximum-value-sum-by-placing-three-rooks-ii",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "DFS"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3258: {
      "title": "Count Substrings That Satisfy K-Constraint I",
      "slug": "count-substrings-that-satisfy-k-constraint-i",
      "difficulty": "easy",
      "primaryPattern": "Sliding Window",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Maintain a window of elements that slides through the array. Expand when adding elements, contract when removing. Track window state."
  },
  3259: {
      "title": "Maximum Energy Boost From Two Drinks",
      "slug": "maximum-energy-boost-from-two-drinks",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3260: {
      "title": "Find the Largest Palindrome Divisible by K",
      "slug": "find-the-largest-palindrome-divisible-by-k",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3261: {
      "title": "Count Substrings That Satisfy K-Constraint II",
      "slug": "count-substrings-that-satisfy-k-constraint-ii",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Sliding Window"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  3264: {
      "title": "Final Array State After K Multiplication Operations I",
      "slug": "final-array-state-after-k-multiplication-operations-i",
      "difficulty": "easy",
      "primaryPattern": "Heap/Priority Queue",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Maintain ordered access to min/max elements. Useful for k-largest/smallest, merging, or scheduling problems."
  },
  3265: {
      "title": "Count Almost Equal Pairs I",
      "slug": "count-almost-equal-pairs-i",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3266: {
      "title": "Final Array State After K Multiplication Operations II",
      "slug": "final-array-state-after-k-multiplication-operations-ii",
      "difficulty": "hard",
      "primaryPattern": "Heap/Priority Queue",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Maintain ordered access to min/max elements. Useful for k-largest/smallest, merging, or scheduling problems."
  },
  3267: {
      "title": "Count Almost Equal Pairs II",
      "slug": "count-almost-equal-pairs-ii",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3270: {
      "title": "Find the Key of the Numbers",
      "slug": "find-the-key-of-the-numbers",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3271: {
      "title": "Hash Divided String",
      "slug": "hash-divided-string",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3272: {
      "title": "Find the Count of Good Integers",
      "slug": "find-the-count-of-good-integers",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3273: {
      "title": "Minimum Amount of Damage Dealt to Bob",
      "slug": "minimum-amount-of-damage-dealt-to-bob",
      "difficulty": "hard",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  3274: {
      "title": "Check if Two Chessboard Squares Have the Same Color",
      "slug": "check-if-two-chessboard-squares-have-the-same-color",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3275: {
      "title": "K-th Nearest Obstacle Queries",
      "slug": "k-th-nearest-obstacle-queries",
      "difficulty": "medium",
      "primaryPattern": "Heap/Priority Queue",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Maintain ordered access to min/max elements. Useful for k-largest/smallest, merging, or scheduling problems."
  },
  3276: {
      "title": "Select Cells in Grid With Maximum Score",
      "slug": "select-cells-in-grid-with-maximum-score",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "DFS"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3277: {
      "title": "Maximum XOR Score Subarray Queries",
      "slug": "maximum-xor-score-subarray-queries",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3280: {
      "title": "Convert Date to Binary",
      "slug": "convert-date-to-binary",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3281: {
      "title": "Maximize Score of Numbers in Ranges",
      "slug": "maximize-score-of-numbers-in-ranges",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy",
          "Two Pointers"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  3282: {
      "title": "Reach End of Array With Max Score",
      "slug": "reach-end-of-array-with-max-score",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  3283: {
      "title": "Maximum Number of Moves to Kill All Pawns",
      "slug": "maximum-number-of-moves-to-kill-all-pawns",
      "difficulty": "hard",
      "primaryPattern": "BFS",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Breadth-first search - explore level by level using a queue. Ideal for shortest path in unweighted graphs or level-order traversal."
  },
  3285: {
      "title": "Find Indices of Stable Mountains",
      "slug": "find-indices-of-stable-mountains",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3286: {
      "title": "Find a Safe Walk Through a Grid",
      "slug": "find-a-safe-walk-through-a-grid",
      "difficulty": "medium",
      "primaryPattern": "BFS",
      "acceptablePatterns": [
          "Hash Map",
          "Graph",
          "Heap/Priority Queue",
          "DFS"
      ],
      "explanation": "Breadth-first search - explore level by level using a queue. Ideal for shortest path in unweighted graphs or level-order traversal."
  },
  3287: {
      "title": "Find the Maximum Sequence Value of Array",
      "slug": "find-the-maximum-sequence-value-of-array",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3288: {
      "title": "Length of the Longest Increasing Path",
      "slug": "length-of-the-longest-increasing-path",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  3289: {
      "title": "The Two Sneaky Numbers of Digitville",
      "slug": "the-two-sneaky-numbers-of-digitville",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3290: {
      "title": "Maximum Multiplication Score",
      "slug": "maximum-multiplication-score",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3291: {
      "title": "Minimum Number of Valid Strings to Form Target I",
      "slug": "minimum-number-of-valid-strings-to-form-target-i",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Dynamic Programming",
          "Trie"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  3292: {
      "title": "Minimum Number of Valid Strings to Form Target II",
      "slug": "minimum-number-of-valid-strings-to-form-target-ii",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Dynamic Programming"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  3295: {
      "title": "Report Spam Message",
      "slug": "report-spam-message",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3296: {
      "title": "Minimum Number of Seconds to Make Mountain Height Zero",
      "slug": "minimum-number-of-seconds-to-make-mountain-height-zero",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy",
          "Heap/Priority Queue"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  3297: {
      "title": "Count Substrings That Can Be Rearranged to Contain a String I",
      "slug": "count-substrings-that-can-be-rearranged-to-contain-a-string-i",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Sliding Window"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3298: {
      "title": "Count Substrings That Can Be Rearranged to Contain a String II",
      "slug": "count-substrings-that-can-be-rearranged-to-contain-a-string-ii",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Sliding Window"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3300: {
      "title": "Minimum Element After Replacement With Digit Sum",
      "slug": "minimum-element-after-replacement-with-digit-sum",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3301: {
      "title": "Maximize the Total Height of Unique Towers",
      "slug": "maximize-the-total-height-of-unique-towers",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  3302: {
      "title": "Find the Lexicographically Smallest Valid Sequence",
      "slug": "find-the-lexicographically-smallest-valid-sequence",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map",
          "Dynamic Programming",
          "Greedy"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  3303: {
      "title": "Find the Occurrence of First Almost Equal Substring",
      "slug": "find-the-occurrence-of-first-almost-equal-substring",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3304: {
      "title": "Find the K-th Character in String Game I",
      "slug": "find-the-k-th-character-in-string-game-i",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "DFS"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3305: {
      "title": "Count of Substrings Containing Every Vowel and K Consonants I",
      "slug": "count-of-substrings-containing-every-vowel-and-k-consonants-i",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Sliding Window"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3306: {
      "title": "Count of Substrings Containing Every Vowel and K Consonants II",
      "slug": "count-of-substrings-containing-every-vowel-and-k-consonants-ii",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Sliding Window"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3307: {
      "title": "Find the K-th Character in String Game II",
      "slug": "find-the-k-th-character-in-string-game-ii",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "DFS"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3309: {
      "title": "Maximum Possible Number by Binary Concatenation",
      "slug": "maximum-possible-number-by-binary-concatenation",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3310: {
      "title": "Remove Methods From Project",
      "slug": "remove-methods-from-project",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "BFS",
          "Graph"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  3311: {
      "title": "Construct 2D Grid Matching Graph Layout",
      "slug": "construct-2d-grid-matching-graph-layout",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Graph",
          "DFS"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3312: {
      "title": "Sorted GCD Pair Queries",
      "slug": "sorted-gcd-pair-queries",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Binary Search"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3314: {
      "title": "Construct the Minimum Bitwise Array I",
      "slug": "construct-the-minimum-bitwise-array-i",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3315: {
      "title": "Construct the Minimum Bitwise Array II",
      "slug": "construct-the-minimum-bitwise-array-ii",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3316: {
      "title": "Find Maximum Removals From Source String",
      "slug": "find-maximum-removals-from-source-string",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Two Pointers",
          "Dynamic Programming"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3317: {
      "title": "Find the Number of Possible Ways for an Event",
      "slug": "find-the-number-of-possible-ways-for-an-event",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3318: {
      "title": "Find X-Sum of All K-Long Subarrays I",
      "slug": "find-x-sum-of-all-k-long-subarrays-i",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Sliding Window",
          "Heap/Priority Queue"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3319: {
      "title": "K-th Largest Perfect Subtree Size in Binary Tree",
      "slug": "k-th-largest-perfect-subtree-size-in-binary-tree",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Tree Traversal",
          "Two Pointers"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  3320: {
      "title": "Count The Number of Winning Sequences",
      "slug": "count-the-number-of-winning-sequences",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3321: {
      "title": "Find X-Sum of All K-Long Subarrays II",
      "slug": "find-x-sum-of-all-k-long-subarrays-ii",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Sliding Window",
          "Heap/Priority Queue"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3324: {
      "title": "Find the Sequence of Strings Appeared on the Screen",
      "slug": "find-the-sequence-of-strings-appeared-on-the-screen",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3325: {
      "title": "Count Substrings With K-Frequency Characters I",
      "slug": "count-substrings-with-k-frequency-characters-i",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Sliding Window"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3326: {
      "title": "Minimum Division Operations to Make Array Non Decreasing",
      "slug": "minimum-division-operations-to-make-array-non-decreasing",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  3327: {
      "title": "Check if DFS Strings Are Palindromes",
      "slug": "check-if-dfs-strings-are-palindromes",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Tree Traversal",
          "DFS"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3330: {
      "title": "Find the Original Typed String I",
      "slug": "find-the-original-typed-string-i",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3331: {
      "title": "Find Subtree Sizes After Changes",
      "slug": "find-subtree-sizes-after-changes",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Tree Traversal",
          "DFS"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3332: {
      "title": "Maximum Points Tourist Can Earn",
      "slug": "maximum-points-tourist-can-earn",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "DFS"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3333: {
      "title": "Find the Original Typed String II",
      "slug": "find-the-original-typed-string-ii",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3334: {
      "title": "Find the Maximum Factor Score of Array",
      "slug": "find-the-maximum-factor-score-of-array",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3335: {
      "title": "Total Characters in String After Transformations I",
      "slug": "total-characters-in-string-after-transformations-i",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Dynamic Programming"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3336: {
      "title": "Find the Number of Subsequences With Equal GCD",
      "slug": "find-the-number-of-subsequences-with-equal-gcd",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3337: {
      "title": "Total Characters in String After Transformations II",
      "slug": "total-characters-in-string-after-transformations-ii",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Dynamic Programming"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3340: {
      "title": "Check Balanced String",
      "slug": "check-balanced-string",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3341: {
      "title": "Find Minimum Time to Reach Last Room I",
      "slug": "find-minimum-time-to-reach-last-room-i",
      "difficulty": "medium",
      "primaryPattern": "Heap/Priority Queue",
      "acceptablePatterns": [
          "Hash Map",
          "Graph",
          "DFS",
          "BFS"
      ],
      "explanation": "Maintain ordered access to min/max elements. Useful for k-largest/smallest, merging, or scheduling problems."
  },
  3342: {
      "title": "Find Minimum Time to Reach Last Room II",
      "slug": "find-minimum-time-to-reach-last-room-ii",
      "difficulty": "medium",
      "primaryPattern": "Heap/Priority Queue",
      "acceptablePatterns": [
          "Hash Map",
          "Graph",
          "DFS",
          "BFS"
      ],
      "explanation": "Maintain ordered access to min/max elements. Useful for k-largest/smallest, merging, or scheduling problems."
  },
  3343: {
      "title": "Count Number of Balanced Permutations",
      "slug": "count-number-of-balanced-permutations",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3345: {
      "title": "Smallest Divisible Digit Product I",
      "slug": "smallest-divisible-digit-product-i",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3346: {
      "title": "Maximum Frequency of an Element After Performing Operations I",
      "slug": "maximum-frequency-of-an-element-after-performing-operations-i",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Sliding Window",
          "Two Pointers"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  3347: {
      "title": "Maximum Frequency of an Element After Performing Operations II",
      "slug": "maximum-frequency-of-an-element-after-performing-operations-ii",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Sliding Window",
          "Two Pointers"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  3348: {
      "title": "Smallest Divisible Digit Product II",
      "slug": "smallest-divisible-digit-product-ii",
      "difficulty": "hard",
      "primaryPattern": "Backtracking",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy"
      ],
      "explanation": "Explore all possible solutions recursively. Build candidates incrementally and abandon paths that cannot lead to solution."
  },
  3349: {
      "title": "Adjacent Increasing Subarrays Detection I",
      "slug": "adjacent-increasing-subarrays-detection-i",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3350: {
      "title": "Adjacent Increasing Subarrays Detection II",
      "slug": "adjacent-increasing-subarrays-detection-ii",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  3351: {
      "title": "Sum of Good Subsequences",
      "slug": "sum-of-good-subsequences",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Dynamic Programming"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3352: {
      "title": "Count K-Reducible Numbers Less Than N",
      "slug": "count-k-reducible-numbers-less-than-n",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3354: {
      "title": "Make Array Elements Equal to Zero",
      "slug": "make-array-elements-equal-to-zero",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3355: {
      "title": "Zero Array Transformation I",
      "slug": "zero-array-transformation-i",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3356: {
      "title": "Zero Array Transformation II",
      "slug": "zero-array-transformation-ii",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  3357: {
      "title": "Minimize the Maximum Adjacent Element Difference",
      "slug": "minimize-the-maximum-adjacent-element-difference",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  3360: {
      "title": "Stone Removal Game",
      "slug": "stone-removal-game",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3361: {
      "title": "Shift Distance Between Two Strings",
      "slug": "shift-distance-between-two-strings",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3362: {
      "title": "Zero Array Transformation III",
      "slug": "zero-array-transformation-iii",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers",
          "Heap/Priority Queue"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  3363: {
      "title": "Find the Maximum Number of Fruits Collected",
      "slug": "find-the-maximum-number-of-fruits-collected",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "DFS"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3364: {
      "title": "Minimum Positive Sum Subarray ",
      "slug": "minimum-positive-sum-subarray",
      "difficulty": "easy",
      "primaryPattern": "Sliding Window",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Maintain a window of elements that slides through the array. Expand when adding elements, contract when removing. Track window state."
  },
  3365: {
      "title": "Rearrange K Substrings to Form Target String",
      "slug": "rearrange-k-substrings-to-form-target-string",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3366: {
      "title": "Minimum Array Sum",
      "slug": "minimum-array-sum",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3367: {
      "title": "Maximize Sum of Weights after Edge Removals",
      "slug": "maximize-sum-of-weights-after-edge-removals",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Tree Traversal",
          "DFS"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3370: {
      "title": "Smallest Number With All Set Bits",
      "slug": "smallest-number-with-all-set-bits",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3371: {
      "title": "Identify the Largest Outlier in an Array",
      "slug": "identify-the-largest-outlier-in-an-array",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3372: {
      "title": "Maximize the Number of Target Nodes After Connecting Trees I",
      "slug": "maximize-the-number-of-target-nodes-after-connecting-trees-i",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Tree Traversal",
          "BFS"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  3373: {
      "title": "Maximize the Number of Target Nodes After Connecting Trees II",
      "slug": "maximize-the-number-of-target-nodes-after-connecting-trees-ii",
      "difficulty": "hard",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Tree Traversal",
          "BFS"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  3374: {
      "title": "First Letter Capitalization II",
      "slug": "first-letter-capitalization-ii",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3375: {
      "title": "Minimum Operations to Make Array Values Equal to K",
      "slug": "minimum-operations-to-make-array-values-equal-to-k",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3376: {
      "title": "Minimum Time to Break Locks I",
      "slug": "minimum-time-to-break-locks-i",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Backtracking",
          "DFS"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3377: {
      "title": "Digit Operations to Make Two Integers Equal",
      "slug": "digit-operations-to-make-two-integers-equal",
      "difficulty": "medium",
      "primaryPattern": "Heap/Priority Queue",
      "acceptablePatterns": [
          "Hash Map",
          "Graph",
          "BFS"
      ],
      "explanation": "Maintain ordered access to min/max elements. Useful for k-largest/smallest, merging, or scheduling problems."
  },
  3378: {
      "title": "Count Connected Components in LCM Graph",
      "slug": "count-connected-components-in-lcm-graph",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Graph"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3379: {
      "title": "Transformed Array",
      "slug": "transformed-array",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3380: {
      "title": "Maximum Area Rectangle With Point Constraints I",
      "slug": "maximum-area-rectangle-with-point-constraints-i",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3381: {
      "title": "Maximum Subarray Sum With Length Divisible by K",
      "slug": "maximum-subarray-sum-with-length-divisible-by-k",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3382: {
      "title": "Maximum Area Rectangle With Point Constraints II",
      "slug": "maximum-area-rectangle-with-point-constraints-ii",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3386: {
      "title": "Button with Longest Push Time",
      "slug": "button-with-longest-push-time",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3387: {
      "title": "Maximize Amount After Two Days of Conversions",
      "slug": "maximize-amount-after-two-days-of-conversions",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map",
          "BFS",
          "Graph"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  3388: {
      "title": "Count Beautiful Splits in an Array",
      "slug": "count-beautiful-splits-in-an-array",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3389: {
      "title": "Minimum Operations to Make Character Frequencies Equal",
      "slug": "minimum-operations-to-make-character-frequencies-equal",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Dynamic Programming"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3392: {
      "title": "Count Subarrays of Length Three With a Condition",
      "slug": "count-subarrays-of-length-three-with-a-condition",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3393: {
      "title": "Count Paths With the Given XOR Value",
      "slug": "count-paths-with-the-given-xor-value",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "DFS"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3394: {
      "title": "Check if Grid can be Cut into Sections",
      "slug": "check-if-grid-can-be-cut-into-sections",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  3395: {
      "title": "Subsequences with a Unique Middle Mode I",
      "slug": "subsequences-with-a-unique-middle-mode-i",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3396: {
      "title": "Minimum Number of Operations to Make Elements in Array Distinct",
      "slug": "minimum-number-of-operations-to-make-elements-in-array-distinct",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3397: {
      "title": "Maximum Number of Distinct Elements After Operations",
      "slug": "maximum-number-of-distinct-elements-after-operations",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  3398: {
      "title": "Smallest Substring With Identical Characters I",
      "slug": "smallest-substring-with-identical-characters-i",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  3399: {
      "title": "Smallest Substring With Identical Characters II",
      "slug": "smallest-substring-with-identical-characters-ii",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  3402: {
      "title": "Minimum Operations to Make Columns Strictly Increasing",
      "slug": "minimum-operations-to-make-columns-strictly-increasing",
      "difficulty": "easy",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "DFS"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  3403: {
      "title": "Find the Lexicographically Largest String From the Box I",
      "slug": "find-the-lexicographically-largest-string-from-the-box-i",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  3404: {
      "title": "Count Special Subsequences",
      "slug": "count-special-subsequences",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3405: {
      "title": "Count the Number of Arrays with K Matching Adjacent Elements",
      "slug": "count-the-number-of-arrays-with-k-matching-adjacent-elements",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3407: {
      "title": "Substring Matching Pattern",
      "slug": "substring-matching-pattern",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3408: {
      "title": "Design Task Manager",
      "slug": "design-task-manager",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Heap/Priority Queue"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3409: {
      "title": "Longest Subsequence With Decreasing Adjacent Difference",
      "slug": "longest-subsequence-with-decreasing-adjacent-difference",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3410: {
      "title": "Maximize Subarray Sum After Removing All Occurrences of One Element",
      "slug": "maximize-subarray-sum-after-removing-all-occurrences-of-one-element",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3411: {
      "title": "Maximum Subarray With Equal Products",
      "slug": "maximum-subarray-with-equal-products",
      "difficulty": "easy",
      "primaryPattern": "Sliding Window",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Maintain a window of elements that slides through the array. Expand when adding elements, contract when removing. Track window state."
  },
  3412: {
      "title": "Find Mirror Score of a String",
      "slug": "find-mirror-score-of-a-string",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Stack"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3413: {
      "title": "Maximum Coins From K Consecutive Bags",
      "slug": "maximum-coins-from-k-consecutive-bags",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy",
          "Sliding Window",
          "Two Pointers"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  3414: {
      "title": "Maximum Score of Non-overlapping Intervals",
      "slug": "maximum-score-of-non-overlapping-intervals",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Dynamic Programming",
          "Two Pointers"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  3417: {
      "title": "Zigzag Grid Traversal With Skip",
      "slug": "zigzag-grid-traversal-with-skip",
      "difficulty": "easy",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  3418: {
      "title": "Maximum Amount of Money Robot Can Earn",
      "slug": "maximum-amount-of-money-robot-can-earn",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "DFS"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3419: {
      "title": "Minimize the Maximum Edge Weight of Graph",
      "slug": "minimize-the-maximum-edge-weight-of-graph",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "DFS",
          "BFS",
          "Graph"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  3420: {
      "title": "Count Non-Decreasing Subarrays After K Operations",
      "slug": "count-non-decreasing-subarrays-after-k-operations",
      "difficulty": "hard",
      "primaryPattern": "Stack",
      "acceptablePatterns": [
          "Hash Map",
          "BFS",
          "Sliding Window"
      ],
      "explanation": "LIFO structure for nested patterns, matching pairs, or maintaining monotonic sequences."
  },
  3421: {
      "title": "Find Students Who Improved",
      "slug": "find-students-who-improved",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3423: {
      "title": "Maximum Difference Between Adjacent Elements in a Circular Array",
      "slug": "maximum-difference-between-adjacent-elements-in-a-circular-array",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3424: {
      "title": "Minimum Cost to Make Arrays Identical",
      "slug": "minimum-cost-to-make-arrays-identical",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  3425: {
      "title": "Longest Special Path",
      "slug": "longest-special-path",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Tree Traversal",
          "DFS"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3426: {
      "title": "Manhattan Distances of All Arrangements of Pieces",
      "slug": "manhattan-distances-of-all-arrangements-of-pieces",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3427: {
      "title": "Sum of Variable Length Subarrays",
      "slug": "sum-of-variable-length-subarrays",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3428: {
      "title": "Maximum and Minimum Sums of at Most Size K Subsequences",
      "slug": "maximum-and-minimum-sums-of-at-most-size-k-subsequences",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3429: {
      "title": "Paint House IV",
      "slug": "paint-house-iv",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3430: {
      "title": "Maximum and Minimum Sums of at Most Size K Subarrays",
      "slug": "maximum-and-minimum-sums-of-at-most-size-k-subarrays",
      "difficulty": "hard",
      "primaryPattern": "Stack",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "LIFO structure for nested patterns, matching pairs, or maintaining monotonic sequences."
  },
  3432: {
      "title": "Count Partitions with Even Sum Difference",
      "slug": "count-partitions-with-even-sum-difference",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3433: {
      "title": "Count Mentions Per User",
      "slug": "count-mentions-per-user",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  3434: {
      "title": "Maximum Frequency After Subarray Operation",
      "slug": "maximum-frequency-after-subarray-operation",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Dynamic Programming",
          "Greedy"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3435: {
      "title": "Frequencies of Shortest Supersequences",
      "slug": "frequencies-of-shortest-supersequences",
      "difficulty": "hard",
      "primaryPattern": "Graph",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Graph algorithms - may involve topological sort, cycle detection, union find, or connectivity checks."
  },
  3436: {
      "title": "Find Valid Emails",
      "slug": "find-valid-emails",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3438: {
      "title": "Find Valid Pair of Adjacent Digits in String",
      "slug": "find-valid-pair-of-adjacent-digits-in-string",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3439: {
      "title": "Reschedule Meetings for Maximum Free Time I",
      "slug": "reschedule-meetings-for-maximum-free-time-i",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Sliding Window"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  3440: {
      "title": "Reschedule Meetings for Maximum Free Time II",
      "slug": "reschedule-meetings-for-maximum-free-time-ii",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  3441: {
      "title": "Minimum Cost Good Caption",
      "slug": "minimum-cost-good-caption",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3442: {
      "title": "Maximum Difference Between Even and Odd Frequency I",
      "slug": "maximum-difference-between-even-and-odd-frequency-i",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3443: {
      "title": "Maximum Manhattan Distance After K Changes",
      "slug": "maximum-manhattan-distance-after-k-changes",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3444: {
      "title": "Minimum Increments for Target Multiples in an Array",
      "slug": "minimum-increments-for-target-multiples-in-an-array",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3445: {
      "title": "Maximum Difference Between Even and Odd Frequency II",
      "slug": "maximum-difference-between-even-and-odd-frequency-ii",
      "difficulty": "hard",
      "primaryPattern": "Sliding Window",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Maintain a window of elements that slides through the array. Expand when adding elements, contract when removing. Track window state."
  },
  3446: {
      "title": "Sort Matrix by Diagonals",
      "slug": "sort-matrix-by-diagonals",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map",
          "DFS"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  3447: {
      "title": "Assign Elements to Groups with Constraints",
      "slug": "assign-elements-to-groups-with-constraints",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3448: {
      "title": "Count Substrings Divisible By Last Digit",
      "slug": "count-substrings-divisible-by-last-digit",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3449: {
      "title": "Maximize the Minimum Game Score",
      "slug": "maximize-the-minimum-game-score",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  3451: {
      "title": "Find Invalid IP Addresses",
      "slug": "find-invalid-ip-addresses",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3452: {
      "title": "Sum of Good Numbers",
      "slug": "sum-of-good-numbers",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3453: {
      "title": "Separate Squares I",
      "slug": "separate-squares-i",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  3454: {
      "title": "Separate Squares II",
      "slug": "separate-squares-ii",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  3455: {
      "title": "Shortest Matching Substring",
      "slug": "shortest-matching-substring",
      "difficulty": "hard",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map",
          "Binary Search"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  3456: {
      "title": "Find Special Substring of Length K",
      "slug": "find-special-substring-of-length-k",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3457: {
      "title": "Eat Pizzas!",
      "slug": "eat-pizzas",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  3458: {
      "title": "Select K Disjoint Special Substrings",
      "slug": "select-k-disjoint-special-substrings",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Dynamic Programming",
          "Greedy",
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3459: {
      "title": "Length of Longest V-Shaped Diagonal Segment",
      "slug": "length-of-longest-v-shaped-diagonal-segment",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "DFS"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3461: {
      "title": "Check If Digits Are Equal in String After Operations I",
      "slug": "check-if-digits-are-equal-in-string-after-operations-i",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3462: {
      "title": "Maximum Sum With at Most K Elements",
      "slug": "maximum-sum-with-at-most-k-elements",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers",
          "Heap/Priority Queue",
          "DFS"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  3463: {
      "title": "Check If Digits Are Equal in String After Operations II",
      "slug": "check-if-digits-are-equal-in-string-after-operations-ii",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3464: {
      "title": "Maximize the Distance Between Points on a Square",
      "slug": "maximize-the-distance-between-points-on-a-square",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  3465: {
      "title": "Find Products with Valid Serial Numbers",
      "slug": "find-products-with-valid-serial-numbers",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3467: {
      "title": "Transform Array by Parity",
      "slug": "transform-array-by-parity",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3468: {
      "title": "Find the Number of Copy Arrays",
      "slug": "find-the-number-of-copy-arrays",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3469: {
      "title": "Find Minimum Cost to Remove Array Elements",
      "slug": "find-minimum-cost-to-remove-array-elements",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3470: {
      "title": "Permutations IV",
      "slug": "permutations-iv",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3471: {
      "title": "Find the Largest Almost Missing Integer",
      "slug": "find-the-largest-almost-missing-integer",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3472: {
      "title": "Longest Palindromic Subsequence After at Most K Operations",
      "slug": "longest-palindromic-subsequence-after-at-most-k-operations",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3473: {
      "title": "Sum of K Subarrays With Length at Least M",
      "slug": "sum-of-k-subarrays-with-length-at-least-m",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3474: {
      "title": "Lexicographically Smallest Generated String",
      "slug": "lexicographically-smallest-generated-string",
      "difficulty": "hard",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  3475: {
      "title": "DNA Pattern Recognition ",
      "slug": "dna-pattern-recognition",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3477: {
      "title": "Fruits Into Baskets II",
      "slug": "fruits-into-baskets-ii",
      "difficulty": "easy",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  3478: {
      "title": "Choose K Elements With Maximum Sum",
      "slug": "choose-k-elements-with-maximum-sum",
      "difficulty": "medium",
      "primaryPattern": "Heap/Priority Queue",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Maintain ordered access to min/max elements. Useful for k-largest/smallest, merging, or scheduling problems."
  },
  3479: {
      "title": "Fruits Into Baskets III",
      "slug": "fruits-into-baskets-iii",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  3480: {
      "title": "Maximize Subarrays After Removing One Conflicting Pair",
      "slug": "maximize-subarrays-after-removing-one-conflicting-pair",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3482: {
      "title": "Analyze Organization Hierarchy",
      "slug": "analyze-organization-hierarchy",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3483: {
      "title": "Unique 3-Digit Even Numbers",
      "slug": "unique-3-digit-even-numbers",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "DFS"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3484: {
      "title": "Design Spreadsheet",
      "slug": "design-spreadsheet",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "DFS"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3485: {
      "title": "Longest Common Prefix of K Strings After Removal",
      "slug": "longest-common-prefix-of-k-strings-after-removal",
      "difficulty": "hard",
      "primaryPattern": "Trie",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Prefix tree for efficient string operations. Each node represents a character, paths represent strings."
  },
  3486: {
      "title": "Longest Special Path II",
      "slug": "longest-special-path-ii",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Tree Traversal",
          "DFS"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3487: {
      "title": "Maximum Unique Subarray Sum After Deletion",
      "slug": "maximum-unique-subarray-sum-after-deletion",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Greedy"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3488: {
      "title": "Closest Equal Element Queries",
      "slug": "closest-equal-element-queries",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Binary Search"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3489: {
      "title": "Zero Array Transformation IV",
      "slug": "zero-array-transformation-iv",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3490: {
      "title": "Count Beautiful Numbers",
      "slug": "count-beautiful-numbers",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3492: {
      "title": "Maximum Containers on a Ship",
      "slug": "maximum-containers-on-a-ship",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3493: {
      "title": "Properties Graph",
      "slug": "properties-graph",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "DFS",
          "BFS",
          "Graph"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3494: {
      "title": "Find the Minimum Amount of Time to Brew Potions",
      "slug": "find-the-minimum-amount-of-time-to-brew-potions",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3495: {
      "title": "Minimum Operations to Make Array Elements Zero",
      "slug": "minimum-operations-to-make-array-elements-zero",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3497: {
      "title": "Analyze Subscription Conversion ",
      "slug": "analyze-subscription-conversion",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3498: {
      "title": "Reverse Degree of a String",
      "slug": "reverse-degree-of-a-string",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3499: {
      "title": "Maximize Active Section with Trade I",
      "slug": "maximize-active-section-with-trade-i",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3500: {
      "title": "Minimum Cost to Divide Array Into Subarrays",
      "slug": "minimum-cost-to-divide-array-into-subarrays",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3501: {
      "title": "Maximize Active Section with Trade II",
      "slug": "maximize-active-section-with-trade-ii",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  3502: {
      "title": "Minimum Cost to Reach Every Position",
      "slug": "minimum-cost-to-reach-every-position",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3503: {
      "title": "Longest Palindrome After Substring Concatenation I",
      "slug": "longest-palindrome-after-substring-concatenation-i",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map",
          "Dynamic Programming"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  3504: {
      "title": "Longest Palindrome After Substring Concatenation II",
      "slug": "longest-palindrome-after-substring-concatenation-ii",
      "difficulty": "hard",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map",
          "Dynamic Programming"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  3505: {
      "title": "Minimum Operations to Make Elements Within K Subarrays Equal",
      "slug": "minimum-operations-to-make-elements-within-k-subarrays-equal",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Dynamic Programming",
          "Sliding Window",
          "Heap/Priority Queue"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3507: {
      "title": "Minimum Pair Removal to Sort Array I",
      "slug": "minimum-pair-removal-to-sort-array-i",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Linked List",
          "Heap/Priority Queue"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3508: {
      "title": "Implement Router",
      "slug": "implement-router",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Binary Search",
          "BFS"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3509: {
      "title": "Maximum Product of Subsequences With an Alternating Sum Equal to K",
      "slug": "maximum-product-of-subsequences-with-an-alternating-sum-equal-to-k",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Dynamic Programming"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3510: {
      "title": "Minimum Pair Removal to Sort Array II",
      "slug": "minimum-pair-removal-to-sort-array-ii",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Linked List",
          "Heap/Priority Queue"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3512: {
      "title": "Minimum Operations to Make Array Sum Divisible by K",
      "slug": "minimum-operations-to-make-array-sum-divisible-by-k",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3513: {
      "title": "Number of Unique XOR Triplets I",
      "slug": "number-of-unique-xor-triplets-i",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3514: {
      "title": "Number of Unique XOR Triplets II",
      "slug": "number-of-unique-xor-triplets-ii",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3515: {
      "title": "Shortest Path in a Weighted Tree",
      "slug": "shortest-path-in-a-weighted-tree",
      "difficulty": "hard",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map",
          "Tree Traversal"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  3516: {
      "title": "Find Closest Person",
      "slug": "find-closest-person",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3517: {
      "title": "Smallest Palindromic Rearrangement I",
      "slug": "smallest-palindromic-rearrangement-i",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  3518: {
      "title": "Smallest Palindromic Rearrangement II",
      "slug": "smallest-palindromic-rearrangement-ii",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3519: {
      "title": "Count Numbers with Non-Decreasing Digits ",
      "slug": "count-numbers-with-non-decreasing-digits",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3521: {
      "title": "Find Product Recommendation Pairs",
      "slug": "find-product-recommendation-pairs",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3522: {
      "title": "Calculate Score After Performing Instructions",
      "slug": "calculate-score-after-performing-instructions",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3523: {
      "title": "Make Array Non-decreasing",
      "slug": "make-array-non-decreasing",
      "difficulty": "medium",
      "primaryPattern": "Stack",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy"
      ],
      "explanation": "LIFO structure for nested patterns, matching pairs, or maintaining monotonic sequences."
  },
  3524: {
      "title": "Find X Value of Array I",
      "slug": "find-x-value-of-array-i",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3525: {
      "title": "Find X Value of Array II",
      "slug": "find-x-value-of-array-ii",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3527: {
      "title": "Find the Most Common Response",
      "slug": "find-the-most-common-response",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3528: {
      "title": "Unit Conversion I",
      "slug": "unit-conversion-i",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "BFS",
          "Graph"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  3529: {
      "title": "Count Cells in Overlapping Horizontal and Vertical Substrings",
      "slug": "count-cells-in-overlapping-horizontal-and-vertical-substrings",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  3530: {
      "title": "Maximum Profit from Valid Topological Order in DAG",
      "slug": "maximum-profit-from-valid-topological-order-in-dag",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Graph"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3531: {
      "title": "Count Covered Buildings",
      "slug": "count-covered-buildings",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3532: {
      "title": "Path Existence Queries in a Graph I",
      "slug": "path-existence-queries-in-a-graph-i",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Binary Search",
          "Graph"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3533: {
      "title": "Concatenated Divisibility",
      "slug": "concatenated-divisibility",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3534: {
      "title": "Path Existence Queries in a Graph II",
      "slug": "path-existence-queries-in-a-graph-ii",
      "difficulty": "hard",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map",
          "Binary Search",
          "Dynamic Programming",
          "Greedy",
          "Graph"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  3536: {
      "title": "Maximum Product of Two Digits",
      "slug": "maximum-product-of-two-digits",
      "difficulty": "easy",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  3537: {
      "title": "Fill a Special Grid",
      "slug": "fill-a-special-grid",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "DFS"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  3538: {
      "title": "Merge Operations for Minimum Travel Time",
      "slug": "merge-operations-for-minimum-travel-time",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3539: {
      "title": "Find Sum of Array Product of Magical Sequences",
      "slug": "find-sum-of-array-product-of-magical-sequences",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3541: {
      "title": "Find Most Frequent Vowel and Consonant",
      "slug": "find-most-frequent-vowel-and-consonant",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3542: {
      "title": "Minimum Operations to Convert All Elements to Zero",
      "slug": "minimum-operations-to-convert-all-elements-to-zero",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Stack",
          "Greedy"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3543: {
      "title": "Maximum Weighted K-Edge Path",
      "slug": "maximum-weighted-k-edge-path",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Dynamic Programming",
          "Graph"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3544: {
      "title": "Subtree Inversion Sum",
      "slug": "subtree-inversion-sum",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Tree Traversal",
          "DFS"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3545: {
      "title": "Minimum Deletions for At Most K Distinct Characters",
      "slug": "minimum-deletions-for-at-most-k-distinct-characters",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Greedy",
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3546: {
      "title": "Equal Sum Grid Partition I",
      "slug": "equal-sum-grid-partition-i",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "DFS"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3547: {
      "title": "Maximum Sum of Edge Values in a Graph",
      "slug": "maximum-sum-of-edge-values-in-a-graph",
      "difficulty": "hard",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Graph"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  3548: {
      "title": "Equal Sum Grid Partition II",
      "slug": "equal-sum-grid-partition-ii",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "DFS"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3550: {
      "title": "Smallest Index With Digit Sum Equal to Index",
      "slug": "smallest-index-with-digit-sum-equal-to-index",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3551: {
      "title": "Minimum Swaps to Sort by Digit Sum",
      "slug": "minimum-swaps-to-sort-by-digit-sum",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3552: {
      "title": "Grid Teleportation Traversal",
      "slug": "grid-teleportation-traversal",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "BFS",
          "DFS"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3553: {
      "title": "Minimum Weighted Subgraph With the Required Paths II",
      "slug": "minimum-weighted-subgraph-with-the-required-paths-ii",
      "difficulty": "hard",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map",
          "Tree Traversal"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  3554: {
      "title": "Find Category Recommendation Pairs",
      "slug": "find-category-recommendation-pairs",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3556: {
      "title": "Sum of Largest Prime Substrings",
      "slug": "sum-of-largest-prime-substrings",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3557: {
      "title": "Find Maximum Number of Non Intersecting Substrings",
      "slug": "find-maximum-number-of-non-intersecting-substrings",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Dynamic Programming",
          "Greedy"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3558: {
      "title": "Number of Ways to Assign Edge Weights I",
      "slug": "number-of-ways-to-assign-edge-weights-i",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map",
          "Tree Traversal"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  3559: {
      "title": "Number of Ways to Assign Edge Weights II",
      "slug": "number-of-ways-to-assign-edge-weights-ii",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Tree Traversal",
          "DFS"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3560: {
      "title": "Find Minimum Log Transportation Cost",
      "slug": "find-minimum-log-transportation-cost",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3561: {
      "title": "Resulting String After Adjacent Removals",
      "slug": "resulting-string-after-adjacent-removals",
      "difficulty": "medium",
      "primaryPattern": "Stack",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "LIFO structure for nested patterns, matching pairs, or maintaining monotonic sequences."
  },
  3562: {
      "title": "Maximum Profit from Trading Stocks with Discounts",
      "slug": "maximum-profit-from-trading-stocks-with-discounts",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Tree Traversal",
          "DFS"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3563: {
      "title": "Lexicographically Smallest String After Adjacent Removals",
      "slug": "lexicographically-smallest-string-after-adjacent-removals",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3564: {
      "title": "Seasonal Sales Analysis",
      "slug": "seasonal-sales-analysis",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3566: {
      "title": "Partition Array into Two Equal Product Subsets",
      "slug": "partition-array-into-two-equal-product-subsets",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "DFS"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3567: {
      "title": "Minimum Absolute Difference in Sliding Submatrix",
      "slug": "minimum-absolute-difference-in-sliding-submatrix",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map",
          "DFS"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  3568: {
      "title": "Minimum Moves to Clean the Classroom",
      "slug": "minimum-moves-to-clean-the-classroom",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "BFS",
          "DFS"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3569: {
      "title": "Maximize Count of Distinct Primes After Split",
      "slug": "maximize-count-of-distinct-primes-after-split",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3570: {
      "title": "Find Books with No Available Copies",
      "slug": "find-books-with-no-available-copies",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3572: {
      "title": "Maximize Y‑Sum by Picking a Triplet of Distinct X‑Values",
      "slug": "maximize-ysum-by-picking-a-triplet-of-distinct-xvalues",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Greedy",
          "Two Pointers",
          "Heap/Priority Queue"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3573: {
      "title": "Best Time to Buy and Sell Stock V",
      "slug": "best-time-to-buy-and-sell-stock-v",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3574: {
      "title": "Maximize Subarray GCD Score",
      "slug": "maximize-subarray-gcd-score",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3575: {
      "title": "Maximum Good Subtree Score",
      "slug": "maximum-good-subtree-score",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Tree Traversal",
          "DFS"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3576: {
      "title": "Transform Array to All Equal Elements",
      "slug": "transform-array-to-all-equal-elements",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  3577: {
      "title": "Count the Number of Computer Unlocking Permutations",
      "slug": "count-the-number-of-computer-unlocking-permutations",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3578: {
      "title": "Count Partitions With Max-Min Difference at Most K",
      "slug": "count-partitions-with-max-min-difference-at-most-k",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "BFS",
          "Sliding Window"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3579: {
      "title": "Minimum Steps to Convert String with Operations",
      "slug": "minimum-steps-to-convert-string-with-operations",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3580: {
      "title": "Find Consistently Improving Employees",
      "slug": "find-consistently-improving-employees",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3582: {
      "title": "Generate Tag for Video Caption",
      "slug": "generate-tag-for-video-caption",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3583: {
      "title": "Count Special Triplets",
      "slug": "count-special-triplets",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3584: {
      "title": "Maximum Product of First and Last Elements of a Subsequence",
      "slug": "maximum-product-of-first-and-last-elements-of-a-subsequence",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  3585: {
      "title": "Find Weighted Median Node in Tree",
      "slug": "find-weighted-median-node-in-tree",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Dynamic Programming",
          "Tree Traversal",
          "DFS"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  3586: {
      "title": "Find COVID Recovery Patients",
      "slug": "find-covid-recovery-patients",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3587: {
      "title": "Minimum Adjacent Swaps to Alternate Parity",
      "slug": "minimum-adjacent-swaps-to-alternate-parity",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  3588: {
      "title": "Find Maximum Area of a Triangle",
      "slug": "find-maximum-area-of-a-triangle",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Greedy"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3589: {
      "title": "Count Prime-Gap Balanced Subarrays",
      "slug": "count-prime-gap-balanced-subarrays",
      "difficulty": "medium",
      "primaryPattern": "Sliding Window",
      "acceptablePatterns": [
          "Hash Map",
          "BFS"
      ],
      "explanation": "Maintain a window of elements that slides through the array. Expand when adding elements, contract when removing. Track window state."
  },
  3590: {
      "title": "Kth Smallest Path XOR Sum",
      "slug": "kth-smallest-path-xor-sum",
      "difficulty": "hard",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map",
          "Tree Traversal"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  3591: {
      "title": "Check if Any Element Has Prime Frequency",
      "slug": "check-if-any-element-has-prime-frequency",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3592: {
      "title": "Inverse Coin Change",
      "slug": "inverse-coin-change",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3593: {
      "title": "Minimum Increments to Equalize Leaf Paths",
      "slug": "minimum-increments-to-equalize-leaf-paths",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Tree Traversal",
          "DFS"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3594: {
      "title": "Minimum Time to Transport All Individuals",
      "slug": "minimum-time-to-transport-all-individuals",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Graph",
          "Heap/Priority Queue",
          "BFS"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3597: {
      "title": "Partition String ",
      "slug": "partition-string",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Trie"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3598: {
      "title": "Longest Common Prefix Between Adjacent Strings After Removals",
      "slug": "longest-common-prefix-between-adjacent-strings-after-removals",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3599: {
      "title": "Partition Array to Minimize XOR",
      "slug": "partition-array-to-minimize-xor",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3600: {
      "title": "Maximize Spanning Tree Stability with Upgrades",
      "slug": "maximize-spanning-tree-stability-with-upgrades",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Greedy",
          "Graph"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  3601: {
      "title": "Find Drivers with Improved Fuel Efficiency",
      "slug": "find-drivers-with-improved-fuel-efficiency",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3602: {
      "title": "Hexadecimal and Hexatrigesimal Conversion",
      "slug": "hexadecimal-and-hexatrigesimal-conversion",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3603: {
      "title": "Minimum Cost Path with Alternating Directions II",
      "slug": "minimum-cost-path-with-alternating-directions-ii",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "DFS"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3604: {
      "title": "Minimum Time to Reach Destination in Directed Graph",
      "slug": "minimum-time-to-reach-destination-in-directed-graph",
      "difficulty": "medium",
      "primaryPattern": "Heap/Priority Queue",
      "acceptablePatterns": [
          "Graph",
          "BFS"
      ],
      "explanation": "Maintain ordered access to min/max elements. Useful for k-largest/smallest, merging, or scheduling problems."
  },
  3605: {
      "title": "Minimum Stability Factor of Array",
      "slug": "minimum-stability-factor-of-array",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  3606: {
      "title": "Coupon Code Validator",
      "slug": "coupon-code-validator",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3607: {
      "title": "Power Grid Maintenance",
      "slug": "power-grid-maintenance",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "DFS",
          "BFS",
          "Graph",
          "Heap/Priority Queue"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3608: {
      "title": "Minimum Time for K Connected Components",
      "slug": "minimum-time-for-k-connected-components",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Graph",
          "Two Pointers"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  3609: {
      "title": "Minimum Moves to Reach Target in Grid",
      "slug": "minimum-moves-to-reach-target-in-grid",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3611: {
      "title": "Find Overbooked Employees",
      "slug": "find-overbooked-employees",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3612: {
      "title": "Process String with Special Operations I",
      "slug": "process-string-with-special-operations-i",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3613: {
      "title": "Minimize Maximum Component Cost",
      "slug": "minimize-maximum-component-cost",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Graph",
          "Two Pointers"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  3614: {
      "title": "Process String with Special Operations II",
      "slug": "process-string-with-special-operations-ii",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3615: {
      "title": "Longest Palindromic Path in Graph",
      "slug": "longest-palindromic-path-in-graph",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Graph"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3617: {
      "title": "Find Students with Study Spiral Pattern",
      "slug": "find-students-with-study-spiral-pattern",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3618: {
      "title": "Split Array by Prime Indices",
      "slug": "split-array-by-prime-indices",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3619: {
      "title": "Count Islands With Total Value Divisible by K",
      "slug": "count-islands-with-total-value-divisible-by-k",
      "difficulty": "medium",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map",
          "BFS",
          "Graph"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  3620: {
      "title": "Network Recovery Pathways",
      "slug": "network-recovery-pathways",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Dynamic Programming",
          "Graph",
          "Heap/Priority Queue",
          "BFS"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  3621: {
      "title": "Number of Integers With Popcount-Depth Equal to K I",
      "slug": "number-of-integers-with-popcount-depth-equal-to-k-i",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3622: {
      "title": "Check Divisibility by Digit Sum and Product",
      "slug": "check-divisibility-by-digit-sum-and-product",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3623: {
      "title": "Count Number of Trapezoids I",
      "slug": "count-number-of-trapezoids-i",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3624: {
      "title": "Number of Integers With Popcount-Depth Equal to K II",
      "slug": "number-of-integers-with-popcount-depth-equal-to-k-ii",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  3625: {
      "title": "Count Number of Trapezoids II",
      "slug": "count-number-of-trapezoids-ii",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3626: {
      "title": "Find Stores with Inventory Imbalance",
      "slug": "find-stores-with-inventory-imbalance",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3627: {
      "title": "Maximum Median Sum of Subsequences of Size 3",
      "slug": "maximum-median-sum-of-subsequences-of-size-3",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  3628: {
      "title": "Maximum Number of Subsequences After One Inserting",
      "slug": "maximum-number-of-subsequences-after-one-inserting",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3629: {
      "title": "Minimum Jumps to Reach End via Prime Teleportation",
      "slug": "minimum-jumps-to-reach-end-via-prime-teleportation",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "BFS"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3630: {
      "title": "Partition Array for Maximum XOR and AND",
      "slug": "partition-array-for-maximum-xor-and-and",
      "difficulty": "hard",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  3633: {
      "title": "Earliest Finish Time for Land and Water Rides I",
      "slug": "earliest-finish-time-for-land-and-water-rides-i",
      "difficulty": "easy",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map",
          "Binary Search",
          "Greedy"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  3634: {
      "title": "Minimum Removals to Balance Array",
      "slug": "minimum-removals-to-balance-array",
      "difficulty": "medium",
      "primaryPattern": "Sliding Window",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Maintain a window of elements that slides through the array. Expand when adding elements, contract when removing. Track window state."
  },
  3635: {
      "title": "Earliest Finish Time for Land and Water Rides II",
      "slug": "earliest-finish-time-for-land-and-water-rides-ii",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map",
          "Binary Search",
          "Greedy"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  3636: {
      "title": "Threshold Majority Queries",
      "slug": "threshold-majority-queries",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Binary Search"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3637: {
      "title": "Trionic Array I",
      "slug": "trionic-array-i",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3638: {
      "title": "Maximum Balanced Shipments",
      "slug": "maximum-balanced-shipments",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Stack",
          "Greedy"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3639: {
      "title": "Minimum Time to Activate String",
      "slug": "minimum-time-to-activate-string",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  3640: {
      "title": "Trionic Array II",
      "slug": "trionic-array-ii",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3642: {
      "title": "Find Books with Polarized Opinions",
      "slug": "find-books-with-polarized-opinions",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3643: {
      "title": "Flip Square Submatrix Vertically",
      "slug": "flip-square-submatrix-vertically",
      "difficulty": "easy",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map",
          "DFS"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  3644: {
      "title": "Maximum K to Sort a Permutation",
      "slug": "maximum-k-to-sort-a-permutation",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3645: {
      "title": "Maximum Total from Optimal Activation Order",
      "slug": "maximum-total-from-optimal-activation-order",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy",
          "Heap/Priority Queue"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  3646: {
      "title": "Next Special Palindrome Number",
      "slug": "next-special-palindrome-number",
      "difficulty": "hard",
      "primaryPattern": "Backtracking",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Explore all possible solutions recursively. Build candidates incrementally and abandon paths that cannot lead to solution."
  },
  3648: {
      "title": "Minimum Sensors to Cover Grid",
      "slug": "minimum-sensors-to-cover-grid",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3649: {
      "title": "Number of Perfect Pairs",
      "slug": "number-of-perfect-pairs",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  3650: {
      "title": "Minimum Cost Path with Edge Reversals",
      "slug": "minimum-cost-path-with-edge-reversals",
      "difficulty": "medium",
      "primaryPattern": "Heap/Priority Queue",
      "acceptablePatterns": [
          "Graph",
          "BFS"
      ],
      "explanation": "Maintain ordered access to min/max elements. Useful for k-largest/smallest, merging, or scheduling problems."
  },
  3651: {
      "title": "Minimum Cost Path with Teleportations",
      "slug": "minimum-cost-path-with-teleportations",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "DFS"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3652: {
      "title": "Best Time to Buy and Sell Stock using Strategy",
      "slug": "best-time-to-buy-and-sell-stock-using-strategy",
      "difficulty": "medium",
      "primaryPattern": "Sliding Window",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Maintain a window of elements that slides through the array. Expand when adding elements, contract when removing. Track window state."
  },
  3653: {
      "title": "XOR After Range Multiplication Queries I",
      "slug": "xor-after-range-multiplication-queries-i",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  3654: {
      "title": "Minimum Sum After Divisible Sum Deletions",
      "slug": "minimum-sum-after-divisible-sum-deletions",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Dynamic Programming"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3655: {
      "title": "XOR After Range Multiplication Queries II",
      "slug": "xor-after-range-multiplication-queries-ii",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  3657: {
      "title": "Find Loyal Customers",
      "slug": "find-loyal-customers",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3658: {
      "title": "GCD of Odd and Even Sums",
      "slug": "gcd-of-odd-and-even-sums",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3659: {
      "title": "Partition Array Into K-Distinct Groups",
      "slug": "partition-array-into-k-distinct-groups",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3660: {
      "title": "Jump Game IX",
      "slug": "jump-game-ix",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3661: {
      "title": "Maximum Walls Destroyed by Robots",
      "slug": "maximum-walls-destroyed-by-robots",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Dynamic Programming",
          "Two Pointers"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  3663: {
      "title": "Find The Least Frequent Digit",
      "slug": "find-the-least-frequent-digit",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3664: {
      "title": "Two-Letter Card Game",
      "slug": "two-letter-card-game",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3665: {
      "title": "Twisted Mirror Path Count",
      "slug": "twisted-mirror-path-count",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "DFS"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3666: {
      "title": "Minimum Operations to Equalize Binary String",
      "slug": "minimum-operations-to-equalize-binary-string",
      "difficulty": "hard",
      "primaryPattern": "BFS",
      "acceptablePatterns": [
          "Hash Map",
          "Graph"
      ],
      "explanation": "Breadth-first search - explore level by level using a queue. Ideal for shortest path in unweighted graphs or level-order traversal."
  },
  3668: {
      "title": "Restore Finishing Order",
      "slug": "restore-finishing-order",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3669: {
      "title": "Balanced K-Factor Decomposition",
      "slug": "balanced-k-factor-decomposition",
      "difficulty": "medium",
      "primaryPattern": "Backtracking",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Explore all possible solutions recursively. Build candidates incrementally and abandon paths that cannot lead to solution."
  },
  3670: {
      "title": "Maximum Product of Two Integers With No Common Bits",
      "slug": "maximum-product-of-two-integers-with-no-common-bits",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3671: {
      "title": "Sum of Beautiful Subsequences",
      "slug": "sum-of-beautiful-subsequences",
      "difficulty": "hard",
      "primaryPattern": "Tree Traversal",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Navigate tree structures using inorder, preorder, or postorder traversal. Consider recursive or iterative approaches."
  },
  3673: {
      "title": "Find Zombie Sessions",
      "slug": "find-zombie-sessions",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3674: {
      "title": "Minimum Operations to Equalize Array",
      "slug": "minimum-operations-to-equalize-array",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3675: {
      "title": "Minimum Operations to Transform String",
      "slug": "minimum-operations-to-transform-string",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  3676: {
      "title": "Count Bowl Subarrays",
      "slug": "count-bowl-subarrays",
      "difficulty": "medium",
      "primaryPattern": "Stack",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "LIFO structure for nested patterns, matching pairs, or maintaining monotonic sequences."
  },
  3677: {
      "title": "Count Binary Palindromic Numbers",
      "slug": "count-binary-palindromic-numbers",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3678: {
      "title": "Smallest Absent Positive Greater Than Average",
      "slug": "smallest-absent-positive-greater-than-average",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3679: {
      "title": " Minimum Discards to Balance Inventory",
      "slug": "minimum-discards-to-balance-inventory",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Sliding Window"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3680: {
      "title": "Generate Schedule",
      "slug": "generate-schedule",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  3681: {
      "title": "Maximum XOR of Subsequences",
      "slug": "maximum-xor-of-subsequences",
      "difficulty": "hard",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  3683: {
      "title": "Earliest Time to Finish One Task",
      "slug": "earliest-time-to-finish-one-task",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3684: {
      "title": "Maximize Sum of At Most K Distinct Elements",
      "slug": "maximize-sum-of-at-most-k-distinct-elements",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Greedy",
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3685: {
      "title": "Subsequence Sum After Capping Elements",
      "slug": "subsequence-sum-after-capping-elements",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map",
          "Dynamic Programming"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  3686: {
      "title": "Number of Stable Subsequences",
      "slug": "number-of-stable-subsequences",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3688: {
      "title": "Bitwise OR of Even Numbers in an Array",
      "slug": "bitwise-or-of-even-numbers-in-an-array",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3689: {
      "title": "Maximum Total Subarray Value I",
      "slug": "maximum-total-subarray-value-i",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  3690: {
      "title": "Split and Merge Array Transformation",
      "slug": "split-and-merge-array-transformation",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "BFS"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3691: {
      "title": "Maximum Total Subarray Value II",
      "slug": "maximum-total-subarray-value-ii",
      "difficulty": "hard",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Heap/Priority Queue"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  3692: {
      "title": "Majority Frequency Characters",
      "slug": "majority-frequency-characters",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3693: {
      "title": "Climbing Stairs II",
      "slug": "climbing-stairs-ii",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3694: {
      "title": "Distinct Points Reachable After Substring Removal",
      "slug": "distinct-points-reachable-after-substring-removal",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Sliding Window"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3695: {
      "title": "Maximize Alternating Sum Using Swaps",
      "slug": "maximize-alternating-sum-using-swaps",
      "difficulty": "hard",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Graph",
          "Two Pointers"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  3697: {
      "title": "Compute Decimal Representation",
      "slug": "compute-decimal-representation",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3698: {
      "title": "Split Array With Minimum Difference",
      "slug": "split-array-with-minimum-difference",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3699: {
      "title": "Number of ZigZag Arrays I",
      "slug": "number-of-zigzag-arrays-i",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3700: {
      "title": "Number of ZigZag Arrays II",
      "slug": "number-of-zigzag-arrays-ii",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3701: {
      "title": "Compute Alternating Sum",
      "slug": "compute-alternating-sum",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3702: {
      "title": "Longest Subsequence With Non-Zero Bitwise XOR",
      "slug": "longest-subsequence-with-non-zero-bitwise-xor",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3703: {
      "title": "Remove K-Balanced Substrings",
      "slug": "remove-k-balanced-substrings",
      "difficulty": "medium",
      "primaryPattern": "Stack",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "LIFO structure for nested patterns, matching pairs, or maintaining monotonic sequences."
  },
  3704: {
      "title": "Count No-Zero Pairs That Sum to N",
      "slug": "count-no-zero-pairs-that-sum-to-n",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3705: {
      "title": "Find Golden Hour Customers",
      "slug": "find-golden-hour-customers",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3707: {
      "title": "Equal Score Substrings",
      "slug": "equal-score-substrings",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3708: {
      "title": "Longest Fibonacci Subarray",
      "slug": "longest-fibonacci-subarray",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3709: {
      "title": "Design Exam Scores Tracker",
      "slug": "design-exam-scores-tracker",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  3710: {
      "title": "Maximum Partition Factor",
      "slug": "maximum-partition-factor",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "DFS",
          "BFS",
          "Graph"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  3712: {
      "title": "Sum of Elements With Frequency Divisible by K",
      "slug": "sum-of-elements-with-frequency-divisible-by-k",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3713: {
      "title": "Longest Balanced Substring I",
      "slug": "longest-balanced-substring-i",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3714: {
      "title": "Longest Balanced Substring II",
      "slug": "longest-balanced-substring-ii",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3715: {
      "title": "Sum of Perfect Square Ancestors",
      "slug": "sum-of-perfect-square-ancestors",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Tree Traversal",
          "DFS"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3716: {
      "title": "Find Churn Risk Customers",
      "slug": "find-churn-risk-customers",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3718: {
      "title": "Smallest Missing Multiple of K",
      "slug": "smallest-missing-multiple-of-k",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3719: {
      "title": "Longest Balanced Subarray I",
      "slug": "longest-balanced-subarray-i",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Binary Search"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3720: {
      "title": "Lexicographically Smallest Permutation Greater Than Target",
      "slug": "lexicographically-smallest-permutation-greater-than-target",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Greedy"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3721: {
      "title": "Longest Balanced Subarray II",
      "slug": "longest-balanced-subarray-ii",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Binary Search"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3722: {
      "title": "Lexicographically Smallest String After Reverse",
      "slug": "lexicographically-smallest-string-after-reverse",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Binary Search"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  3723: {
      "title": "Maximize Sum of Squares of Digits",
      "slug": "maximize-sum-of-squares-of-digits",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  3724: {
      "title": "Minimum Operations to Transform Array",
      "slug": "minimum-operations-to-transform-array",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  3725: {
      "title": "Count Ways to Choose Coprime Integers from Rows",
      "slug": "count-ways-to-choose-coprime-integers-from-rows",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "DFS"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3726: {
      "title": "Remove Zeros in Decimal Representation",
      "slug": "remove-zeros-in-decimal-representation",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3727: {
      "title": "Maximum Alternating Sum of Squares",
      "slug": "maximum-alternating-sum-of-squares",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  3728: {
      "title": "Stable Subarrays With Equal Boundary and Interior Sum",
      "slug": "stable-subarrays-with-equal-boundary-and-interior-sum",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3729: {
      "title": "Count Distinct Subarrays Divisible by K in Sorted Array",
      "slug": "count-distinct-subarrays-divisible-by-k-in-sorted-array",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3731: {
      "title": "Find Missing Elements",
      "slug": "find-missing-elements",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3732: {
      "title": "Maximum Product of Three Elements After One Replacement",
      "slug": "maximum-product-of-three-elements-after-one-replacement",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  3733: {
      "title": "Minimum Time to Complete All Deliveries",
      "slug": "minimum-time-to-complete-all-deliveries",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  3734: {
      "title": "Lexicographically Smallest Palindromic Permutation Greater Than Target",
      "slug": "lexicographically-smallest-palindromic-permutation-greater-than-target",
      "difficulty": "hard",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  3736: {
      "title": "Minimum Moves to Equal Array Elements III",
      "slug": "minimum-moves-to-equal-array-elements-iii",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3737: {
      "title": "Count Subarrays With Majority Element I",
      "slug": "count-subarrays-with-majority-element-i",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Binary Search",
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3738: {
      "title": "Longest Non-Decreasing Subarray After Replacing at Most One Element",
      "slug": "longest-non-decreasing-subarray-after-replacing-at-most-one-element",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3739: {
      "title": "Count Subarrays With Majority Element II",
      "slug": "count-subarrays-with-majority-element-ii",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Binary Search",
          "Two Pointers"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3740: {
      "title": "Minimum Distance Between Three Equal Elements I",
      "slug": "minimum-distance-between-three-equal-elements-i",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3741: {
      "title": "Minimum Distance Between Three Equal Elements II",
      "slug": "minimum-distance-between-three-equal-elements-ii",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3742: {
      "title": "Maximum Path Score in a Grid",
      "slug": "maximum-path-score-in-a-grid",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "DFS"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3743: {
      "title": "Maximize Cyclic Partition Score",
      "slug": "maximize-cyclic-partition-score",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3745: {
      "title": "Maximize Expression of Three Elements",
      "slug": "maximize-expression-of-three-elements",
      "difficulty": "easy",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  3746: {
      "title": "Minimum String Length After Balanced Removals",
      "slug": "minimum-string-length-after-balanced-removals",
      "difficulty": "medium",
      "primaryPattern": "Stack",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "LIFO structure for nested patterns, matching pairs, or maintaining monotonic sequences."
  },
  3747: {
      "title": "Count Distinct Integers After Removing Zeros",
      "slug": "count-distinct-integers-after-removing-zeros",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3748: {
      "title": "Count Stable Subarrays",
      "slug": "count-stable-subarrays",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  3750: {
      "title": "Minimum Number of Flips to Reverse Binary String",
      "slug": "minimum-number-of-flips-to-reverse-binary-string",
      "difficulty": "easy",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  3751: {
      "title": "Total Waviness of Numbers in Range I",
      "slug": "total-waviness-of-numbers-in-range-i",
      "difficulty": "medium",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3752: {
      "title": "Lexicographically Smallest Negated Permutation that Sums to Target",
      "slug": "lexicographically-smallest-negated-permutation-that-sums-to-target",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map",
          "Greedy"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  3753: {
      "title": "Total Waviness of Numbers in Range II",
      "slug": "total-waviness-of-numbers-in-range-ii",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3754: {
      "title": "Concatenate Non-Zero Digits and Multiply by Sum I",
      "slug": "concatenate-non-zero-digits-and-multiply-by-sum-i",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3755: {
      "title": "Find Maximum Balanced XOR Subarray Length",
      "slug": "find-maximum-balanced-xor-subarray-length",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3756: {
      "title": "Concatenate Non-Zero Digits and Multiply by Sum II",
      "slug": "concatenate-non-zero-digits-and-multiply-by-sum-ii",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3757: {
      "title": "Number of Effective Subsequences",
      "slug": "number-of-effective-subsequences",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3759: {
      "title": "Count Elements With at Least K Greater Values",
      "slug": "count-elements-with-at-least-k-greater-values",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers",
          "Heap/Priority Queue"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  3760: {
      "title": "Maximum Substrings With Distinct Start",
      "slug": "maximum-substrings-with-distinct-start",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3761: {
      "title": "Minimum Absolute Distance Between Mirror Pairs",
      "slug": "minimum-absolute-distance-between-mirror-pairs",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3762: {
      "title": "Minimum Operations to Equalize Subarrays",
      "slug": "minimum-operations-to-equalize-subarrays",
      "difficulty": "hard",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  3764: {
      "title": "Most Common Course Pairs",
      "slug": "most-common-course-pairs",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3765: {
      "title": "Complete Prime Number",
      "slug": "complete-prime-number",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3766: {
      "title": "Minimum Operations to Make Binary Palindrome",
      "slug": "minimum-operations-to-make-binary-palindrome",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map",
          "Binary Search"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  3767: {
      "title": "Maximize Points After Choosing K Tasks",
      "slug": "maximize-points-after-choosing-k-tasks",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers",
          "Heap/Priority Queue"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  3768: {
      "title": "Minimum Inversion Count in Subarrays of Fixed Length",
      "slug": "minimum-inversion-count-in-subarrays-of-fixed-length",
      "difficulty": "hard",
      "primaryPattern": "Sliding Window",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Maintain a window of elements that slides through the array. Expand when adding elements, contract when removing. Track window state."
  },
  3769: {
      "title": "Sort Integers by Binary Reflection",
      "slug": "sort-integers-by-binary-reflection",
      "difficulty": "easy",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  3770: {
      "title": "Largest Prime from Consecutive Prime Sum",
      "slug": "largest-prime-from-consecutive-prime-sum",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3771: {
      "title": "Total Score of Dungeon Runs",
      "slug": "total-score-of-dungeon-runs",
      "difficulty": "medium",
      "primaryPattern": "Binary Search",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Divide and conquer on sorted data. Repeatedly halve the search space by comparing with middle element."
  },
  3772: {
      "title": "Maximum Subgraph Score in a Tree",
      "slug": "maximum-subgraph-score-in-a-tree",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "Tree Traversal",
          "DFS"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3774: {
      "title": "Absolute Difference Between Maximum and Minimum K Elements",
      "slug": "absolute-difference-between-maximum-and-minimum-k-elements",
      "difficulty": "easy",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  3775: {
      "title": "Reverse Words With Same Vowel Count",
      "slug": "reverse-words-with-same-vowel-count",
      "difficulty": "medium",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  3776: {
      "title": "Minimum Moves to Balance Circular Array",
      "slug": "minimum-moves-to-balance-circular-array",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  3777: {
      "title": "Minimum Deletions to Make Alternating Substring",
      "slug": "minimum-deletions-to-make-alternating-substring",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3779: {
      "title": "Minimum Number of Operations to Have Distinct Elements",
      "slug": "minimum-number-of-operations-to-have-distinct-elements",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3780: {
      "title": "Maximum Sum of Three Numbers Divisible by Three",
      "slug": "maximum-sum-of-three-numbers-divisible-by-three",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers",
          "Heap/Priority Queue"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  3781: {
      "title": "Maximum Score After Binary Swaps",
      "slug": "maximum-score-after-binary-swaps",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map",
          "Heap/Priority Queue"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  3782: {
      "title": "Last Remaining Integer After Alternating Deletion Operations",
      "slug": "last-remaining-integer-after-alternating-deletion-operations",
      "difficulty": "hard",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  3783: {
      "title": "Mirror Distance of an Integer",
      "slug": "mirror-distance-of-an-integer",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3784: {
      "title": "Minimum Deletion Cost to Make All Characters Equal",
      "slug": "minimum-deletion-cost-to-make-all-characters-equal",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3785: {
      "title": "Minimum Swaps to Avoid Forbidden Values",
      "slug": "minimum-swaps-to-avoid-forbidden-values",
      "difficulty": "hard",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Greedy"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3786: {
      "title": "Total Sum of Interaction Cost in Tree Groups",
      "slug": "total-sum-of-interaction-cost-in-tree-groups",
      "difficulty": "hard",
      "primaryPattern": "DFS",
      "acceptablePatterns": [
          "Hash Map",
          "Tree Traversal"
      ],
      "explanation": "Depth-first search - explore as deep as possible before backtracking. Use recursion or stack for implementation."
  },
  3788: {
      "title": "Maximum Score of a Split",
      "slug": "maximum-score-of-a-split",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3789: {
      "title": "Minimum Cost to Acquire Required Items",
      "slug": "minimum-cost-to-acquire-required-items",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  3790: {
      "title": "Smallest All-Ones Multiple",
      "slug": "smallest-all-ones-multiple",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3791: {
      "title": "Number of Balanced Integers in a Range",
      "slug": "number-of-balanced-integers-in-a-range",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3793: {
      "title": "Find Users with High Token Usage",
      "slug": "find-users-with-high-token-usage",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3794: {
      "title": "Reverse String Prefix",
      "slug": "reverse-string-prefix",
      "difficulty": "easy",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  },
  3795: {
      "title": "Minimum Subarray Length With Distinct Sum At Least K",
      "slug": "minimum-subarray-length-with-distinct-sum-at-least-k",
      "difficulty": "medium",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [
          "Sliding Window"
      ],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3796: {
      "title": "Find Maximum Value in a Constrained Sequence",
      "slug": "find-maximum-value-in-a-constrained-sequence",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  3797: {
      "title": "Count Routes to Climb a Rectangular Grid",
      "slug": "count-routes-to-climb-a-rectangular-grid",
      "difficulty": "hard",
      "primaryPattern": "Dynamic Programming",
      "acceptablePatterns": [
          "Hash Map",
          "DFS"
      ],
      "explanation": "Break problem into overlapping subproblems. Build solution bottom-up or top-down with memoization."
  },
  3798: {
      "title": "Largest Even Number",
      "slug": "largest-even-number",
      "difficulty": "easy",
      "primaryPattern": "Hash Map",
      "acceptablePatterns": [],
      "explanation": "Use hash map for O(1) lookups and frequency counting. Perfect for tracking seen elements or mapping relationships."
  },
  3799: {
      "title": "Word Squares II",
      "slug": "word-squares-ii",
      "difficulty": "medium",
      "primaryPattern": "Backtracking",
      "acceptablePatterns": [
          "Hash Map",
          "Two Pointers"
      ],
      "explanation": "Explore all possible solutions recursively. Build candidates incrementally and abandon paths that cannot lead to solution."
  },
  3800: {
      "title": "Minimum Cost to Make Two Binary Strings Equal",
      "slug": "minimum-cost-to-make-two-binary-strings-equal",
      "difficulty": "medium",
      "primaryPattern": "Greedy",
      "acceptablePatterns": [
          "Hash Map"
      ],
      "explanation": "Make locally optimal choice at each step. Works when local optimum leads to global optimum."
  },
  3801: {
      "title": "Minimum Cost to Merge Sorted Lists",
      "slug": "minimum-cost-to-merge-sorted-lists",
      "difficulty": "hard",
      "primaryPattern": "Two Pointers",
      "acceptablePatterns": [
          "Hash Map",
          "Binary Search",
          "Dynamic Programming"
      ],
      "explanation": "Two pointers technique - use multiple indices to traverse the data structure efficiently, often from opposite ends or at different speeds."
  }
};

function getProblem(leetcodeId) {
  return PROBLEM_DATABASE[leetcodeId] || null;
}

function getProblemBySlug(slug) {
  for (const id in PROBLEM_DATABASE) {
    if (PROBLEM_DATABASE[id].slug === slug) {
      return { leetcodeId: parseInt(id), ...PROBLEM_DATABASE[id] };
    }
  }
  return null;
}

if (typeof module !== 'undefined' && module.exports) {
  module.exports = { PROBLEM_DATABASE, getProblem, getProblemBySlug };
}
